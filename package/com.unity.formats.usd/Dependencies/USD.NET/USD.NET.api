// This file is generated. Do not modify by hand.
// XML documentation file not found. To check if public methods have XML comments,
// make sure the XML doc file is present and located next to the scraped dll
public static class SdfValueTypeNames
{
    public static pxr.SdfValueTypeName Asset;
    public static pxr.SdfValueTypeName AssetArray;
    public static pxr.SdfValueTypeName Bool;
    public static pxr.SdfValueTypeName BoolArray;
    public static pxr.SdfValueTypeName Color3d;
    public static pxr.SdfValueTypeName Color3dArray;
    public static pxr.SdfValueTypeName Color3f;
    public static pxr.SdfValueTypeName Color3fArray;
    public static pxr.SdfValueTypeName Color3h;
    public static pxr.SdfValueTypeName Color3hArray;
    public static pxr.SdfValueTypeName Color4d;
    public static pxr.SdfValueTypeName Color4dArray;
    public static pxr.SdfValueTypeName Color4f;
    public static pxr.SdfValueTypeName Color4fArray;
    public static pxr.SdfValueTypeName Color4h;
    public static pxr.SdfValueTypeName Color4hArray;
    public static pxr.SdfValueTypeName Double;
    public static pxr.SdfValueTypeName Double2;
    public static pxr.SdfValueTypeName Double2Array;
    public static pxr.SdfValueTypeName Double3;
    public static pxr.SdfValueTypeName Double3Array;
    public static pxr.SdfValueTypeName Double4;
    public static pxr.SdfValueTypeName Double4Array;
    public static pxr.SdfValueTypeName DoubleArray;
    public static pxr.SdfValueTypeName Float;
    public static pxr.SdfValueTypeName Float2;
    public static pxr.SdfValueTypeName Float2Array;
    public static pxr.SdfValueTypeName Float3;
    public static pxr.SdfValueTypeName Float3Array;
    public static pxr.SdfValueTypeName Float4;
    public static pxr.SdfValueTypeName Float4Array;
    public static pxr.SdfValueTypeName FloatArray;
    public static pxr.SdfValueTypeName Frame4d;
    public static pxr.SdfValueTypeName Frame4dArray;
    public static pxr.SdfValueTypeName Half;
    public static pxr.SdfValueTypeName Half2;
    public static pxr.SdfValueTypeName Half2Array;
    public static pxr.SdfValueTypeName Half3;
    public static pxr.SdfValueTypeName Half3Array;
    public static pxr.SdfValueTypeName Half4;
    public static pxr.SdfValueTypeName Half4Array;
    public static pxr.SdfValueTypeName HalfArray;
    public static pxr.SdfValueTypeName Int;
    public static pxr.SdfValueTypeName Int2;
    public static pxr.SdfValueTypeName Int2Array;
    public static pxr.SdfValueTypeName Int3;
    public static pxr.SdfValueTypeName Int3Array;
    public static pxr.SdfValueTypeName Int4;
    public static pxr.SdfValueTypeName Int4Array;
    public static pxr.SdfValueTypeName Int64;
    public static pxr.SdfValueTypeName Int64Array;
    public static pxr.SdfValueTypeName IntArray;
    public static pxr.SdfValueTypeName Matrix2d;
    public static pxr.SdfValueTypeName Matrix2dArray;
    public static pxr.SdfValueTypeName Matrix3d;
    public static pxr.SdfValueTypeName Matrix3dArray;
    public static pxr.SdfValueTypeName Matrix4d;
    public static pxr.SdfValueTypeName Matrix4dArray;
    public static pxr.SdfValueTypeName Normal3d;
    public static pxr.SdfValueTypeName Normal3dArray;
    public static pxr.SdfValueTypeName Normal3f;
    public static pxr.SdfValueTypeName Normal3fArray;
    public static pxr.SdfValueTypeName Normal3h;
    public static pxr.SdfValueTypeName Normal3hArray;
    public static pxr.SdfValueTypeName Point3d;
    public static pxr.SdfValueTypeName Point3dArray;
    public static pxr.SdfValueTypeName Point3f;
    public static pxr.SdfValueTypeName Point3fArray;
    public static pxr.SdfValueTypeName Point3h;
    public static pxr.SdfValueTypeName Point3hArray;
    public static pxr.SdfValueTypeName Quatd;
    public static pxr.SdfValueTypeName QuatdArray;
    public static pxr.SdfValueTypeName Quatf;
    public static pxr.SdfValueTypeName QuatfArray;
    public static pxr.SdfValueTypeName Quath;
    public static pxr.SdfValueTypeName QuathArray;
    public static pxr.SdfValueTypeName String;
    public static pxr.SdfValueTypeName StringArray;
    public static pxr.SdfValueTypeName TexCoord2d;
    public static pxr.SdfValueTypeName TexCoord2dArray;
    public static pxr.SdfValueTypeName TexCoord2f;
    public static pxr.SdfValueTypeName TexCoord2fArray;
    public static pxr.SdfValueTypeName TexCoord2h;
    public static pxr.SdfValueTypeName TexCoord2hArray;
    public static pxr.SdfValueTypeName TexCoord3d;
    public static pxr.SdfValueTypeName TexCoord3dArray;
    public static pxr.SdfValueTypeName TexCoord3f;
    public static pxr.SdfValueTypeName TexCoord3fArray;
    public static pxr.SdfValueTypeName TexCoord3h;
    public static pxr.SdfValueTypeName TexCoord3hArray;
    public static pxr.SdfValueTypeName TimeCode;
    public static pxr.SdfValueTypeName TimeCodeArray;
    public static pxr.SdfValueTypeName Token;
    public static pxr.SdfValueTypeName TokenArray;
    public static pxr.SdfValueTypeName UChar;
    public static pxr.SdfValueTypeName UCharArray;
    public static pxr.SdfValueTypeName UInt;
    public static pxr.SdfValueTypeName UInt64;
    public static pxr.SdfValueTypeName UInt64Array;
    public static pxr.SdfValueTypeName UIntArray;
    public static pxr.SdfValueTypeName Vector3d;
    public static pxr.SdfValueTypeName Vector3dArray;
    public static pxr.SdfValueTypeName Vector3f;
    public static pxr.SdfValueTypeName Vector3fArray;
    public static pxr.SdfValueTypeName Vector3h;
    public static pxr.SdfValueTypeName Vector3hArray;
}

namespace pxr
{
    public class ArResolverContext : System.IDisposable
    {
        protected bool swigCMemOwn;
        public ArResolverContext() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public string GetDebugString();
        public bool IsEmpty();
    }

    public abstract class DiagnosticHandler : System.IDisposable
    {
        public DiagnosticHandler() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public abstract void OnError(string msg);
        public abstract void OnFatalError(string msg);
        public abstract void OnInfo(string msg);
        public abstract void OnWarning(string msg);
    }

    public class GfBBox3d : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfBBox3d() {}
        public GfBBox3d(pxr.GfBBox3d rhs) {}
        public GfBBox3d(pxr.GfRange3d box) {}
        public GfBBox3d(pxr.GfRange3d box, pxr.GfMatrix4d matrix) {}
        public static pxr.GfBBox3d Combine(pxr.GfBBox3d b1, pxr.GfBBox3d b2);
        public pxr.GfRange3d ComputeAlignedBox();
        public pxr.GfRange3d ComputeAlignedRange();
        public pxr.GfVec3d ComputeCentroid();
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfBBox3d lhs, pxr.GfBBox3d rhs);
        protected virtual void Finalize();
        public pxr.GfRange3d GetBox();
        public virtual int GetHashCode();
        public pxr.GfMatrix4d GetInverseMatrix();
        public pxr.GfMatrix4d GetMatrix();
        public pxr.GfRange3d GetRange();
        public double GetVolume();
        public bool HasZeroAreaPrimitives();
        public static bool operator ==(pxr.GfBBox3d lhs, pxr.GfBBox3d rhs);
        public static bool operator !=(pxr.GfBBox3d lhs, pxr.GfBBox3d rhs);
        public void Set(pxr.GfRange3d box, pxr.GfMatrix4d matrix);
        public void SetHasZeroAreaPrimitives(bool hasThem);
        public void SetMatrix(pxr.GfMatrix4d matrix);
        public void SetRange(pxr.GfRange3d box);
        public void Transform(pxr.GfMatrix4d matrix);
    }

    public class GfCamera : System.IDisposable
    {
        protected bool swigCMemOwn;
        public static double APERTURE_UNIT { get; }
        public static double DEFAULT_HORIZONTAL_APERTURE { get; }
        public static double DEFAULT_VERTICAL_APERTURE { get; }
        public static double FOCAL_LENGTH_UNIT { get; }
        public GfCamera() {}
        public GfCamera(pxr.GfMatrix4d transform) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset, float focalLength) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset, float focalLength, pxr.GfRange1f clippingRange) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset, float focalLength, pxr.GfRange1f clippingRange, pxr.GfVec4fVector clippingPlanes) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset, float focalLength, pxr.GfRange1f clippingRange, pxr.GfVec4fVector clippingPlanes, float fStop) {}
        public GfCamera(pxr.GfMatrix4d transform, pxr.GfCamera.Projection projection, float horizontalAperture, float verticalAperture, float horizontalApertureOffset, float verticalApertureOffset, float focalLength, pxr.GfRange1f clippingRange, pxr.GfVec4fVector clippingPlanes, float fStop, float focusDistance) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfCamera lhs, pxr.GfCamera rhs);
        protected virtual void Finalize();
        public float GetAspectRatio();
        public pxr.GfVec4fVector GetClippingPlanes();
        public pxr.GfRange1f GetClippingRange();
        public float GetFieldOfView(pxr.GfCamera.FOVDirection direction);
        public float GetFocalLength();
        public float GetFocusDistance();
        public pxr.GfFrustum GetFrustum();
        public float GetFStop();
        public virtual int GetHashCode();
        public float GetHorizontalAperture();
        public float GetHorizontalApertureOffset();
        public pxr.GfCamera.Projection GetProjection();
        public pxr.GfMatrix4d GetTransform();
        public float GetVerticalAperture();
        public float GetVerticalApertureOffset();
        public static bool operator ==(pxr.GfCamera lhs, pxr.GfCamera rhs);
        public static bool operator !=(pxr.GfCamera lhs, pxr.GfCamera rhs);
        public void SetClippingPlanes(pxr.GfVec4fVector val);
        public void SetClippingRange(pxr.GfRange1f val);
        public void SetFocalLength(float val);
        public void SetFocusDistance(float val);
        public void SetFStop(float val);
        public void SetHorizontalAperture(float val);
        public void SetHorizontalApertureOffset(float val);
        public void SetOrthographicFromAspectRatioAndSize(float aspectRatio, float orthographicSize, pxr.GfCamera.FOVDirection direction);
        public void SetPerspectiveFromAspectRatioAndFieldOfView(float aspectRatio, float fieldOfView, pxr.GfCamera.FOVDirection direction);
        public void SetPerspectiveFromAspectRatioAndFieldOfView(float aspectRatio, float fieldOfView, pxr.GfCamera.FOVDirection direction, float horizontalAperture);
        public void SetProjection(pxr.GfCamera.Projection val);
        public void SetTransform(pxr.GfMatrix4d val);
        public void SetVerticalAperture(float val);
        public void SetVerticalApertureOffset(float val);
        public enum FOVDirection
        {
            public const pxr.GfCamera.FOVDirection FOVHorizontal = 0;
            public const pxr.GfCamera.FOVDirection FOVVertical = 1;
            public int value__;
        }
        public enum Projection
        {
            public const pxr.GfCamera.Projection Orthographic = 1;
            public const pxr.GfCamera.Projection Perspective = 0;
            public int value__;
        }
    }

    public class GfFrustum : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfFrustum() {}
        public GfFrustum(pxr.GfMatrix4d camToWorldXf, pxr.GfRange2d window, pxr.GfRange1d nearFar, pxr.GfFrustum.ProjectionType projectionType) {}
        public GfFrustum(pxr.GfMatrix4d camToWorldXf, pxr.GfRange2d window, pxr.GfRange1d nearFar, pxr.GfFrustum.ProjectionType projectionType, double viewDistance) {}
        public GfFrustum(pxr.GfVec3d position, pxr.GfRotation rotation, pxr.GfRange2d window, pxr.GfRange1d nearFar, pxr.GfFrustum.ProjectionType projectionType) {}
        public GfFrustum(pxr.GfVec3d position, pxr.GfRotation rotation, pxr.GfRange2d window, pxr.GfRange1d nearFar, pxr.GfFrustum.ProjectionType projectionType, double viewDistance) {}
        public double ComputeAspectRatio();
        public pxr.GfVec3dVector ComputeCorners();
        public pxr.GfVec3dVector ComputeCornersAtDistance(double d);
        public pxr.GfVec3d ComputeLookAtPoint();
        public pxr.GfFrustum ComputeNarrowedFrustum(pxr.GfVec2d point, pxr.GfVec2d halfSize);
        public pxr.GfFrustum ComputeNarrowedFrustum(pxr.GfVec3d worldPoint, pxr.GfVec2d halfSize);
        public pxr.GfRay ComputePickRay(pxr.GfVec2d windowPos);
        public pxr.GfRay ComputePickRay(pxr.GfVec3d worldSpacePos);
        public pxr.GfMatrix4d ComputeProjectionMatrix();
        public pxr.GfRay ComputeRay(pxr.GfVec2d windowPos);
        public pxr.GfRay ComputeRay(pxr.GfVec3d worldSpacePos);
        public pxr.GfVec3d ComputeUpVector();
        public pxr.GfVec3d ComputeViewDirection();
        public void ComputeViewFrame(pxr.GfVec3d side, pxr.GfVec3d up, pxr.GfVec3d view);
        public pxr.GfMatrix4d ComputeViewInverse();
        public pxr.GfMatrix4d ComputeViewMatrix();
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfFrustum lhs, pxr.GfFrustum rhs);
        protected virtual void Finalize();
        public void FitToSphere(pxr.GfVec3d center, double radius);
        public void FitToSphere(pxr.GfVec3d center, double radius, double slack);
        public double GetFOV();
        public double GetFOV(bool isFovVertical);
        public virtual int GetHashCode();
        public pxr.GfRange1d GetNearFar();
        public bool GetOrthographic(out double left, out double right, out double bottom, out double top, out double nearPlane, out double farPlane);
        public bool GetPerspective(out double fieldOfViewHeight, out double aspectRatio, out double nearDistance, out double farDistance);
        public bool GetPerspective(bool isFovVertical, out double fieldOfView, out double aspectRatio, out double nearDistance, out double farDistance);
        public pxr.GfVec3d GetPosition();
        public pxr.GfFrustum.ProjectionType GetProjectionType();
        public static double GetReferencePlaneDepth();
        public pxr.GfRotation GetRotation();
        public double GetViewDistance();
        public pxr.GfRange2d GetWindow();
        public bool Intersects(pxr.GfBBox3d bbox);
        public bool Intersects(pxr.GfVec3d point);
        public bool Intersects(pxr.GfVec3d p0, pxr.GfVec3d p1);
        public bool Intersects(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2);
        public static bool IntersectsViewVolume(pxr.GfBBox3d bbox, pxr.GfMatrix4d vpMat);
        public static bool operator ==(pxr.GfFrustum lhs, pxr.GfFrustum rhs);
        public static bool operator !=(pxr.GfFrustum lhs, pxr.GfFrustum rhs);
        public void SetNearFar(pxr.GfRange1d nearFar);
        public void SetOrthographic(double left, double right, double bottom, double top, double nearPlane, double farPlane);
        public void SetPerspective(double fieldOfViewHeight, double aspectRatio, double nearDistance, double farDistance);
        public void SetPerspective(double fieldOfView, bool isFovVertical, double aspectRatio, double nearDistance, double farDistance);
        public void SetPosition(pxr.GfVec3d position);
        public void SetPositionAndRotationFromMatrix(pxr.GfMatrix4d camToWorldXf);
        public void SetProjectionType(pxr.GfFrustum.ProjectionType projectionType);
        public void SetRotation(pxr.GfRotation rotation);
        public void SetViewDistance(double viewDistance);
        public void SetWindow(pxr.GfRange2d window);
        public pxr.GfFrustum Transform(pxr.GfMatrix4d matrix);
        public enum ProjectionType
        {
            public const pxr.GfFrustum.ProjectionType Orthographic = 0;
            public const pxr.GfFrustum.ProjectionType Perspective = 1;
            public int value__;
        }
    }

    public class GfHalf : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfHalf() {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfHalf lhs, pxr.GfHalf rhs);
        protected virtual void Finalize();
        public virtual int GetHashCode();
        public static bool operator ==(pxr.GfHalf lhs, pxr.GfHalf rhs);
        public static bool operator !=(pxr.GfHalf lhs, pxr.GfHalf rhs);
    }

    public class GfInterval : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfInterval() {}
        public GfInterval(double val) {}
        public GfInterval(double min, double max) {}
        public GfInterval(double min, double max, bool minClosed) {}
        public GfInterval(double min, double max, bool minClosed, bool maxClosed) {}
        public bool Contains(pxr.GfInterval i);
        public bool Contains(double d);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfInterval lhs, pxr.GfInterval rhs);
        protected virtual void Finalize();
        public static pxr.GfInterval GetFullInterval();
        public virtual int GetHashCode();
        public double GetMax();
        public double GetMin();
        public double GetSize();
        public System.UInt32 Hash();
        public bool In(double d);
        public bool Intersects(pxr.GfInterval i);
        public bool IsEmpty();
        public bool IsFinite();
        public bool IsMaxClosed();
        public bool IsMaxFinite();
        public bool IsMaxOpen();
        public bool IsMinClosed();
        public bool IsMinFinite();
        public bool IsMinOpen();
        public static bool operator ==(pxr.GfInterval lhs, pxr.GfInterval rhs);
        public static bool operator !=(pxr.GfInterval lhs, pxr.GfInterval rhs);
        public void SetMax(double v);
        public void SetMax(double v, bool maxClosed);
        public void SetMin(double v);
        public void SetMin(double v, bool minClosed);
        public double Size();
    }

    public class GfLine : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfLine() {}
        public GfLine(pxr.GfVec3d p0, pxr.GfVec3d dir) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfLine lhs, pxr.GfLine rhs);
        protected virtual void Finalize();
        public pxr.GfVec3d FindClosestPoint(pxr.GfVec3d point);
        public pxr.GfVec3d FindClosestPoint(pxr.GfVec3d point, out double t);
        public pxr.GfVec3d GetDirection();
        public virtual int GetHashCode();
        public pxr.GfVec3d GetPoint(double t);
        public static bool operator ==(pxr.GfLine lhs, pxr.GfLine rhs);
        public static bool operator !=(pxr.GfLine lhs, pxr.GfLine rhs);
        public double Set(pxr.GfVec3d p0, pxr.GfVec3d dir);
    }

    public class GfLineSeg : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfLineSeg() {}
        public GfLineSeg(pxr.GfVec3d p0, pxr.GfVec3d p1) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfLineSeg lhs, pxr.GfLineSeg rhs);
        protected virtual void Finalize();
        public pxr.GfVec3d FindClosestPoint(pxr.GfVec3d point);
        public pxr.GfVec3d FindClosestPoint(pxr.GfVec3d point, out double t);
        public pxr.GfVec3d GetDirection();
        public virtual int GetHashCode();
        public double GetLength();
        public pxr.GfVec3d GetPoint(double t);
        public static bool operator ==(pxr.GfLineSeg lhs, pxr.GfLineSeg rhs);
        public static bool operator !=(pxr.GfLineSeg lhs, pxr.GfLineSeg rhs);
    }

    public class GfMatrix2d : System.IDisposable
    {
        public static readonly System.UInt32 numColumns;
        public static readonly System.UInt32 numRows;
        protected bool swigCMemOwn;
        public GfMatrix2d() {}
        public GfMatrix2d(pxr.GfMatrix2f m) {}
        public GfMatrix2d(pxr.GfVec2d v) {}
        public GfMatrix2d(pxr.StdDoubleVectorVector v) {}
        public GfMatrix2d(pxr.StdFloatVectorVector v) {}
        public GfMatrix2d(double s) {}
        public GfMatrix2d(int s) {}
        public GfMatrix2d(double m00, double m01, double m10, double m11) {}
        public void CopyFromArray(double[] src);
        public void CopyToArray(double[] dest);
        public pxr.SWIGTYPE_p_double data();
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfMatrix2d lhs, pxr.GfMatrix2d rhs);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_double Get(pxr.SWIGTYPE_p_a_2__double m);
        public pxr.GfVec2d GetColumn(int i);
        public double GetDeterminant();
        public virtual int GetHashCode();
        public pxr.GfMatrix2d GetInverse();
        public pxr.GfMatrix2d GetInverse(ref double det);
        public pxr.GfMatrix2d GetInverse(ref double det, double eps);
        public pxr.GfVec2d GetRow(int i);
        public pxr.GfMatrix2d GetTranspose();
        public static bool operator ==(pxr.GfMatrix2d lhs, pxr.GfMatrix2d rhs);
        public static bool operator !=(pxr.GfMatrix2d lhs, pxr.GfMatrix2d rhs);
        public pxr.GfMatrix2d Set(double m00, double m01, double m10, double m11);
        public void SetColumn(int i, pxr.GfVec2d v);
        public pxr.GfMatrix2d SetDiagonal(pxr.GfVec2d arg0);
        public pxr.GfMatrix2d SetDiagonal(double s);
        public pxr.GfMatrix2d SetIdentity();
        public void SetRow(int i, pxr.GfVec2d v);
        public pxr.GfMatrix2d SetZero();
        public virtual string ToString();
    }

    public class GfMatrix2f : System.IDisposable
    {
        public static readonly System.UInt32 numColumns;
        public static readonly System.UInt32 numRows;
        protected bool swigCMemOwn;
        public GfMatrix2f() {}
        public GfMatrix2f(pxr.GfMatrix2d m) {}
        public GfMatrix2f(pxr.GfVec2f v) {}
        public GfMatrix2f(pxr.StdDoubleVectorVector v) {}
        public GfMatrix2f(pxr.StdFloatVectorVector v) {}
        public GfMatrix2f(int s) {}
        public GfMatrix2f(float s) {}
        public GfMatrix2f(float m00, float m01, float m10, float m11) {}
        public void CopyFromArray(float[] src);
        public void CopyToArray(float[] dest);
        public pxr.SWIGTYPE_p_float data();
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfMatrix2f lhs, pxr.GfMatrix2f rhs);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_float Get(pxr.SWIGTYPE_p_a_2__float m);
        public pxr.GfVec2f GetColumn(int i);
        public double GetDeterminant();
        public virtual int GetHashCode();
        public pxr.GfMatrix2f GetInverse();
        public pxr.GfMatrix2f GetInverse(ref double det);
        public pxr.GfMatrix2f GetInverse(ref double det, double eps);
        public pxr.GfVec2f GetRow(int i);
        public pxr.GfMatrix2f GetTranspose();
        public static bool operator ==(pxr.GfMatrix2f lhs, pxr.GfMatrix2f rhs);
        public static bool operator !=(pxr.GfMatrix2f lhs, pxr.GfMatrix2f rhs);
        public pxr.GfMatrix2f Set(float m00, float m01, float m10, float m11);
        public void SetColumn(int i, pxr.GfVec2f v);
        public pxr.GfMatrix2f SetDiagonal(pxr.GfVec2f arg0);
        public pxr.GfMatrix2f SetDiagonal(float s);
        public pxr.GfMatrix2f SetIdentity();
        public void SetRow(int i, pxr.GfVec2f v);
        public pxr.GfMatrix2f SetZero();
        public virtual string ToString();
    }

    public class GfMatrix3d : System.IDisposable
    {
        public static readonly System.UInt32 numColumns;
        public static readonly System.UInt32 numRows;
        protected bool swigCMemOwn;
        public GfMatrix3d() {}
        public GfMatrix3d(pxr.GfMatrix3f m) {}
        public GfMatrix3d(pxr.GfQuatd rot) {}
        public GfMatrix3d(pxr.GfRotation rot) {}
        public GfMatrix3d(pxr.GfVec3d v) {}
        public GfMatrix3d(pxr.StdDoubleVectorVector v) {}
        public GfMatrix3d(pxr.StdFloatVectorVector v) {}
        public GfMatrix3d(double s) {}
        public GfMatrix3d(int s) {}
        public GfMatrix3d(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22) {}
        public void CopyFromArray(double[] src);
        public void CopyToArray(double[] dest);
        public pxr.SWIGTYPE_p_double data();
        public pxr.GfVec3d DecomposeRotation(pxr.GfVec3d axis0, pxr.GfVec3d axis1, pxr.GfVec3d axis2);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfMatrix3d lhs, pxr.GfMatrix3d rhs);
        public pxr.GfRotation ExtractRotation();
        public pxr.GfQuaternion ExtractRotationQuaternion();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_double Get(pxr.SWIGTYPE_p_a_3__double m);
        public pxr.GfVec3d GetColumn(int i);
        public double GetDeterminant();
        public double GetHandedness();
        public virtual int GetHashCode();
        public pxr.GfMatrix3d GetInverse();
        public pxr.GfMatrix3d GetInverse(ref double det);
        public pxr.GfMatrix3d GetInverse(ref double det, double eps);
        public pxr.GfMatrix3d GetOrthonormalized();
        public pxr.GfMatrix3d GetOrthonormalized(bool issueWarning);
        public pxr.GfVec3d GetRow(int i);
        public pxr.GfMatrix3d GetTranspose();
        public bool IsLeftHanded();
        public bool IsRightHanded();
        public static bool operator ==(pxr.GfMatrix3d lhs, pxr.GfMatrix3d rhs);
        public static bool operator !=(pxr.GfMatrix3d lhs, pxr.GfMatrix3d rhs);
        public bool Orthonormalize();
        public bool Orthonormalize(bool issueWarning);
        public pxr.GfMatrix3d Set(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22);
        public void SetColumn(int i, pxr.GfVec3d v);
        public pxr.GfMatrix3d SetDiagonal(pxr.GfVec3d arg0);
        public pxr.GfMatrix3d SetDiagonal(double s);
        public pxr.GfMatrix3d SetIdentity();
        public pxr.GfMatrix3d SetRotate(pxr.GfQuatd rot);
        public pxr.GfMatrix3d SetRotate(pxr.GfRotation rot);
        public void SetRow(int i, pxr.GfVec3d v);
        public pxr.GfMatrix3d SetScale(pxr.GfVec3d scaleFactors);
        public pxr.GfMatrix3d SetScale(double scaleFactor);
        public pxr.GfMatrix3d SetZero();
        public virtual string ToString();
    }

    public class GfMatrix3f : System.IDisposable
    {
        public static readonly System.UInt32 numColumns;
        public static readonly System.UInt32 numRows;
        protected bool swigCMemOwn;
        public GfMatrix3f() {}
        public GfMatrix3f(pxr.GfMatrix3d m) {}
        public GfMatrix3f(pxr.GfQuatf rot) {}
        public GfMatrix3f(pxr.GfRotation rot) {}
        public GfMatrix3f(pxr.GfVec3f v) {}
        public GfMatrix3f(pxr.StdDoubleVectorVector v) {}
        public GfMatrix3f(pxr.StdFloatVectorVector v) {}
        public GfMatrix3f(int s) {}
        public GfMatrix3f(float s) {}
        public GfMatrix3f(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22) {}
        public void CopyFromArray(float[] src);
        public void CopyToArray(float[] dest);
        public pxr.SWIGTYPE_p_float data();
        public pxr.GfVec3f DecomposeRotation(pxr.GfVec3f axis0, pxr.GfVec3f axis1, pxr.GfVec3f axis2);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfMatrix3f lhs, pxr.GfMatrix3f rhs);
        public pxr.GfRotation ExtractRotation();
        public pxr.GfQuaternion ExtractRotationQuaternion();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_float Get(pxr.SWIGTYPE_p_a_3__float m);
        public pxr.GfVec3f GetColumn(int i);
        public double GetDeterminant();
        public double GetHandedness();
        public virtual int GetHashCode();
        public pxr.GfMatrix3f GetInverse();
        public pxr.GfMatrix3f GetInverse(ref double det);
        public pxr.GfMatrix3f GetInverse(ref double det, double eps);
        public pxr.GfMatrix3f GetOrthonormalized();
        public pxr.GfMatrix3f GetOrthonormalized(bool issueWarning);
        public pxr.GfVec3f GetRow(int i);
        public pxr.GfMatrix3f GetTranspose();
        public bool IsLeftHanded();
        public bool IsRightHanded();
        public static bool operator ==(pxr.GfMatrix3f lhs, pxr.GfMatrix3f rhs);
        public static bool operator !=(pxr.GfMatrix3f lhs, pxr.GfMatrix3f rhs);
        public bool Orthonormalize();
        public bool Orthonormalize(bool issueWarning);
        public pxr.GfMatrix3f Set(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22);
        public void SetColumn(int i, pxr.GfVec3f v);
        public pxr.GfMatrix3f SetDiagonal(pxr.GfVec3f arg0);
        public pxr.GfMatrix3f SetDiagonal(float s);
        public pxr.GfMatrix3f SetIdentity();
        public pxr.GfMatrix3f SetRotate(pxr.GfQuatf rot);
        public pxr.GfMatrix3f SetRotate(pxr.GfRotation rot);
        public void SetRow(int i, pxr.GfVec3f v);
        public pxr.GfMatrix3f SetScale(pxr.GfVec3f scaleFactors);
        public pxr.GfMatrix3f SetScale(float scaleFactor);
        public pxr.GfMatrix3f SetZero();
        public virtual string ToString();
    }

    public class GfMatrix4d : System.IDisposable
    {
        public static readonly System.UInt32 numColumns;
        public static readonly System.UInt32 numRows;
        protected bool swigCMemOwn;
        public GfMatrix4d() {}
        public GfMatrix4d(pxr.GfMatrix4f m) {}
        public GfMatrix4d(pxr.GfVec4d v) {}
        public GfMatrix4d(pxr.StdDoubleVectorVector v) {}
        public GfMatrix4d(pxr.StdFloatVectorVector v) {}
        public GfMatrix4d(double s) {}
        public GfMatrix4d(pxr.GfMatrix3d rotmx, pxr.GfVec3d translate) {}
        public GfMatrix4d(pxr.GfRotation rotate, pxr.GfVec3d translate) {}
        public GfMatrix4d(pxr.StdDoubleVector r0, pxr.StdDoubleVector r1, pxr.StdDoubleVector r2, pxr.StdDoubleVector r3) {}
        public GfMatrix4d(pxr.StdFloatVector r0, pxr.StdFloatVector r1, pxr.StdFloatVector r2, pxr.StdFloatVector r3) {}
        public GfMatrix4d(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23, double m30, double m31, double m32, double m33) {}
        public void CopyFromArray(double[] src);
        public void CopyToArray(double[] dest);
        public pxr.SWIGTYPE_p_double data();
        public pxr.GfVec3d DecomposeRotation(pxr.GfVec3d axis0, pxr.GfVec3d axis1, pxr.GfVec3d axis2);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfMatrix4d lhs, pxr.GfMatrix4d rhs);
        public pxr.GfRotation ExtractRotation();
        public pxr.GfMatrix3d ExtractRotationMatrix();
        public pxr.GfQuatd ExtractRotationQuat();
        public pxr.GfVec3d ExtractTranslation();
        public bool Factor(pxr.GfMatrix4d r, pxr.GfVec3d s, pxr.GfMatrix4d u, pxr.GfVec3d t, pxr.GfMatrix4d p);
        public bool Factor(pxr.GfMatrix4d r, pxr.GfVec3d s, pxr.GfMatrix4d u, pxr.GfVec3d t, pxr.GfMatrix4d p, double eps);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_double Get(pxr.SWIGTYPE_p_a_4__double m);
        public pxr.GfVec4d GetColumn(int i);
        public double GetDeterminant();
        public double GetDeterminant3();
        public double GetHandedness();
        public virtual int GetHashCode();
        public pxr.GfMatrix4d GetInverse();
        public pxr.GfMatrix4d GetInverse(ref double det);
        public pxr.GfMatrix4d GetInverse(ref double det, double eps);
        public pxr.GfMatrix4d GetOrthonormalized();
        public pxr.GfMatrix4d GetOrthonormalized(bool issueWarning);
        public pxr.GfVec4d GetRow(int i);
        public pxr.GfVec3d GetRow3(int i);
        public pxr.GfMatrix4d GetTranspose();
        public bool HasOrthogonalRows3();
        public bool IsLeftHanded();
        public bool IsRightHanded();
        public static bool operator ==(pxr.GfMatrix4d lhs, pxr.GfMatrix4d rhs);
        public static bool operator !=(pxr.GfMatrix4d lhs, pxr.GfMatrix4d rhs);
        public bool Orthonormalize();
        public bool Orthonormalize(bool issueWarning);
        public pxr.GfMatrix4d RemoveScaleShear();
        public pxr.GfMatrix4d Set(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23, double m30, double m31, double m32, double m33);
        public void SetColumn(int i, pxr.GfVec4d v);
        public pxr.GfMatrix4d SetDiagonal(pxr.GfVec4d arg0);
        public pxr.GfMatrix4d SetDiagonal(double s);
        public pxr.GfMatrix4d SetIdentity();
        public pxr.GfMatrix4d SetLookAt(pxr.GfVec3d eyePoint, pxr.GfRotation orientation);
        public pxr.GfMatrix4d SetLookAt(pxr.GfVec3d eyePoint, pxr.GfVec3d centerPoint, pxr.GfVec3d upDirection);
        public pxr.GfMatrix4d SetRotate(pxr.GfMatrix3d mx);
        public pxr.GfMatrix4d SetRotate(pxr.GfQuatd rot);
        public pxr.GfMatrix4d SetRotate(pxr.GfRotation rot);
        public pxr.GfMatrix4d SetRotateOnly(pxr.GfMatrix3d mx);
        public pxr.GfMatrix4d SetRotateOnly(pxr.GfQuatd rot);
        public pxr.GfMatrix4d SetRotateOnly(pxr.GfRotation rot);
        public void SetRow(int i, pxr.GfVec4d v);
        public void SetRow3(int i, pxr.GfVec3d v);
        public pxr.GfMatrix4d SetScale(pxr.GfVec3d scaleFactors);
        public pxr.GfMatrix4d SetScale(double scaleFactor);
        public pxr.GfMatrix4d SetTransform(pxr.GfMatrix3d rotmx, pxr.GfVec3d translate);
        public pxr.GfMatrix4d SetTransform(pxr.GfRotation rotate, pxr.GfVec3d translate);
        public pxr.GfMatrix4d SetTranslate(pxr.GfVec3d trans);
        public pxr.GfMatrix4d SetTranslateOnly(pxr.GfVec3d t);
        public pxr.GfMatrix4d SetZero();
        public virtual string ToString();
        public pxr.GfVec3d Transform(pxr.GfVec3d vec);
        public pxr.GfVec3f Transform(pxr.GfVec3f vec);
        public pxr.GfVec3d TransformAffine(pxr.GfVec3d vec);
        public pxr.GfVec3f TransformAffine(pxr.GfVec3f vec);
        public pxr.GfVec3d TransformDir(pxr.GfVec3d vec);
        public pxr.GfVec3f TransformDir(pxr.GfVec3f vec);
    }

    public class GfMatrix4f : System.IDisposable
    {
        public static readonly System.UInt32 numColumns;
        public static readonly System.UInt32 numRows;
        protected bool swigCMemOwn;
        public GfMatrix4f() {}
        public GfMatrix4f(pxr.GfMatrix4d m) {}
        public GfMatrix4f(pxr.GfVec4f v) {}
        public GfMatrix4f(pxr.StdDoubleVectorVector v) {}
        public GfMatrix4f(pxr.StdFloatVectorVector v) {}
        public GfMatrix4f(float s) {}
        public GfMatrix4f(pxr.GfRotation rotate, pxr.GfVec3f translate) {}
        public GfMatrix4f(pxr.StdDoubleVector r0, pxr.StdDoubleVector r1, pxr.StdDoubleVector r2, pxr.StdDoubleVector r3) {}
        public GfMatrix4f(pxr.StdFloatVector r0, pxr.StdFloatVector r1, pxr.StdFloatVector r2, pxr.StdFloatVector r3) {}
        public GfMatrix4f(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23, float m30, float m31, float m32, float m33) {}
        public void CopyFromArray(float[] src);
        public void CopyToArray(float[] dest);
        public pxr.SWIGTYPE_p_float data();
        public pxr.GfVec3f DecomposeRotation(pxr.GfVec3f axis0, pxr.GfVec3f axis1, pxr.GfVec3f axis2);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfMatrix4f lhs, pxr.GfMatrix4f rhs);
        public pxr.GfRotation ExtractRotation();
        public pxr.GfMatrix3f ExtractRotationMatrix();
        public pxr.GfQuatf ExtractRotationQuat();
        public pxr.GfVec3f ExtractTranslation();
        public bool Factor(pxr.GfMatrix4f r, pxr.GfVec3f s, pxr.GfMatrix4f u, pxr.GfVec3f t, pxr.GfMatrix4f p);
        public bool Factor(pxr.GfMatrix4f r, pxr.GfVec3f s, pxr.GfMatrix4f u, pxr.GfVec3f t, pxr.GfMatrix4f p, float eps);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_float Get(pxr.SWIGTYPE_p_a_4__float m);
        public pxr.GfVec4f GetColumn(int i);
        public double GetDeterminant();
        public double GetDeterminant3();
        public double GetHandedness();
        public virtual int GetHashCode();
        public pxr.GfMatrix4f GetInverse();
        public pxr.GfMatrix4f GetInverse(ref double det);
        public pxr.GfMatrix4f GetInverse(ref double det, double eps);
        public pxr.GfMatrix4f GetOrthonormalized();
        public pxr.GfMatrix4f GetOrthonormalized(bool issueWarning);
        public pxr.GfVec4f GetRow(int i);
        public pxr.GfVec3f GetRow3(int i);
        public pxr.GfMatrix4f GetTranspose();
        public bool HasOrthogonalRows3();
        public bool IsLeftHanded();
        public bool IsRightHanded();
        public static bool operator ==(pxr.GfMatrix4f lhs, pxr.GfMatrix4f rhs);
        public static bool operator !=(pxr.GfMatrix4f lhs, pxr.GfMatrix4f rhs);
        public bool Orthonormalize();
        public bool Orthonormalize(bool issueWarning);
        public pxr.GfMatrix4f Set(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23, float m30, float m31, float m32, float m33);
        public void SetColumn(int i, pxr.GfVec4f v);
        public pxr.GfMatrix4f SetDiagonal(pxr.GfVec4f arg0);
        public pxr.GfMatrix4f SetDiagonal(float s);
        public pxr.GfMatrix4f SetIdentity();
        public pxr.GfMatrix4f SetLookAt(pxr.GfVec3f eyePoint, pxr.GfRotation orientation);
        public pxr.GfMatrix4f SetLookAt(pxr.GfVec3f eyePoint, pxr.GfVec3f centerPoint, pxr.GfVec3f upDirection);
        public pxr.GfMatrix4f SetRotate(pxr.GfMatrix3f mx);
        public pxr.GfMatrix4f SetRotate(pxr.GfQuatf rot);
        public pxr.GfMatrix4f SetRotate(pxr.GfRotation rot);
        public pxr.GfMatrix4f SetRotateOnly(pxr.GfMatrix3f mx);
        public pxr.GfMatrix4f SetRotateOnly(pxr.GfQuatf rot);
        public pxr.GfMatrix4f SetRotateOnly(pxr.GfRotation rot);
        public void SetRow(int i, pxr.GfVec4f v);
        public void SetRow3(int i, pxr.GfVec3f v);
        public pxr.GfMatrix4f SetScale(pxr.GfVec3f scaleFactors);
        public pxr.GfMatrix4f SetScale(float scaleFactor);
        public pxr.GfMatrix4f SetTransform(pxr.GfMatrix3f rotmx, pxr.GfVec3f translate);
        public pxr.GfMatrix4f SetTransform(pxr.GfRotation rotate, pxr.GfVec3f translate);
        public pxr.GfMatrix4f SetTranslate(pxr.GfVec3f trans);
        public pxr.GfMatrix4f SetTranslateOnly(pxr.GfVec3f t);
        public pxr.GfMatrix4f SetZero();
        public virtual string ToString();
        public pxr.GfVec3d Transform(pxr.GfVec3d vec);
        public pxr.GfVec3f Transform(pxr.GfVec3f vec);
        public pxr.GfVec3d TransformAffine(pxr.GfVec3d vec);
        public pxr.GfVec3f TransformAffine(pxr.GfVec3f vec);
        public pxr.GfVec3d TransformDir(pxr.GfVec3d vec);
        public pxr.GfVec3f TransformDir(pxr.GfVec3f vec);
    }

    public class GfPlane : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfPlane() {}
        public GfPlane(pxr.GfVec4d eqn) {}
        public GfPlane(pxr.GfVec3d normal, pxr.GfVec3d point) {}
        public GfPlane(pxr.GfVec3d normal, double distanceToOrigin) {}
        public GfPlane(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfPlane lhs, pxr.GfPlane rhs);
        protected virtual void Finalize();
        public double GetDistance(pxr.GfVec3d p);
        public double GetDistanceFromOrigin();
        public pxr.GfVec4d GetEquation();
        public virtual int GetHashCode();
        public pxr.GfVec3d GetNormal();
        public bool IntersectsPositiveHalfSpace(pxr.GfRange3d box);
        public bool IntersectsPositiveHalfSpace(pxr.GfVec3d pt);
        public static bool operator ==(pxr.GfPlane lhs, pxr.GfPlane rhs);
        public static bool operator !=(pxr.GfPlane lhs, pxr.GfPlane rhs);
        public pxr.GfVec3d Project(pxr.GfVec3d p);
        public void Reorient(pxr.GfVec3d p);
        public void Set(pxr.GfVec4d eqn);
        public void Set(pxr.GfVec3d normal, pxr.GfVec3d point);
        public void Set(pxr.GfVec3d normal, double distanceToOrigin);
        public void Set(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2);
        public pxr.GfPlane Transform(pxr.GfMatrix4d matrix);
    }

    public class GfQuatd : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfQuatd() {}
        public GfQuatd(pxr.GfQuatf other) {}
        public GfQuatd(pxr.GfQuath other) {}
        public GfQuatd(double realVal) {}
        public GfQuatd(double real, pxr.GfVec3d imaginary) {}
        public GfQuatd(double real, double i, double j, double k) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfQuatd lhs, pxr.GfQuatd rhs);
        protected virtual void Finalize();
        public pxr.GfQuatd GetConjugate();
        public virtual int GetHashCode();
        public static pxr.GfQuatd GetIdentity();
        public pxr.GfVec3d GetImaginary();
        public pxr.GfQuatd GetInverse();
        public double GetLength();
        public pxr.GfQuatd GetNormalized();
        public pxr.GfQuatd GetNormalized(double eps);
        public double GetReal();
        public double Normalize();
        public double Normalize(double eps);
        public static bool operator ==(pxr.GfQuatd lhs, pxr.GfQuatd rhs);
        public static bool operator !=(pxr.GfQuatd lhs, pxr.GfQuatd rhs);
        public void SetImaginary(pxr.GfVec3d imaginary);
        public void SetImaginary(double i, double j, double k);
        public void SetReal(double real);
    }

    public class GfQuaternion : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfQuaternion() {}
        public GfQuaternion(int realVal) {}
        public GfQuaternion(double real, pxr.GfVec3d imaginary) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfQuaternion lhs, pxr.GfQuaternion rhs);
        protected virtual void Finalize();
        public virtual int GetHashCode();
        public static pxr.GfQuaternion GetIdentity();
        public pxr.GfVec3d GetImaginary();
        public pxr.GfQuaternion GetInverse();
        public double GetLength();
        public pxr.GfQuaternion GetNormalized();
        public pxr.GfQuaternion GetNormalized(double eps);
        public double GetReal();
        public double Normalize();
        public double Normalize(double eps);
        public static bool operator ==(pxr.GfQuaternion lhs, pxr.GfQuaternion rhs);
        public static bool operator !=(pxr.GfQuaternion lhs, pxr.GfQuaternion rhs);
        public void SetImaginary(pxr.GfVec3d imaginary);
        public void SetReal(double real);
    }

    public class GfQuatf : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfQuatf() {}
        public GfQuatf(pxr.GfQuatd other) {}
        public GfQuatf(pxr.GfQuath other) {}
        public GfQuatf(float realVal) {}
        public GfQuatf(float real, pxr.GfVec3f imaginary) {}
        public GfQuatf(float real, float i, float j, float k) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfQuatf lhs, pxr.GfQuatf rhs);
        protected virtual void Finalize();
        public pxr.GfQuatf GetConjugate();
        public virtual int GetHashCode();
        public static pxr.GfQuatf GetIdentity();
        public pxr.GfVec3f GetImaginary();
        public pxr.GfQuatf GetInverse();
        public float GetLength();
        public pxr.GfQuatf GetNormalized();
        public pxr.GfQuatf GetNormalized(float eps);
        public float GetReal();
        public float Normalize();
        public float Normalize(float eps);
        public static bool operator ==(pxr.GfQuatf lhs, pxr.GfQuatf rhs);
        public static bool operator !=(pxr.GfQuatf lhs, pxr.GfQuatf rhs);
        public void SetImaginary(pxr.GfVec3f imaginary);
        public void SetImaginary(float i, float j, float k);
        public void SetReal(float real);
    }

    public class GfQuath : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfQuath() {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfQuath lhs, pxr.GfQuath rhs);
        protected virtual void Finalize();
        public virtual int GetHashCode();
        public static bool operator ==(pxr.GfQuath lhs, pxr.GfQuath rhs);
        public static bool operator !=(pxr.GfQuath lhs, pxr.GfQuath rhs);
    }

    public class GfRange1d : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public GfRange1d() {}
        public GfRange1d(double min, double max) {}
        public bool Contains(pxr.GfRange1d range);
        public bool Contains(double point);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfRange1d lhs, pxr.GfRange1d rhs);
        public void ExtendBy(pxr.GfRange1d range);
        public void ExtendBy(double point);
        protected virtual void Finalize();
        public double GetDistanceSquared(double p);
        public virtual int GetHashCode();
        public static pxr.GfRange1d GetIntersection(pxr.GfRange1d a, pxr.GfRange1d b);
        public double GetMax();
        public double GetMidpoint();
        public double GetMin();
        public double GetSize();
        public static pxr.GfRange1d GetUnion(pxr.GfRange1d a, pxr.GfRange1d b);
        public static pxr.GfRange1d Intersection(pxr.GfRange1d a, pxr.GfRange1d b);
        public pxr.GfRange1d IntersectWith(pxr.GfRange1d b);
        public bool IsEmpty();
        public bool IsInside(pxr.GfRange1d range);
        public bool IsInside(double point);
        public bool IsOutside(pxr.GfRange1d range);
        public static bool operator ==(pxr.GfRange1d lhs, pxr.GfRange1d rhs);
        public static bool operator !=(pxr.GfRange1d lhs, pxr.GfRange1d rhs);
        public void SetEmpty();
        public void SetMax(double max);
        public void SetMin(double min);
        public pxr.GfRange1d Union(double b);
        public static pxr.GfRange1d Union(pxr.GfRange1d a, pxr.GfRange1d b);
        public pxr.GfRange1d UnionWith(pxr.GfRange1d b);
        public pxr.GfRange1d UnionWith(double b);
    }

    public class GfRange1f : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public GfRange1f() {}
        public GfRange1f(float min, float max) {}
        public bool Contains(pxr.GfRange1f range);
        public bool Contains(float point);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfRange1f lhs, pxr.GfRange1f rhs);
        public void ExtendBy(pxr.GfRange1f range);
        public void ExtendBy(float point);
        protected virtual void Finalize();
        public double GetDistanceSquared(float p);
        public virtual int GetHashCode();
        public static pxr.GfRange1f GetIntersection(pxr.GfRange1f a, pxr.GfRange1f b);
        public float GetMax();
        public float GetMidpoint();
        public float GetMin();
        public float GetSize();
        public static pxr.GfRange1f GetUnion(pxr.GfRange1f a, pxr.GfRange1f b);
        public static pxr.GfRange1f Intersection(pxr.GfRange1f a, pxr.GfRange1f b);
        public pxr.GfRange1f IntersectWith(pxr.GfRange1f b);
        public bool IsEmpty();
        public bool IsInside(pxr.GfRange1f range);
        public bool IsInside(float point);
        public bool IsOutside(pxr.GfRange1f range);
        public static bool operator ==(pxr.GfRange1f lhs, pxr.GfRange1f rhs);
        public static bool operator !=(pxr.GfRange1f lhs, pxr.GfRange1f rhs);
        public void SetEmpty();
        public void SetMax(float max);
        public void SetMin(float min);
        public pxr.GfRange1f Union(float b);
        public static pxr.GfRange1f Union(pxr.GfRange1f a, pxr.GfRange1f b);
        public pxr.GfRange1f UnionWith(pxr.GfRange1f b);
        public pxr.GfRange1f UnionWith(float b);
    }

    public class GfRange2d : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public static pxr.GfRange2d UnitSquare { get; }
        public GfRange2d() {}
        public GfRange2d(pxr.GfVec2d min, pxr.GfVec2d max) {}
        public bool Contains(pxr.GfRange2d range);
        public bool Contains(pxr.GfVec2d point);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfRange2d lhs, pxr.GfRange2d rhs);
        public void ExtendBy(pxr.GfRange2d range);
        public void ExtendBy(pxr.GfVec2d point);
        protected virtual void Finalize();
        public pxr.GfVec2d GetCorner(System.UInt32 i);
        public double GetDistanceSquared(pxr.GfVec2d p);
        public virtual int GetHashCode();
        public static pxr.GfRange2d GetIntersection(pxr.GfRange2d a, pxr.GfRange2d b);
        public pxr.GfVec2d GetMax();
        public pxr.GfVec2d GetMidpoint();
        public pxr.GfVec2d GetMin();
        public pxr.GfRange2d GetQuadrant(System.UInt32 i);
        public pxr.GfVec2d GetSize();
        public static pxr.GfRange2d GetUnion(pxr.GfRange2d a, pxr.GfRange2d b);
        public static pxr.GfRange2d Intersection(pxr.GfRange2d a, pxr.GfRange2d b);
        public pxr.GfRange2d IntersectWith(pxr.GfRange2d b);
        public bool IsEmpty();
        public bool IsInside(pxr.GfRange2d range);
        public bool IsInside(pxr.GfVec2d point);
        public bool IsOutside(pxr.GfRange2d range);
        public static bool operator ==(pxr.GfRange2d lhs, pxr.GfRange2d rhs);
        public static bool operator !=(pxr.GfRange2d lhs, pxr.GfRange2d rhs);
        public void SetEmpty();
        public void SetMax(pxr.GfVec2d max);
        public void SetMin(pxr.GfVec2d min);
        public pxr.GfRange2d Union(pxr.GfVec2d b);
        public static pxr.GfRange2d Union(pxr.GfRange2d a, pxr.GfRange2d b);
        public pxr.GfRange2d UnionWith(pxr.GfRange2d b);
        public pxr.GfRange2d UnionWith(pxr.GfVec2d b);
    }

    public class GfRange3d : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public static pxr.GfRange3d UnitCube { get; }
        public GfRange3d() {}
        public GfRange3d(pxr.GfVec3d min, pxr.GfVec3d max) {}
        public bool Contains(pxr.GfRange3d range);
        public bool Contains(pxr.GfVec3d point);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfRange3d lhs, pxr.GfRange3d rhs);
        public void ExtendBy(pxr.GfRange3d range);
        public void ExtendBy(pxr.GfVec3d point);
        protected virtual void Finalize();
        public pxr.GfVec3d GetCorner(System.UInt32 i);
        public double GetDistanceSquared(pxr.GfVec3d p);
        public virtual int GetHashCode();
        public static pxr.GfRange3d GetIntersection(pxr.GfRange3d a, pxr.GfRange3d b);
        public pxr.GfVec3d GetMax();
        public pxr.GfVec3d GetMidpoint();
        public pxr.GfVec3d GetMin();
        public pxr.GfRange3d GetOctant(System.UInt32 i);
        public pxr.GfVec3d GetSize();
        public static pxr.GfRange3d GetUnion(pxr.GfRange3d a, pxr.GfRange3d b);
        public static pxr.GfRange3d Intersection(pxr.GfRange3d a, pxr.GfRange3d b);
        public pxr.GfRange3d IntersectWith(pxr.GfRange3d b);
        public bool IsEmpty();
        public bool IsInside(pxr.GfRange3d range);
        public bool IsInside(pxr.GfVec3d point);
        public bool IsOutside(pxr.GfRange3d range);
        public static bool operator ==(pxr.GfRange3d lhs, pxr.GfRange3d rhs);
        public static bool operator !=(pxr.GfRange3d lhs, pxr.GfRange3d rhs);
        public void SetEmpty();
        public void SetMax(pxr.GfVec3d max);
        public void SetMin(pxr.GfVec3d min);
        public pxr.GfRange3d Union(pxr.GfVec3d b);
        public static pxr.GfRange3d Union(pxr.GfRange3d a, pxr.GfRange3d b);
        public pxr.GfRange3d UnionWith(pxr.GfRange3d b);
        public pxr.GfRange3d UnionWith(pxr.GfVec3d b);
    }

    public class GfRay : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfRay() {}
        public GfRay(pxr.GfVec3d startPoint, pxr.GfVec3d direction) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfRay lhs, pxr.GfRay rhs);
        protected virtual void Finalize();
        public pxr.GfVec3d FindClosestPoint(pxr.GfVec3d point);
        public pxr.GfVec3d FindClosestPoint(pxr.GfVec3d point, out double rayDistance);
        public pxr.GfVec3d GetDirection();
        public virtual int GetHashCode();
        public pxr.GfVec3d GetPoint(double distance);
        public pxr.GfVec3d GetStartPoint();
        public bool Intersect(pxr.GfBBox3d box);
        public bool Intersect(pxr.GfPlane plane);
        public bool Intersect(pxr.GfRange3d box);
        public bool Intersect(pxr.GfBBox3d box, out double enterDistance);
        public bool Intersect(pxr.GfPlane plane, out double distance);
        public bool Intersect(pxr.GfRange3d box, out double enterDistance);
        public bool Intersect(pxr.GfVec3d center, double radius);
        public bool Intersect(pxr.GfBBox3d box, out double enterDistance, out double exitDistance);
        public bool Intersect(pxr.GfPlane plane, out double distance, out bool frontFacing);
        public bool Intersect(pxr.GfRange3d box, out double enterDistance, out double exitDistance);
        public bool Intersect(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2);
        public bool Intersect(pxr.GfVec3d origin, pxr.GfVec3d axis, double radius);
        public bool Intersect(pxr.GfVec3d center, double radius, out double enterDistance);
        public bool Intersect(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2, out double distance);
        public bool Intersect(pxr.GfVec3d origin, pxr.GfVec3d axis, double radius, out double enterDistance);
        public bool Intersect(pxr.GfVec3d origin, pxr.GfVec3d axis, double radius, double height);
        public bool Intersect(pxr.GfVec3d center, double radius, out double enterDistance, out double exitDistance);
        public bool Intersect(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2, out double distance, pxr.GfVec3d barycentricCoords);
        public bool Intersect(pxr.GfVec3d origin, pxr.GfVec3d axis, double radius, out double enterDistance, out double exitDistance);
        public bool Intersect(pxr.GfVec3d origin, pxr.GfVec3d axis, double radius, double height, out double enterDistance);
        public bool Intersect(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2, out double distance, pxr.GfVec3d barycentricCoords, out bool frontFacing);
        public bool Intersect(pxr.GfVec3d origin, pxr.GfVec3d axis, double radius, double height, out double enterDistance, out double exitDistance);
        public bool Intersect(pxr.GfVec3d p0, pxr.GfVec3d p1, pxr.GfVec3d p2, out double distance, pxr.GfVec3d barycentricCoords, out bool frontFacing, double maxDist);
        public static bool operator ==(pxr.GfRay lhs, pxr.GfRay rhs);
        public static bool operator !=(pxr.GfRay lhs, pxr.GfRay rhs);
        public void SetEnds(pxr.GfVec3d startPoint, pxr.GfVec3d endPoint);
        public void SetPointAndDirection(pxr.GfVec3d startPoint, pxr.GfVec3d direction);
        public pxr.GfRay Transform(pxr.GfMatrix4d matrix);
    }

    public class GfRotation : System.IDisposable
    {
        protected bool swigCMemOwn;
        public GfRotation() {}
        public GfRotation(pxr.GfQuatd quat) {}
        public GfRotation(pxr.GfQuaternion quaternion) {}
        public GfRotation(pxr.GfVec3d rotateFrom, pxr.GfVec3d rotateTo) {}
        public GfRotation(pxr.GfVec3d axis, double angle) {}
        public pxr.GfVec3d Decompose(pxr.GfVec3d axis0, pxr.GfVec3d axis1, pxr.GfVec3d axis2);
        public static void DecomposeRotation(pxr.GfMatrix4d rot, pxr.GfVec3d TwAxis, pxr.GfVec3d FBAxis, pxr.GfVec3d LRAxis, double handedness, ref double thetaTw, ref double thetaFB, ref double thetaLR);
        public static void DecomposeRotation(pxr.GfMatrix4d rot, pxr.GfVec3d TwAxis, pxr.GfVec3d FBAxis, pxr.GfVec3d LRAxis, double handedness, ref double thetaTw, ref double thetaFB, ref double thetaLR, ref double thetaSw);
        public static void DecomposeRotation(pxr.GfMatrix4d rot, pxr.GfVec3d TwAxis, pxr.GfVec3d FBAxis, pxr.GfVec3d LRAxis, double handedness, ref double thetaTw, ref double thetaFB, ref double thetaLR, ref double thetaSw, bool useHint);
        public static void DecomposeRotation(pxr.GfMatrix4d rot, pxr.GfVec3d TwAxis, pxr.GfVec3d FBAxis, pxr.GfVec3d LRAxis, double handedness, ref double thetaTw, ref double thetaFB, ref double thetaLR, ref double thetaSw, bool useHint, ref double swShift);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfRotation lhs, pxr.GfRotation rhs);
        protected virtual void Finalize();
        public double GetAngle();
        public pxr.GfVec3d GetAxis();
        public virtual int GetHashCode();
        public pxr.GfRotation GetInverse();
        public pxr.GfQuatd GetQuat();
        public pxr.GfQuaternion GetQuaternion();
        public static bool operator ==(pxr.GfRotation lhs, pxr.GfRotation rhs);
        public static bool operator !=(pxr.GfRotation lhs, pxr.GfRotation rhs);
        public static pxr.GfRotation RotateOntoProjected(pxr.GfVec3d v1, pxr.GfVec3d v2, pxr.GfVec3d axis);
        public pxr.GfRotation SetAxisAngle(pxr.GfVec3d axis, double angle);
        public pxr.GfRotation SetIdentity();
        public pxr.GfRotation SetQuat(pxr.GfQuatd quat);
        public pxr.GfRotation SetQuaternion(pxr.GfQuaternion quat);
        public pxr.GfRotation SetRotateInto(pxr.GfVec3d rotateFrom, pxr.GfVec3d rotateTo);
        public pxr.GfVec3d TransformDir(pxr.GfVec3d vec);
        public pxr.GfVec3f TransformDir(pxr.GfVec3f vec);
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec2d : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public double this[int index] { get; set; }
        public GfVec2d() {}
        public GfVec2d(pxr.GfVec2f other) {}
        public GfVec2d(pxr.GfVec2h other) {}
        public GfVec2d(pxr.GfVec2i other) {}
        public GfVec2d(double value) {}
        public GfVec2d(double s0, double s1) {}
        public static pxr.GfVec2d Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec2d lhs, pxr.GfVec2d rhs);
        protected virtual void Finalize();
        public pxr.GfVec2d GetComplement(pxr.GfVec2d b);
        public virtual int GetHashCode();
        public double GetLength();
        public double GetLengthSq();
        public pxr.GfVec2d GetNormalized();
        public pxr.GfVec2d GetNormalized(double eps);
        public pxr.GfVec2d GetProjection(pxr.GfVec2d v);
        protected double GetValue(int index);
        public double Normalize();
        public double Normalize(double eps);
        public static bool operator ==(pxr.GfVec2d lhs, pxr.GfVec2d rhs);
        public static bool operator !=(pxr.GfVec2d lhs, pxr.GfVec2d rhs);
        public pxr.GfVec2d Set(double s0, double s1);
        protected void SetValue(int index, double value);
        public static pxr.GfVec2d XAxis();
        public static pxr.GfVec2d YAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec2f : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public float this[int index] { get; set; }
        public GfVec2f() {}
        public GfVec2f(pxr.GfVec2d other) {}
        public GfVec2f(pxr.GfVec2h other) {}
        public GfVec2f(pxr.GfVec2i other) {}
        public GfVec2f(float value) {}
        public GfVec2f(float s0, float s1) {}
        public static pxr.GfVec2f Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec2f lhs, pxr.GfVec2f rhs);
        protected virtual void Finalize();
        public pxr.GfVec2f GetComplement(pxr.GfVec2f b);
        public virtual int GetHashCode();
        public float GetLength();
        public float GetLengthSq();
        public pxr.GfVec2f GetNormalized();
        public pxr.GfVec2f GetNormalized(float eps);
        public pxr.GfVec2f GetProjection(pxr.GfVec2f v);
        protected float GetValue(int index);
        public float Normalize();
        public float Normalize(float eps);
        public static bool operator ==(pxr.GfVec2f lhs, pxr.GfVec2f rhs);
        public static bool operator !=(pxr.GfVec2f lhs, pxr.GfVec2f rhs);
        public pxr.GfVec2f Set(float s0, float s1);
        protected void SetValue(int index, float value);
        public static pxr.GfVec2f XAxis();
        public static pxr.GfVec2f YAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec2h : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public float this[int index] { get; set; }
        public GfVec2h() {}
        public GfVec2h(pxr.GfHalf value) {}
        public GfVec2h(pxr.GfVec2d other) {}
        public GfVec2h(pxr.GfVec2f other) {}
        public GfVec2h(pxr.GfVec2i other) {}
        public GfVec2h(pxr.GfHalf s0, pxr.GfHalf s1) {}
        public static pxr.GfVec2h Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec2h lhs, pxr.GfVec2h rhs);
        protected virtual void Finalize();
        public pxr.GfVec2h GetComplement(pxr.GfVec2h b);
        public virtual int GetHashCode();
        public pxr.GfHalf GetLength();
        public pxr.GfHalf GetLengthSq();
        public pxr.GfVec2h GetNormalized();
        public pxr.GfVec2h GetNormalized(pxr.GfHalf eps);
        public pxr.GfVec2h GetProjection(pxr.GfVec2h v);
        protected float GetValue(int index);
        public pxr.GfHalf Normalize();
        public pxr.GfHalf Normalize(pxr.GfHalf eps);
        public static bool operator ==(pxr.GfVec2h lhs, pxr.GfVec2h rhs);
        public static bool operator !=(pxr.GfVec2h lhs, pxr.GfVec2h rhs);
        public pxr.GfVec2h Set(pxr.GfHalf a);
        public pxr.GfVec2h Set(pxr.GfHalf s0, pxr.GfHalf s1);
        protected void SetValue(int index, float value);
        public static pxr.GfVec2h XAxis();
        public static pxr.GfVec2h YAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec2i : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public int this[int index] { get; set; }
        public GfVec2i() {}
        public GfVec2i(int value) {}
        public GfVec2i(int s0, int s1) {}
        public static pxr.GfVec2i Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec2i lhs, pxr.GfVec2i rhs);
        protected virtual void Finalize();
        public pxr.GfVec2i GetComplement(pxr.GfVec2i b);
        public virtual int GetHashCode();
        public int GetLengthSq();
        public pxr.GfVec2i GetProjection(pxr.GfVec2i v);
        protected int GetValue(int index);
        public static bool operator ==(pxr.GfVec2i lhs, pxr.GfVec2i rhs);
        public static bool operator !=(pxr.GfVec2i lhs, pxr.GfVec2i rhs);
        public pxr.GfVec2i Set(int s0, int s1);
        protected void SetValue(int index, int value);
        public static pxr.GfVec2i XAxis();
        public static pxr.GfVec2i YAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec3d : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public double this[int index] { get; set; }
        public GfVec3d() {}
        public GfVec3d(pxr.GfVec3f other) {}
        public GfVec3d(pxr.GfVec3h other) {}
        public GfVec3d(pxr.GfVec3i other) {}
        public GfVec3d(double value) {}
        public GfVec3d(double s0, double s1, double s2) {}
        public static pxr.GfVec3d Axis(System.UInt32 i);
        public void BuildOrthonormalFrame(pxr.GfVec3d v1, pxr.GfVec3d v2);
        public void BuildOrthonormalFrame(pxr.GfVec3d v1, pxr.GfVec3d v2, double eps);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec3d lhs, pxr.GfVec3d rhs);
        protected virtual void Finalize();
        public pxr.GfVec3d GetComplement(pxr.GfVec3d b);
        public virtual int GetHashCode();
        public double GetLength();
        public double GetLengthSq();
        public pxr.GfVec3d GetNormalized();
        public pxr.GfVec3d GetNormalized(double eps);
        public pxr.GfVec3d GetProjection(pxr.GfVec3d v);
        protected double GetValue(int index);
        public double Normalize();
        public double Normalize(double eps);
        public static bool operator ==(pxr.GfVec3d lhs, pxr.GfVec3d rhs);
        public static bool operator !=(pxr.GfVec3d lhs, pxr.GfVec3d rhs);
        public static bool OrthogonalizeBasis(pxr.GfVec3d tx, pxr.GfVec3d ty, pxr.GfVec3d tz, bool normalize);
        public static bool OrthogonalizeBasis(pxr.GfVec3d tx, pxr.GfVec3d ty, pxr.GfVec3d tz, bool normalize, double eps);
        public pxr.GfVec3d Set(double s0, double s1, double s2);
        protected void SetValue(int index, double value);
        public static pxr.GfVec3d XAxis();
        public static pxr.GfVec3d YAxis();
        public static pxr.GfVec3d ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec3dVector : System.Collections.Generic.IEnumerable<pxr.GfVec3d>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.GfVec3d this[int index] { get; set; }
        public GfVec3dVector() {}
        public GfVec3dVector(pxr.GfVec3dVector other) {}
        public GfVec3dVector(System.Collections.ICollection c) {}
        public GfVec3dVector(int capacity) {}
        public void Add(pxr.GfVec3d x);
        public void AddRange(pxr.GfVec3dVector values);
        public void Clear();
        public void CopyTo(pxr.GfVec3d[] array);
        public void CopyTo(pxr.GfVec3d[] array, int arrayIndex);
        public void CopyTo(int index, pxr.GfVec3d[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.GfVec3dVector.GfVec3dVectorEnumerator GetEnumerator();
        public pxr.GfVec3dVector GetRange(int index, int count);
        public void Insert(int index, pxr.GfVec3d x);
        public void InsertRange(int index, pxr.GfVec3dVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.GfVec3dVector Repeat(pxr.GfVec3d value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.GfVec3dVector values);
        public sealed class GfVec3dVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.GfVec3d>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.GfVec3d Current { get; }
            public GfVec3dVectorEnumerator(pxr.GfVec3dVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec3f : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public float this[int index] { get; set; }
        public GfVec3f() {}
        public GfVec3f(pxr.GfVec3d other) {}
        public GfVec3f(pxr.GfVec3h other) {}
        public GfVec3f(pxr.GfVec3i other) {}
        public GfVec3f(float value) {}
        public GfVec3f(float s0, float s1, float s2) {}
        public static pxr.GfVec3f Axis(System.UInt32 i);
        public void BuildOrthonormalFrame(pxr.GfVec3f v1, pxr.GfVec3f v2);
        public void BuildOrthonormalFrame(pxr.GfVec3f v1, pxr.GfVec3f v2, float eps);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec3f lhs, pxr.GfVec3f rhs);
        protected virtual void Finalize();
        public pxr.GfVec3f GetComplement(pxr.GfVec3f b);
        public virtual int GetHashCode();
        public float GetLength();
        public float GetLengthSq();
        public pxr.GfVec3f GetNormalized();
        public pxr.GfVec3f GetNormalized(float eps);
        public pxr.GfVec3f GetProjection(pxr.GfVec3f v);
        protected float GetValue(int index);
        public float Normalize();
        public float Normalize(float eps);
        public static bool operator ==(pxr.GfVec3f lhs, pxr.GfVec3f rhs);
        public static bool operator !=(pxr.GfVec3f lhs, pxr.GfVec3f rhs);
        public static bool OrthogonalizeBasis(pxr.GfVec3f tx, pxr.GfVec3f ty, pxr.GfVec3f tz, bool normalize);
        public static bool OrthogonalizeBasis(pxr.GfVec3f tx, pxr.GfVec3f ty, pxr.GfVec3f tz, bool normalize, double eps);
        public pxr.GfVec3f Set(float s0, float s1, float s2);
        protected void SetValue(int index, float value);
        public static pxr.GfVec3f XAxis();
        public static pxr.GfVec3f YAxis();
        public static pxr.GfVec3f ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec3h : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public float this[int index] { get; set; }
        public GfVec3h() {}
        public GfVec3h(pxr.GfHalf value) {}
        public GfVec3h(pxr.GfVec3d other) {}
        public GfVec3h(pxr.GfVec3f other) {}
        public GfVec3h(pxr.GfVec3i other) {}
        public GfVec3h(pxr.GfHalf s0, pxr.GfHalf s1, pxr.GfHalf s2) {}
        public static pxr.GfVec3h Axis(System.UInt32 i);
        public void BuildOrthonormalFrame(pxr.GfVec3h v1, pxr.GfVec3h v2);
        public void BuildOrthonormalFrame(pxr.GfVec3h v1, pxr.GfVec3h v2, pxr.GfHalf eps);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec3h lhs, pxr.GfVec3h rhs);
        protected virtual void Finalize();
        public pxr.GfVec3h GetComplement(pxr.GfVec3h b);
        public virtual int GetHashCode();
        public pxr.GfHalf GetLength();
        public pxr.GfHalf GetLengthSq();
        public pxr.GfVec3h GetNormalized();
        public pxr.GfVec3h GetNormalized(pxr.GfHalf eps);
        public pxr.GfVec3h GetProjection(pxr.GfVec3h v);
        protected float GetValue(int index);
        public pxr.GfHalf Normalize();
        public pxr.GfHalf Normalize(pxr.GfHalf eps);
        public static bool operator ==(pxr.GfVec3h lhs, pxr.GfVec3h rhs);
        public static bool operator !=(pxr.GfVec3h lhs, pxr.GfVec3h rhs);
        public static bool OrthogonalizeBasis(pxr.GfVec3h tx, pxr.GfVec3h ty, pxr.GfVec3h tz, bool normalize);
        public static bool OrthogonalizeBasis(pxr.GfVec3h tx, pxr.GfVec3h ty, pxr.GfVec3h tz, bool normalize, double eps);
        public pxr.GfVec3h Set(pxr.GfHalf a);
        public pxr.GfVec3h Set(pxr.GfHalf s0, pxr.GfHalf s1, pxr.GfHalf s2);
        protected void SetValue(int index, float value);
        public static pxr.GfVec3h XAxis();
        public static pxr.GfVec3h YAxis();
        public static pxr.GfVec3h ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec3i : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public int this[int index] { get; set; }
        public GfVec3i() {}
        public GfVec3i(int value) {}
        public GfVec3i(int s0, int s1, int s2) {}
        public static pxr.GfVec3i Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec3i lhs, pxr.GfVec3i rhs);
        protected virtual void Finalize();
        public pxr.GfVec3i GetComplement(pxr.GfVec3i b);
        public virtual int GetHashCode();
        public int GetLengthSq();
        public pxr.GfVec3i GetProjection(pxr.GfVec3i v);
        protected int GetValue(int index);
        public static bool operator ==(pxr.GfVec3i lhs, pxr.GfVec3i rhs);
        public static bool operator !=(pxr.GfVec3i lhs, pxr.GfVec3i rhs);
        public pxr.GfVec3i Set(int s0, int s1, int s2);
        protected void SetValue(int index, int value);
        public static pxr.GfVec3i XAxis();
        public static pxr.GfVec3i YAxis();
        public static pxr.GfVec3i ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec4d : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public double this[int index] { get; set; }
        public GfVec4d() {}
        public GfVec4d(pxr.GfVec4f other) {}
        public GfVec4d(pxr.GfVec4h other) {}
        public GfVec4d(pxr.GfVec4i other) {}
        public GfVec4d(double value) {}
        public GfVec4d(double s0, double s1, double s2, double s3) {}
        public static pxr.GfVec4d Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec4d lhs, pxr.GfVec4d rhs);
        protected virtual void Finalize();
        public pxr.GfVec4d GetComplement(pxr.GfVec4d b);
        public virtual int GetHashCode();
        public double GetLength();
        public double GetLengthSq();
        public pxr.GfVec4d GetNormalized();
        public pxr.GfVec4d GetNormalized(double eps);
        public pxr.GfVec4d GetProjection(pxr.GfVec4d v);
        protected double GetValue(int index);
        public double Normalize();
        public double Normalize(double eps);
        public static bool operator ==(pxr.GfVec4d lhs, pxr.GfVec4d rhs);
        public static bool operator !=(pxr.GfVec4d lhs, pxr.GfVec4d rhs);
        public pxr.GfVec4d Set(double s0, double s1, double s2, double s3);
        protected void SetValue(int index, double value);
        public static pxr.GfVec4d WAxis();
        public static pxr.GfVec4d XAxis();
        public static pxr.GfVec4d YAxis();
        public static pxr.GfVec4d ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec4f : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public float this[int index] { get; set; }
        public GfVec4f() {}
        public GfVec4f(pxr.GfVec4d other) {}
        public GfVec4f(pxr.GfVec4h other) {}
        public GfVec4f(pxr.GfVec4i other) {}
        public GfVec4f(float value) {}
        public GfVec4f(float s0, float s1, float s2, float s3) {}
        public static pxr.GfVec4f Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec4f lhs, pxr.GfVec4f rhs);
        protected virtual void Finalize();
        public pxr.GfVec4f GetComplement(pxr.GfVec4f b);
        public virtual int GetHashCode();
        public float GetLength();
        public float GetLengthSq();
        public pxr.GfVec4f GetNormalized();
        public pxr.GfVec4f GetNormalized(float eps);
        public pxr.GfVec4f GetProjection(pxr.GfVec4f v);
        protected float GetValue(int index);
        public float Normalize();
        public float Normalize(float eps);
        public static bool operator ==(pxr.GfVec4f lhs, pxr.GfVec4f rhs);
        public static bool operator !=(pxr.GfVec4f lhs, pxr.GfVec4f rhs);
        public pxr.GfVec4f Set(float s0, float s1, float s2, float s3);
        protected void SetValue(int index, float value);
        public static pxr.GfVec4f WAxis();
        public static pxr.GfVec4f XAxis();
        public static pxr.GfVec4f YAxis();
        public static pxr.GfVec4f ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec4fVector : System.Collections.Generic.IEnumerable<pxr.GfVec4f>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.GfVec4f this[int index] { get; set; }
        public GfVec4fVector() {}
        public GfVec4fVector(pxr.GfVec4fVector other) {}
        public GfVec4fVector(System.Collections.ICollection c) {}
        public GfVec4fVector(int capacity) {}
        public void Add(pxr.GfVec4f x);
        public void AddRange(pxr.GfVec4fVector values);
        public void Clear();
        public void CopyTo(pxr.GfVec4f[] array);
        public void CopyTo(pxr.GfVec4f[] array, int arrayIndex);
        public void CopyTo(int index, pxr.GfVec4f[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.GfVec4fVector.GfVec4fVectorEnumerator GetEnumerator();
        public pxr.GfVec4fVector GetRange(int index, int count);
        public void Insert(int index, pxr.GfVec4f x);
        public void InsertRange(int index, pxr.GfVec4fVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.GfVec4fVector Repeat(pxr.GfVec4f value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.GfVec4fVector values);
        public sealed class GfVec4fVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.GfVec4f>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.GfVec4f Current { get; }
            public GfVec4fVectorEnumerator(pxr.GfVec4fVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec4h : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public float this[int index] { get; set; }
        public GfVec4h() {}
        public GfVec4h(pxr.GfHalf value) {}
        public GfVec4h(pxr.GfVec4d other) {}
        public GfVec4h(pxr.GfVec4f other) {}
        public GfVec4h(pxr.GfVec4i other) {}
        public GfVec4h(pxr.GfHalf s0, pxr.GfHalf s1, pxr.GfHalf s2, pxr.GfHalf s3) {}
        public static pxr.GfVec4h Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec4h lhs, pxr.GfVec4h rhs);
        protected virtual void Finalize();
        public pxr.GfVec4h GetComplement(pxr.GfVec4h b);
        public virtual int GetHashCode();
        public pxr.GfHalf GetLength();
        public pxr.GfHalf GetLengthSq();
        public pxr.GfVec4h GetNormalized();
        public pxr.GfVec4h GetNormalized(pxr.GfHalf eps);
        public pxr.GfVec4h GetProjection(pxr.GfVec4h v);
        protected float GetValue(int index);
        public pxr.GfHalf Normalize();
        public pxr.GfHalf Normalize(pxr.GfHalf eps);
        public static bool operator ==(pxr.GfVec4h lhs, pxr.GfVec4h rhs);
        public static bool operator !=(pxr.GfVec4h lhs, pxr.GfVec4h rhs);
        public pxr.GfVec4h Set(pxr.GfHalf a);
        public pxr.GfVec4h Set(pxr.GfHalf s0, pxr.GfHalf s1, pxr.GfHalf s2, pxr.GfHalf s3);
        protected void SetValue(int index, float value);
        public static pxr.GfVec4h WAxis();
        public static pxr.GfVec4h XAxis();
        public static pxr.GfVec4h YAxis();
        public static pxr.GfVec4h ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class GfVec4i : System.IDisposable
    {
        public static readonly System.UInt32 dimension;
        protected bool swigCMemOwn;
        public int this[int index] { get; set; }
        public GfVec4i() {}
        public GfVec4i(int value) {}
        public GfVec4i(int s0, int s1, int s2, int s3) {}
        public static pxr.GfVec4i Axis(System.UInt32 i);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.GfVec4i lhs, pxr.GfVec4i rhs);
        protected virtual void Finalize();
        public pxr.GfVec4i GetComplement(pxr.GfVec4i b);
        public virtual int GetHashCode();
        public int GetLengthSq();
        public pxr.GfVec4i GetProjection(pxr.GfVec4i v);
        protected int GetValue(int index);
        public static bool operator ==(pxr.GfVec4i lhs, pxr.GfVec4i rhs);
        public static bool operator !=(pxr.GfVec4i lhs, pxr.GfVec4i rhs);
        public pxr.GfVec4i Set(int s0, int s1, int s2, int s3);
        protected void SetValue(int index, int value);
        public static pxr.GfVec4i WAxis();
        public static pxr.GfVec4i XAxis();
        public static pxr.GfVec4i YAxis();
        public static pxr.GfVec4i ZAxis();
    }

    [System.Reflection.DefaultMember(@"Item")] public class JsObject : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, pxr.JsValue>>, System.Collections.Generic.IDictionary<string, pxr.JsValue>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, pxr.JsValue>>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual int Count { get; }
        public virtual bool IsReadOnly { get; }
        public virtual pxr.JsValue this[string key] { get; set; }
        public virtual System.Collections.Generic.ICollection<string> Keys { get; }
        public virtual System.Collections.Generic.ICollection<pxr.JsValue> Values { get; }
        public JsObject() {}
        public JsObject(pxr.JsObject other) {}
        public virtual void Add(System.Collections.Generic.KeyValuePair<string, pxr.JsValue> item);
        public virtual void Add(string key, pxr.JsValue val);
        public virtual void Clear();
        public virtual bool Contains(System.Collections.Generic.KeyValuePair<string, pxr.JsValue> item);
        public virtual bool ContainsKey(string key);
        public void CopyTo(System.Collections.Generic.KeyValuePair<string, pxr.JsValue>[] array);
        public virtual void CopyTo(System.Collections.Generic.KeyValuePair<string, pxr.JsValue>[] array, int arrayIndex);
        public virtual void Dispose();
        public bool empty();
        protected virtual void Finalize();
        public pxr.JsObject.JsObjectEnumerator GetEnumerator();
        public virtual bool Remove(System.Collections.Generic.KeyValuePair<string, pxr.JsValue> item);
        public virtual bool Remove(string key);
        public virtual bool TryGetValue(string key, out pxr.JsValue value);
        public sealed class JsObjectEnumerator : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, pxr.JsValue>>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual System.Collections.Generic.KeyValuePair<string, pxr.JsValue> Current { get; }
            public JsObjectEnumerator(pxr.JsObject collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class JsObjectVector : System.Collections.Generic.IEnumerable<pxr.JsValue>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.JsValue this[int index] { get; set; }
        public JsObjectVector() {}
        public JsObjectVector(pxr.JsObjectVector other) {}
        public JsObjectVector(System.Collections.ICollection c) {}
        public JsObjectVector(int capacity) {}
        public void Add(pxr.JsValue x);
        public void AddRange(pxr.JsObjectVector values);
        public void Clear();
        public void CopyTo(pxr.JsValue[] array);
        public void CopyTo(pxr.JsValue[] array, int arrayIndex);
        public void CopyTo(int index, pxr.JsValue[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.JsObjectVector.JsObjectVectorEnumerator GetEnumerator();
        public pxr.JsObjectVector GetRange(int index, int count);
        public void Insert(int index, pxr.JsValue x);
        public void InsertRange(int index, pxr.JsObjectVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.JsObjectVector Repeat(pxr.JsValue value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.JsObjectVector values);
        public sealed class JsObjectVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.JsValue>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.JsValue Current { get; }
            public JsObjectVectorEnumerator(pxr.JsObjectVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class JsValue : System.IDisposable
    {
        protected bool swigCMemOwn;
        public JsValue() {}
        public JsValue(pxr.JsObject value) {}
        public JsValue(pxr.JsObjectVector value) {}
        public JsValue(pxr.SWIGTYPE_p_std__string value) {}
        public JsValue(bool value) {}
        public JsValue(double value) {}
        public JsValue(int value) {}
        public JsValue(long value) {}
        public JsValue(string value) {}
        public JsValue(System.UInt64 value) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool GetBool();
        public int GetInt();
        public long GetInt64();
        public pxr.JsObjectVector GetJsArray();
        public pxr.JsObject GetJsObject();
        public pxr.JsValue.Type GetJsType();
        public double GetReal();
        public string GetString();
        public string GetTypeName();
        public System.UInt64 GetUInt64();
        public bool IsArray();
        public bool IsBool();
        public bool IsInt();
        public bool IsNull();
        public bool IsObject();
        public bool IsReal();
        public bool IsString();
        public bool IsUInt64();
        public enum Type
        {
            public const pxr.JsValue.Type ArrayType = 1;
            public const pxr.JsValue.Type BoolType = 3;
            public const pxr.JsValue.Type IntType = 4;
            public const pxr.JsValue.Type NullType = 6;
            public const pxr.JsValue.Type ObjectType = 0;
            public const pxr.JsValue.Type RealType = 5;
            public const pxr.JsValue.Type StringType = 2;
            public int value__;
        }
    }

    public class KindRegistry : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual void Dispose();
        public static pxr.TfTokenVector GetAllKinds();
        public static pxr.TfToken GetBaseKind(pxr.TfToken kind);
        public static pxr.KindRegistry GetInstance();
        public static bool HasKind(pxr.TfToken kind);
        public static bool IsA(pxr.TfToken derivedKind, pxr.TfToken baseKind);
    }

    public class KindTokens : System.IDisposable
    {
        public static pxr.TfToken assembly;
        public static pxr.TfToken component;
        public static pxr.TfToken group;
        public static pxr.TfToken model;
        public static pxr.TfToken subcomponent;
        protected bool swigCMemOwn;
        public virtual void Dispose();
    }

    public class NdrDiscoveryPlugin : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual pxr.NdrNodeDiscoveryResultVector DiscoverNodes(pxr.NdrDiscoveryPluginContext arg0);
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual pxr.StdStringVector GetSearchURIs();
    }

    public class NdrDiscoveryPluginContext : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual pxr.TfToken GetSourceType(pxr.TfToken discoveryType);
    }

    public class NdrDiscoveryPluginFactoryBase : pxr.TfType.FactoryBase
    {
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual pxr.SWIGTYPE_p_TfDeclarePtrsT_NdrDiscoveryPlugin_t__RefPtr New();
    }

    public class NdrNode : System.IDisposable
    {
        protected bool swigCMemOwn;
        public NdrNode(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken context, pxr.TfToken sourceType, string definitionURI, string implementationURI, pxr.SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t properties) {}
        public NdrNode(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken context, pxr.TfToken sourceType, string definitionURI, string implementationURI, pxr.SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t properties, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata) {}
        public NdrNode(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken context, pxr.TfToken sourceType, string definitionURI, string implementationURI, pxr.SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t properties, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, string sourceCode) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.TfToken GetContext();
        public pxr.TfToken GetFamily();
        public pxr.TfToken GetIdentifier();
        public virtual string GetInfoString();
        public pxr.NdrProperty GetInput(pxr.TfToken inputName);
        public pxr.TfTokenVector GetInputNames();
        public pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t GetMetadata();
        public string GetName();
        public pxr.NdrProperty GetOutput(pxr.TfToken outputName);
        public pxr.TfTokenVector GetOutputNames();
        public string GetResolvedDefinitionURI();
        public string GetResolvedImplementationURI();
        public string GetSourceCode();
        public pxr.TfToken GetSourceType();
        public pxr.NdrVersion GetVersion();
        public virtual bool IsValid();
    }

    public class NdrNodeDiscoveryResult : System.IDisposable
    {
        protected bool swigCMemOwn;
        public string blindData { get; set; }
        public pxr.TfToken discoveryType { get; set; }
        public pxr.TfToken family { get; set; }
        public pxr.TfToken identifier { get; set; }
        public pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata { get; set; }
        public string name { get; set; }
        public string resolvedUri { get; set; }
        public string sourceCode { get; set; }
        public pxr.TfToken sourceType { get; set; }
        public pxr.TfToken subIdentifier { get; set; }
        public string uri { get; set; }
        public pxr.NdrVersion version { get; set; }
        public NdrNodeDiscoveryResult(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken discoveryType, pxr.TfToken sourceType, string uri, string resolvedUri) {}
        public NdrNodeDiscoveryResult(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken discoveryType, pxr.TfToken sourceType, string uri, string resolvedUri, string sourceCode) {}
        public NdrNodeDiscoveryResult(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken discoveryType, pxr.TfToken sourceType, string uri, string resolvedUri, string sourceCode, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata) {}
        public NdrNodeDiscoveryResult(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken discoveryType, pxr.TfToken sourceType, string uri, string resolvedUri, string sourceCode, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, string blindData) {}
        public NdrNodeDiscoveryResult(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken discoveryType, pxr.TfToken sourceType, string uri, string resolvedUri, string sourceCode, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, string blindData, pxr.TfToken subIdentifier) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class NdrNodeDiscoveryResultVector : System.Collections.Generic.IEnumerable<pxr.NdrNodeDiscoveryResult>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.NdrNodeDiscoveryResult this[int index] { get; set; }
        public NdrNodeDiscoveryResultVector() {}
        public NdrNodeDiscoveryResultVector(pxr.NdrNodeDiscoveryResultVector other) {}
        public NdrNodeDiscoveryResultVector(System.Collections.ICollection c) {}
        public NdrNodeDiscoveryResultVector(int capacity) {}
        public void Add(pxr.NdrNodeDiscoveryResult x);
        public void AddRange(pxr.NdrNodeDiscoveryResultVector values);
        public void Clear();
        public void CopyTo(pxr.NdrNodeDiscoveryResult[] array);
        public void CopyTo(pxr.NdrNodeDiscoveryResult[] array, int arrayIndex);
        public void CopyTo(int index, pxr.NdrNodeDiscoveryResult[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.NdrNodeDiscoveryResultVector.NdrNodeDiscoveryResultVectorEnumerator GetEnumerator();
        public pxr.NdrNodeDiscoveryResultVector GetRange(int index, int count);
        public void Insert(int index, pxr.NdrNodeDiscoveryResult x);
        public void InsertRange(int index, pxr.NdrNodeDiscoveryResultVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.NdrNodeDiscoveryResultVector Repeat(pxr.NdrNodeDiscoveryResult value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.NdrNodeDiscoveryResultVector values);
        public sealed class NdrNodeDiscoveryResultVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.NdrNodeDiscoveryResult>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.NdrNodeDiscoveryResult Current { get; }
            public NdrNodeDiscoveryResultVectorEnumerator(pxr.NdrNodeDiscoveryResultVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class NdrParserPlugin : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual pxr.TfTokenVector GetDiscoveryTypes();
        public virtual pxr.TfToken GetSourceType();
    }

    public class NdrParserPluginFactoryBase : pxr.TfType.FactoryBase
    {
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual pxr.NdrParserPlugin New();
    }

    public class NdrProperty : System.IDisposable
    {
        protected bool swigCMemOwn;
        public NdrProperty(pxr.TfToken name, pxr.TfToken type, pxr.VtValue defaultValue, bool isOutput, System.UInt32 arraySize, bool isDynamicArray, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata) {}
        public virtual bool CanConnectTo(pxr.NdrProperty other);
        public virtual void Dispose();
        protected virtual void Finalize();
        public int GetArraySize();
        public pxr.VtValue GetDefaultValue();
        public virtual string GetInfoString();
        public virtual pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t GetMetadata();
        public pxr.TfToken GetName();
        public pxr.TfToken GetTfType();
        public virtual pxr.SWIGTYPE_p_std__pairT_SdfValueTypeName_TfToken_t GetTypeAsSdfType();
        public bool IsArray();
        public virtual bool IsConnectable();
        public bool IsDynamicArray();
        public bool IsOutput();
    }

    public class NdrRegistry : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual void Dispose();
        public pxr.TfTokenVector GetAllNodeSourceTypes();
        public static pxr.NdrRegistry GetInstance();
        public pxr.NdrNode GetNodeByIdentifier(pxr.TfToken identifier);
        public pxr.NdrNode GetNodeByIdentifier(pxr.TfToken identifier, pxr.TfTokenVector typePriority);
        public pxr.NdrNode GetNodeByIdentifierAndType(pxr.TfToken identifier, pxr.TfToken nodeType);
        public pxr.NdrNode GetNodeByName(string name);
        public pxr.NdrNode GetNodeByName(string name, pxr.TfTokenVector typePriority);
        public pxr.NdrNode GetNodeByName(string name, pxr.TfTokenVector typePriority, pxr.NdrVersionFilter filter);
        public pxr.NdrNode GetNodeByNameAndType(string name, pxr.TfToken nodeType);
        public pxr.NdrNode GetNodeByNameAndType(string name, pxr.TfToken nodeType, pxr.NdrVersionFilter filter);
        public pxr.NdrNode GetNodeFromAsset(pxr.SdfAssetPath asset, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public pxr.NdrNode GetNodeFromAsset(pxr.SdfAssetPath asset, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, pxr.TfToken subIdentifier);
        public pxr.NdrNode GetNodeFromAsset(pxr.SdfAssetPath asset, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, pxr.TfToken subIdentifier, pxr.TfToken sourceType);
        public pxr.NdrNode GetNodeFromSourceCode(string sourceCode, pxr.TfToken sourceType, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public pxr.TfTokenVector GetNodeIdentifiers();
        public pxr.TfTokenVector GetNodeIdentifiers(pxr.TfToken family);
        public pxr.TfTokenVector GetNodeIdentifiers(pxr.TfToken family, pxr.NdrVersionFilter filter);
        public pxr.StdStringVector GetNodeNames();
        public pxr.StdStringVector GetNodeNames(pxr.TfToken family);
        public pxr.SWIGTYPE_p_std__vectorT_NdrNode_const_p_t GetNodesByFamily();
        public pxr.SWIGTYPE_p_std__vectorT_NdrNode_const_p_t GetNodesByFamily(pxr.TfToken family);
        public pxr.SWIGTYPE_p_std__vectorT_NdrNode_const_p_t GetNodesByFamily(pxr.TfToken family, pxr.NdrVersionFilter filter);
        public pxr.SWIGTYPE_p_std__vectorT_NdrNode_const_p_t GetNodesByIdentifier(pxr.TfToken identifier);
        public pxr.SWIGTYPE_p_std__vectorT_NdrNode_const_p_t GetNodesByName(string name);
        public pxr.SWIGTYPE_p_std__vectorT_NdrNode_const_p_t GetNodesByName(string name, pxr.NdrVersionFilter filter);
        public pxr.StdStringVector GetSearchURIs();
        public void SetExtraDiscoveryPlugins(pxr.SWIGTYPE_p_TfDeclarePtrsT_NdrDiscoveryPlugin_t__RefPtrVector plugins);
        public void SetExtraDiscoveryPlugins(pxr.TfTypeVector pluginTypes);
        public void SetExtraParserPlugins(pxr.TfTypeVector pluginTypes);
    }

    public class NdrVersion : System.IDisposable
    {
        protected bool swigCMemOwn;
        public NdrVersion() {}
        public NdrVersion(int major) {}
        public NdrVersion(string x) {}
        public NdrVersion(int major, int minor) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.NdrVersion GetAsDefault();
        public System.UInt32 GetHash();
        public int GetMajor();
        public int GetMinor();
        public string GetString();
        public string GetStringSuffix();
        public bool IsDefault();
    }

    public enum NdrVersionFilter
    {
        public const pxr.NdrVersionFilter NdrNumVersionFilters = 2;
        public const pxr.NdrVersionFilter NdrVersionFilterAllVersions = 1;
        public const pxr.NdrVersionFilter NdrVersionFilterDefaultOnly = 0;
        public int value__;
    }

    public class PcpArc : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.SWIGTYPE_p_PcpMapExpression mapToParent { get; set; }
        public int namespaceDepth { get; set; }
        public pxr.PcpNodeRef origin { get; set; }
        public pxr.PcpNodeRef parent { get; set; }
        public int siblingNumAtOrigin { get; set; }
        public pxr.PcpArcType type { get; set; }
        public PcpArc() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public enum PcpArcType
    {
        public const pxr.PcpArcType PcpArcTypeInherit = 1;
        public const pxr.PcpArcType PcpArcTypePayload = 5;
        public const pxr.PcpArcType PcpArcTypeReference = 4;
        public const pxr.PcpArcType PcpArcTypeRelocate = 3;
        public const pxr.PcpArcType PcpArcTypeRoot = 0;
        public const pxr.PcpArcType PcpArcTypeSpecialize = 6;
        public const pxr.PcpArcType PcpArcTypeVariant = 2;
        public const pxr.PcpArcType PcpNumArcTypes = 7;
        public int value__;
    }

    public class PcpCache : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpCache(pxr.PcpLayerStackIdentifier layerStackIdentifier) {}
        public PcpCache(pxr.PcpLayerStackIdentifier layerStackIdentifier, string fileFormatTarget) {}
        public PcpCache(pxr.PcpLayerStackIdentifier layerStackIdentifier, string fileFormatTarget, bool usd) {}
        public void Apply(pxr.SWIGTYPE_p_PcpCacheChanges changes, pxr.SWIGTYPE_p_PcpLifeboat lifeboat);
        public bool CanHaveOpinionForSite(pxr.SdfPath localPcpSitePath, pxr.SdfLayerHandle layer, pxr.SdfPath allowedPathInLayer);
        public void ComputeAttributeConnectionPaths(pxr.SdfPath attributePath, pxr.SdfPathVector paths, bool localOnly, pxr.SdfSpecHandle stopProperty, bool includeStopProperty, pxr.SdfPathVector deletedPaths, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public pxr.PcpLayerStack ComputeLayerStack(pxr.PcpLayerStackIdentifier identifier, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public pxr.PcpPrimIndex ComputePrimIndex(pxr.SdfPath primPath, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public pxr.PcpPropertyIndex ComputePropertyIndex(pxr.SdfPath propPath, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public void ComputeRelationshipTargetPaths(pxr.SdfPath relationshipPath, pxr.SdfPathVector paths, bool localOnly, pxr.SdfSpecHandle stopProperty, bool includeStopProperty, pxr.SdfPathVector deletedPaths, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.PcpLayerStackPtrVector FindAllLayerStacksUsingLayer(pxr.SdfLayerHandle layer);
        public pxr.PcpLayerStackPtr FindLayerStack(pxr.PcpLayerStackIdentifier identifier);
        public pxr.PcpPrimIndex FindPrimIndex(pxr.SdfPath primPath);
        public pxr.PcpPropertyIndex FindPropertyIndex(pxr.SdfPath propPath);
        public pxr.SWIGTYPE_p_PcpDependencyVector FindSiteDependencies(pxr.PcpLayerStackPtr siteLayerStack, pxr.SdfPath sitePath, pxr.SWIGTYPE_p_PcpDependencyFlags depMask, bool recurseOnSite, bool recurseOnIndex, bool filterForExistingCachesOnly);
        public pxr.SWIGTYPE_p_PcpDependencyVector FindSiteDependencies(pxr.SdfLayerHandle siteLayer, pxr.SdfPath sitePath, pxr.SWIGTYPE_p_PcpDependencyFlags depMask, bool recurseOnSite, bool recurseOnIndex, bool filterForExistingCachesOnly);
        public pxr.SWIGTYPE_p_PcpDynamicFileFormatDependencyData GetDynamicFileFormatArgumentDependencyData(pxr.SdfPath primIndexPath);
        public string GetFileFormatTarget();
        public pxr.SWIGTYPE_p_std__unordered_setT_SdfPath_SdfPath__Hash_t GetIncludedPayloads();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_std__vectorT_std__string_t_SdfPath__FastLessThan_t GetInvalidAssetPaths();
        public pxr.StdStringVector GetInvalidSublayerIdentifiers();
        public pxr.PcpLayerStackPtr GetLayerStack();
        public pxr.PcpLayerStackIdentifier GetLayerStackIdentifier();
        public pxr.StdStringVector GetMutedLayers();
        public pxr.SWIGTYPE_p_PcpPrimIndexInputs GetPrimIndexInputs();
        public pxr.SWIGTYPE_p_SdfLayerHandleSet GetUsedLayers();
        public pxr.SWIGTYPE_p_SdfLayerHandleSet GetUsedRootLayers();
        public pxr.SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t GetVariantFallbacks();
        public bool HasAnyDynamicFileFormatArgumentDependencies();
        public bool IsInvalidAssetPath(string resolvedAssetPath);
        public bool IsInvalidSublayerIdentifier(string identifier);
        public bool IsLayerMuted(string layerIdentifier);
        public bool IsLayerMuted(pxr.SdfLayerHandle anchorLayer, string layerIdentifier);
        public bool IsLayerMuted(pxr.SdfLayerHandle anchorLayer, string layerIdentifier, pxr.SWIGTYPE_p_std__string canonicalMutedLayerIdentifier);
        public bool IsPayloadIncluded(pxr.SdfPath path);
        public bool IsPossibleDynamicFileFormatArgumentField(pxr.TfToken field);
        public bool IsUsd();
        public void PrintStatistics();
        public void Reload(pxr.SWIGTYPE_p_PcpChanges changes);
        public void ReloadReferences(pxr.SWIGTYPE_p_PcpChanges changes, pxr.SdfPath primPath);
        public void RequestLayerMuting(pxr.StdStringVector layersToMute, pxr.StdStringVector layersToUnmute);
        public void RequestLayerMuting(pxr.StdStringVector layersToMute, pxr.StdStringVector layersToUnmute, pxr.SWIGTYPE_p_PcpChanges changes);
        public void RequestPayloads(pxr.SWIGTYPE_p_std__setT_SdfPath_t pathsToInclude, pxr.SWIGTYPE_p_std__setT_SdfPath_t pathsToExclude);
        public void RequestPayloads(pxr.SWIGTYPE_p_std__setT_SdfPath_t pathsToInclude, pxr.SWIGTYPE_p_std__setT_SdfPath_t pathsToExclude, pxr.SWIGTYPE_p_PcpChanges changes);
        public void SetVariantFallbacks(pxr.SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t map);
        public void SetVariantFallbacks(pxr.SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t map, pxr.SWIGTYPE_p_PcpChanges changes);
    }

    public class PcpLayerStack : System.IDisposable
    {
        public void Apply(pxr.SWIGTYPE_p_PcpLayerStackChanges changes, pxr.SWIGTYPE_p_PcpLifeboat lifeboat);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_PcpMapExpression GetExpressionForRelocatesAtPath(pxr.SdfPath path);
        public pxr.PcpLayerStackIdentifier GetIdentifier();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetIncrementalRelocatesSourceToTarget();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetIncrementalRelocatesTargetToSource();
        public pxr.SdfLayerOffset GetLayerOffsetForLayer(pxr.SdfLayer arg0);
        public pxr.SdfLayerOffset GetLayerOffsetForLayer(pxr.SdfLayerHandle arg0);
        public pxr.SdfLayerOffset GetLayerOffsetForLayer(System.UInt32 layerIdx);
        public pxr.SdfLayerRefPtrVector GetLayers();
        public pxr.SdfLayerTreeHandle GetLayerTree();
        public pxr.SWIGTYPE_p_PcpErrorVector GetLocalErrors();
        public pxr.SWIGTYPE_p_std__setT_std__string_t GetMutedLayers();
        public pxr.SdfPathVector GetPathsToPrimsWithRelocates();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetRelocatesSourceToTarget();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetRelocatesTargetToSource();
        public pxr.SdfLayerHandleVector GetSessionLayers();
        public double GetTimeCodesPerSecond();
        public bool HasLayer(pxr.SdfLayer layer);
        public bool HasLayer(pxr.SdfLayerHandle layer);
    }

    public class PcpLayerStackIdentifier : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.ArResolverContext pathResolverContext { get; }
        public pxr.SdfLayerHandle rootLayer { get; }
        public pxr.SdfLayerHandle sessionLayer { get; }
        public PcpLayerStackIdentifier() {}
        public PcpLayerStackIdentifier(pxr.SdfLayerHandle rootLayer_) {}
        public PcpLayerStackIdentifier(pxr.SdfLayerHandle rootLayer_, pxr.SdfLayerHandle sessionLayer_) {}
        public PcpLayerStackIdentifier(pxr.SdfLayerHandle rootLayer_, pxr.SdfLayerHandle sessionLayer_, pxr.ArResolverContext pathResolverContext_) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public System.UInt32 GetHash();
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class PcpLayerStackIdentifierStr : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.ArResolverContext pathResolverContext { get; set; }
        public string rootLayerId { get; set; }
        public string sessionLayerId { get; set; }
        public PcpLayerStackIdentifierStr() {}
        public PcpLayerStackIdentifierStr(pxr.PcpLayerStackIdentifier lsid) {}
        public PcpLayerStackIdentifierStr(string rootLayerId) {}
        public PcpLayerStackIdentifierStr(string rootLayerId, string sessionLayerId) {}
        public PcpLayerStackIdentifierStr(string rootLayerId, string sessionLayerId, pxr.ArResolverContext resolverContext) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public System.UInt32 GetHash();
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class PcpLayerStackPtr : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpLayerStackPtr(pxr.PcpLayerStack ptr) {}
        public pxr.PcpLayerStack __deref__();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.PcpLayerStackIdentifier GetIdentifier();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetIncrementalRelocatesSourceToTarget();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetIncrementalRelocatesTargetToSource();
        public pxr.SdfLayerOffset GetLayerOffsetForLayer(pxr.SdfLayer arg0);
        public pxr.SdfLayerOffset GetLayerOffsetForLayer(pxr.SdfLayerHandle arg0);
        public pxr.SdfLayerOffset GetLayerOffsetForLayer(System.UInt32 layerIdx);
        public pxr.SdfLayerRefPtrVector GetLayers();
        public pxr.SdfLayerTreeHandle GetLayerTree();
        public pxr.SWIGTYPE_p_PcpErrorVector GetLocalErrors();
        public pxr.SWIGTYPE_p_std__setT_std__string_t GetMutedLayers();
        public pxr.SdfPathVector GetPathsToPrimsWithRelocates();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetRelocatesSourceToTarget();
        public pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t GetRelocatesTargetToSource();
        public pxr.SdfLayerHandleVector GetSessionLayers();
        public double GetTimeCodesPerSecond();
        public bool HasLayer(pxr.SdfLayer layer);
        public bool HasLayer(pxr.SdfLayerHandle layer);
    }

    [System.Reflection.DefaultMember(@"Item")] public class PcpLayerStackPtrVector : System.Collections.Generic.IEnumerable<pxr.PcpLayerStackPtr>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.PcpLayerStackPtr this[int index] { get; set; }
        public PcpLayerStackPtrVector() {}
        public PcpLayerStackPtrVector(pxr.PcpLayerStackPtrVector other) {}
        public PcpLayerStackPtrVector(System.Collections.ICollection c) {}
        public PcpLayerStackPtrVector(int capacity) {}
        public void Add(pxr.PcpLayerStackPtr x);
        public void AddRange(pxr.PcpLayerStackPtrVector values);
        public void Clear();
        public void CopyTo(pxr.PcpLayerStackPtr[] array);
        public void CopyTo(pxr.PcpLayerStackPtr[] array, int arrayIndex);
        public void CopyTo(int index, pxr.PcpLayerStackPtr[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.PcpLayerStackPtrVector.PcpLayerStackPtrVectorEnumerator GetEnumerator();
        public pxr.PcpLayerStackPtrVector GetRange(int index, int count);
        public void Insert(int index, pxr.PcpLayerStackPtr x);
        public void InsertRange(int index, pxr.PcpLayerStackPtrVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.PcpLayerStackPtrVector Repeat(pxr.PcpLayerStackPtr value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.PcpLayerStackPtrVector values);
        public sealed class PcpLayerStackPtrVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.PcpLayerStackPtr>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.PcpLayerStackPtr Current { get; }
            public PcpLayerStackPtrVectorEnumerator(pxr.PcpLayerStackPtrVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class PcpNodeRef : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpNodeRef() {}
        public bool CanContributeSpecs();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.PcpArcType GetArcType();
        public pxr.PcpNodeRefVector GetChildren();
        public pxr.SWIGTYPE_p_Pcp_CompressedSdSite GetCompressedSdSite(System.UInt32 layerIndex);
        public int GetDepthBelowIntroduction();
        public pxr.SdfPath GetIntroPath();
        public pxr.PcpLayerStack GetLayerStack();
        public pxr.SWIGTYPE_p_PcpMapExpression GetMapToParent();
        public pxr.SWIGTYPE_p_PcpMapExpression GetMapToRoot();
        public int GetNamespaceDepth();
        public pxr.PcpNodeRef GetOriginNode();
        public pxr.PcpNodeRef GetOriginRootNode();
        public pxr.PcpNodeRef GetParentNode();
        public pxr.SdfPath GetPath();
        public pxr.SdfPath GetPathAtIntroduction();
        public pxr.SdfPermission GetPermission();
        public pxr.PcpNodeRef GetRootNode();
        public int GetSiblingNumAtOrigin();
        public pxr.SWIGTYPE_p_PcpLayerStackSite GetSite();
        public bool HasSpecs();
        public bool HasSymmetry();
        public pxr.PcpNodeRef InsertChild(pxr.SWIGTYPE_p_PcpLayerStackSite site, pxr.PcpArc arc);
        public pxr.PcpNodeRef InsertChildSubgraph(pxr.SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__Ptr subgraph, pxr.PcpArc arc);
        public bool IsCulled();
        public bool IsDueToAncestor();
        public bool IsInert();
        public bool IsRestricted();
        public bool IsRootNode();
        public void SetCulled(bool culled);
        public void SetHasSpecs(bool hasSpecs);
        public void SetHasSymmetry(bool hasSymmetry);
        public void SetInert(bool inert);
        public void SetPermission(pxr.SdfPermission perm);
        public void SetRestricted(bool restricted);
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class PcpNodeRef_ChildrenIterator : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpNodeRef_ChildrenIterator() {}
        public PcpNodeRef_ChildrenIterator(pxr.PcpNodeRef node) {}
        public PcpNodeRef_ChildrenIterator(pxr.PcpNodeRef node, bool end) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class PcpNodeRef_ChildrenReverseIterator : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpNodeRef_ChildrenReverseIterator() {}
        public PcpNodeRef_ChildrenReverseIterator(pxr.PcpNodeRef node) {}
        public PcpNodeRef_ChildrenReverseIterator(pxr.PcpNodeRef_ChildrenIterator arg0) {}
        public PcpNodeRef_ChildrenReverseIterator(pxr.PcpNodeRef node, bool end) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class PcpNodeRefVector : System.Collections.Generic.IEnumerable<pxr.PcpNodeRef>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.PcpNodeRef this[int index] { get; set; }
        public PcpNodeRefVector() {}
        public PcpNodeRefVector(pxr.PcpNodeRefVector other) {}
        public PcpNodeRefVector(System.Collections.ICollection c) {}
        public PcpNodeRefVector(int capacity) {}
        public void Add(pxr.PcpNodeRef x);
        public void AddRange(pxr.PcpNodeRefVector values);
        public void Clear();
        public void CopyTo(pxr.PcpNodeRef[] array);
        public void CopyTo(pxr.PcpNodeRef[] array, int arrayIndex);
        public void CopyTo(int index, pxr.PcpNodeRef[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.PcpNodeRefVector.PcpNodeRefVectorEnumerator GetEnumerator();
        public pxr.PcpNodeRefVector GetRange(int index, int count);
        public void Insert(int index, pxr.PcpNodeRef x);
        public void InsertRange(int index, pxr.PcpNodeRefVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.PcpNodeRefVector Repeat(pxr.PcpNodeRef value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.PcpNodeRefVector values);
        public sealed class PcpNodeRefVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.PcpNodeRef>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.PcpNodeRef Current { get; }
            public PcpNodeRefVectorEnumerator(pxr.PcpNodeRefVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class PcpPrimIndex : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpPrimIndex() {}
        public PcpPrimIndex(pxr.PcpPrimIndex rhs) {}
        public pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t ComposeAuthoredVariantSelections();
        public void ComputePrimChildNames(pxr.TfTokenVector nameOrder, pxr.SWIGTYPE_p_TfDenseHashSetT_TfToken_TfToken__HashFunctor_t prohibitedNameSet);
        public void ComputePrimPropertyNames(pxr.TfTokenVector nameOrder);
        public virtual void Dispose();
        public void DumpToDotGraph(string filename);
        public void DumpToDotGraph(string filename, bool includeInheritOriginInfo);
        public void DumpToDotGraph(string filename, bool includeInheritOriginInfo, bool includeMaps);
        public string DumpToString();
        public string DumpToString(bool includeInheritOriginInfo);
        public string DumpToString(bool includeInheritOriginInfo, bool includeMaps);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__Ptr GetGraph();
        public pxr.SWIGTYPE_p_PcpErrorVector GetLocalErrors();
        public pxr.PcpNodeRef GetNodeProvidingSpec(pxr.SdfPrimSpecHandle primSpec);
        public pxr.PcpNodeRef GetNodeProvidingSpec(pxr.SdfLayerHandle layer, pxr.SdfPath path);
        public pxr.SWIGTYPE_p_PcpNodeRange GetNodeRange();
        public pxr.SWIGTYPE_p_PcpNodeRange GetNodeRange(pxr.PcpRangeType rangeType);
        public pxr.SdfPath GetPath();
        public pxr.SWIGTYPE_p_PcpPrimRange GetPrimRange();
        public pxr.SWIGTYPE_p_PcpPrimRange GetPrimRange(pxr.PcpRangeType rangeType);
        public pxr.SWIGTYPE_p_PcpPrimRange GetPrimRangeForNode(pxr.PcpNodeRef node);
        public pxr.PcpNodeRef GetRootNode();
        public string GetSelectionAppliedForVariantSet(string variantSet);
        public bool HasAnyPayloads();
        public bool HasSpecs();
        public bool IsInstanceable();
        public bool IsUsd();
        public bool IsValid();
        public void PrintStatistics();
        public void SetGraph(pxr.SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__RefPtr graph);
        public void swap(pxr.PcpPrimIndex rhs);
        public void Swap(pxr.PcpPrimIndex rhs);
    }

    public class PcpPropertyIndex : System.IDisposable
    {
        protected bool swigCMemOwn;
        public PcpPropertyIndex() {}
        public PcpPropertyIndex(pxr.PcpPropertyIndex rhs) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_PcpErrorVector GetLocalErrors();
        public System.UInt32 GetNumLocalSpecs();
        public pxr.SWIGTYPE_p_PcpPropertyRange GetPropertyRange();
        public pxr.SWIGTYPE_p_PcpPropertyRange GetPropertyRange(bool localOnly);
        public bool IsEmpty();
        public void Swap(pxr.PcpPropertyIndex index);
    }

    public enum PcpRangeType
    {
        public const pxr.PcpRangeType PcpRangeTypeAll = 6;
        public const pxr.PcpRangeType PcpRangeTypeInherit = 1;
        public const pxr.PcpRangeType PcpRangeTypeInvalid = 9;
        public const pxr.PcpRangeType PcpRangeTypePayload = 4;
        public const pxr.PcpRangeType PcpRangeTypeReference = 3;
        public const pxr.PcpRangeType PcpRangeTypeRoot = 0;
        public const pxr.PcpRangeType PcpRangeTypeSpecialize = 5;
        public const pxr.PcpRangeType PcpRangeTypeStrongerThanPayload = 8;
        public const pxr.PcpRangeType PcpRangeTypeVariant = 2;
        public const pxr.PcpRangeType PcpRangeTypeWeakerThanRoot = 7;
        public int value__;
    }

    public class PcpSiteTrackerSegment : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.PcpArcType arcType { get; set; }
        public pxr.SWIGTYPE_p_PcpSiteStr site { get; set; }
        public PcpSiteTrackerSegment() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class PlugPlugin : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool DeclaresType(pxr.TfType type);
        public bool DeclaresType(pxr.TfType type, bool includeSubclasses);
        public virtual void Dispose();
        protected virtual void Finalize();
        public string FindPluginResource(string path);
        public string FindPluginResource(string path, bool verify);
        public pxr.JsObject GetDependencies();
        public pxr.JsObject GetMetadata();
        public pxr.JsObject GetMetadataForType(pxr.TfType type);
        public string GetName();
        public string GetPath();
        public string GetResourcePath();
        public bool IsLoaded();
        public bool IsResource();
        public bool Load();
        public string MakeResourcePath(string path);
    }

    public class PlugRegistry : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual void Dispose();
        public static pxr.TfType FindDerivedTypeByName(pxr.TfType arg0, string typeName);
        public static pxr.TfType FindTypeByName(string typeName);
        public static void GetAllDerivedTypes(pxr.TfType arg0, pxr.SWIGTYPE_p_std__setT_TfType_t result);
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__PtrVector GetAllPlugins();
        public pxr.JsValue GetDataFromPluginMetaData(pxr.TfType type, string key);
        public static pxr.TfTypeVector GetDirectlyDerivedTypes(pxr.TfType arg0);
        public static pxr.PlugRegistry GetInstance();
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__Ptr GetPluginForType(pxr.TfType t);
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__Ptr GetPluginWithName(string name);
        public string GetStringFromPluginMetaData(pxr.TfType type, string key);
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__PtrVector RegisterPlugins(pxr.StdStringVector pathsToPlugInfo);
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__PtrVector RegisterPlugins(string pathToPlugInfo);
    }

    public class Sdf_PathIdentity : System.IDisposable
    {
        protected bool swigCMemOwn;
        public Sdf_PathIdentity() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class SdfAssetPath : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfAssetPath() {}
        public SdfAssetPath(string path) {}
        public SdfAssetPath(string path, string resolvedPath) {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.SdfAssetPath lhs, pxr.SdfAssetPath rhs);
        protected virtual void Finalize();
        public string GetAssetPath();
        public System.UInt32 GetHash();
        public virtual int GetHashCode();
        public string GetResolvedPath();
        public static bool operator ==(pxr.SdfAssetPath lhs, pxr.SdfAssetPath rhs);
        public static bool operator !=(pxr.SdfAssetPath lhs, pxr.SdfAssetPath rhs);
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfAssetPathArray : pxr.Vt_ArrayBase
    {
        public pxr.SdfAssetPath this[int index] { get; set; }
        public SdfAssetPathArray() {}
        public SdfAssetPathArray(pxr.SdfAssetPathArray other) {}
        public SdfAssetPathArray(System.UInt32 n) {}
        public SdfAssetPathArray(System.UInt32 n, pxr.SdfAssetPath value) {}
        public void assign(System.UInt32 n, pxr.SdfAssetPath fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.SdfAssetPath[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.SdfAssetPath[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.SdfAssetPathArray lhs, pxr.SdfAssetPathArray rhs);
        protected virtual void Finalize();
        protected pxr.SdfAssetPath GetValue(int index);
        public bool IsIdentical(pxr.SdfAssetPathArray other);
        public void pop_back();
        public void push_back(pxr.SdfAssetPath elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.SdfAssetPath value);
        public System.UInt32 size();
        public void swap(pxr.SdfAssetPathArray other);
        public virtual string ToString();
    }

    public class SdfAttributeSpec : pxr.SdfPropertySpec
    {
        public void ClearAllowedTokens();
        public void ClearColorSpace();
        public void ClearConnectionPaths();
        public void ClearDisplayUnit();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtTokenArray GetAllowedTokens();
        public pxr.TfToken GetColorSpace();
        public pxr.SWIGTYPE_p_SdfConnectionsProxy GetConnectionPathList();
        public pxr.SWIGTYPE_p_TfEnum GetDisplayUnit();
        public pxr.TfToken GetRoleName();
        public bool HasAllowedTokens();
        public bool HasColorSpace();
        public bool HasConnectionPaths();
        public bool HasDisplayUnit();
        public static pxr.SdfAttributeSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, pxr.SdfValueTypeName typeName);
        public static pxr.SdfAttributeSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability);
        public static pxr.SdfAttributeSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability, bool custom);
        public void SetAllowedTokens(pxr.VtTokenArray allowedTokens);
        public void SetColorSpace(pxr.TfToken colorSpace);
        public void SetDisplayUnit(pxr.SWIGTYPE_p_TfEnum displayUnit);
    }

    public class SdfAttributeSpecHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfAttributeSpecHandle() {}
        public SdfAttributeSpecHandle(pxr.SdfAttributeSpec spec) {}
        public SdfAttributeSpecHandle(pxr.SdfAttributeSpecHandle handle) {}
        public pxr.SdfAttributeSpec __deref__();
        public bool CanSetName(string newName, pxr.SWIGTYPE_p_std__string whyNot);
        public void ClearAllowedTokens();
        public void ClearColorSpace();
        public void ClearConnectionPaths();
        public void ClearDefaultValue();
        public void ClearDisplayUnit();
        public bool ClearField(pxr.TfToken name);
        public void ClearInfo(pxr.TfToken key);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtTokenArray GetAllowedTokens();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetAssetInfo();
        public pxr.TfToken GetColorSpace();
        public string GetComment();
        public pxr.SWIGTYPE_p_SdfConnectionsProxy GetConnectionPathList();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetCustomData();
        public pxr.VtValue GetDefaultValue();
        public string GetDisplayGroup();
        public string GetDisplayName();
        public pxr.SWIGTYPE_p_TfEnum GetDisplayUnit();
        public string GetDocumentation();
        public pxr.VtValue GetFallbackForInfo(pxr.TfToken key);
        public pxr.VtValue GetField(pxr.TfToken name);
        public bool GetHidden();
        public pxr.VtValue GetInfo(pxr.TfToken key);
        public pxr.SdfLayerHandle GetLayer();
        public pxr.TfToken GetMetaDataDisplayGroup(pxr.TfToken key);
        public pxr.TfTokenVector GetMetaDataInfoKeys();
        public string GetName();
        public pxr.TfToken GetNameToken();
        public pxr.SdfSpecHandle GetOwner();
        public pxr.SdfPath GetPath();
        public pxr.SdfPermission GetPermission();
        public string GetPrefix();
        public pxr.TfToken GetRoleName();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public pxr.SdfSpecType GetSpecType();
        public string GetSuffix();
        public string GetSymmetricPeer();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetSymmetryArguments();
        public pxr.TfToken GetSymmetryFunction();
        public pxr.SWIGTYPE_p_std__mapT_double_VtValue_std__lessT_double_t_t GetTimeSampleMap();
        public pxr.TfType GetTypeForInfo(pxr.TfToken key);
        public pxr.SdfValueTypeName GetTypeName();
        public pxr.TfType GetValueType();
        public pxr.SdfVariability GetVariability();
        public bool HasAllowedTokens();
        public bool HasColorSpace();
        public bool HasConnectionPaths();
        public bool HasDefaultValue();
        public bool HasDisplayUnit();
        public bool HasField(pxr.TfToken name);
        public bool HasInfo(pxr.TfToken key);
        public bool HasOnlyRequiredFields();
        public bool IsCustom();
        public bool IsDormant();
        public bool IsInert();
        public bool IsInert(bool ignoreChildren);
        public bool IsValidName(string name);
        public pxr.TfTokenVector ListFields();
        public pxr.TfTokenVector ListInfoKeys();
        public pxr.SdfAttributeSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, pxr.SdfValueTypeName typeName);
        public pxr.SdfAttributeSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability);
        public pxr.SdfAttributeSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability, bool custom);
        public bool PermissionToEdit();
        public void SetAllowedTokens(pxr.VtTokenArray allowedTokens);
        public void SetAssetInfo(string name, pxr.VtValue value);
        public void SetColorSpace(pxr.TfToken colorSpace);
        public void SetComment(string value);
        public void SetCustom(bool custom);
        public void SetCustomData(string name, pxr.VtValue value);
        public bool SetDefaultValue(pxr.VtValue defaultValue);
        public void SetDisplayGroup(string value);
        public void SetDisplayName(string value);
        public void SetDisplayUnit(pxr.SWIGTYPE_p_TfEnum displayUnit);
        public void SetDocumentation(string value);
        public bool SetField(pxr.TfToken name, pxr.VtValue value);
        public void SetHidden(bool value);
        public void SetInfo(pxr.TfToken key, pxr.VtValue value);
        public void SetInfoDictionaryValue(pxr.TfToken dictionaryKey, pxr.TfToken entryKey, pxr.VtValue value);
        public bool SetName(string newName);
        public bool SetName(string newName, bool validate);
        public void SetPermission(pxr.SdfPermission value);
        public void SetPrefix(string value);
        public void SetSuffix(string value);
        public void SetSymmetricPeer(string peerName);
        public void SetSymmetryArgument(string name, pxr.VtValue value);
        public void SetSymmetryFunction(pxr.TfToken functionName);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0, System.UInt32 indent);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfAttributeSpecHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfAttributeSpecHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfAttributeSpecHandle this[int index] { get; set; }
        public SdfAttributeSpecHandleVector() {}
        public SdfAttributeSpecHandleVector(pxr.SdfAttributeSpecHandleVector other) {}
        public SdfAttributeSpecHandleVector(System.Collections.ICollection c) {}
        public SdfAttributeSpecHandleVector(int capacity) {}
        public void Add(pxr.SdfAttributeSpecHandle x);
        public void AddRange(pxr.SdfAttributeSpecHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfAttributeSpecHandle[] array);
        public void CopyTo(pxr.SdfAttributeSpecHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfAttributeSpecHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfAttributeSpecHandleVector.SdfAttributeSpecHandleVectorEnumerator GetEnumerator();
        public pxr.SdfAttributeSpecHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfAttributeSpecHandle x);
        public void InsertRange(int index, pxr.SdfAttributeSpecHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfAttributeSpecHandleVector Repeat(pxr.SdfAttributeSpecHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfAttributeSpecHandleVector values);
        public sealed class SdfAttributeSpecHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfAttributeSpecHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfAttributeSpecHandle Current { get; }
            public SdfAttributeSpecHandleVectorEnumerator(pxr.SdfAttributeSpecHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfBatchNamespaceEdit : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfBatchNamespaceEdit() {}
        public SdfBatchNamespaceEdit(pxr.SdfBatchNamespaceEdit arg0) {}
        public SdfBatchNamespaceEdit(pxr.SdfNamespaceEditVector arg0) {}
        public void Add(pxr.SdfNamespaceEdit edit);
        public void Add(pxr.SdfPath currentPath, pxr.SdfPath newPath);
        public void Add(pxr.SdfPath currentPath, pxr.SdfPath newPath, int index);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfNamespaceEditVector GetEdits();
    }

    public class SdfHumanReadableValue : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfHumanReadableValue() {}
        public SdfHumanReadableValue(string text) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public string GetText();
    }

    public class SdfInt64ListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfInt64ListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfInt64ListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfInt64ListOp Create();
        public static pxr.SdfInt64ListOp Create(pxr.UsdGeomLongVector prependedItems);
        public static pxr.SdfInt64ListOp Create(pxr.UsdGeomLongVector prependedItems, pxr.UsdGeomLongVector appendedItems);
        public static pxr.SdfInt64ListOp Create(pxr.UsdGeomLongVector prependedItems, pxr.UsdGeomLongVector appendedItems, pxr.UsdGeomLongVector deletedItems);
        public static pxr.SdfInt64ListOp CreateExplicit();
        public static pxr.SdfInt64ListOp CreateExplicit(pxr.UsdGeomLongVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomLongVector GetAddedItems();
        public pxr.UsdGeomLongVector GetAppendedItems();
        public pxr.UsdGeomLongVector GetDeletedItems();
        public pxr.UsdGeomLongVector GetExplicitItems();
        public pxr.UsdGeomLongVector GetItems(pxr.SdfListOpType type);
        public pxr.UsdGeomLongVector GetOrderedItems();
        public pxr.UsdGeomLongVector GetPrependedItems();
        public bool HasItem(long item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.UsdGeomLongVector newItems);
        public void SetAddedItems(pxr.UsdGeomLongVector items);
        public void SetAppendedItems(pxr.UsdGeomLongVector items);
        public void SetDeletedItems(pxr.UsdGeomLongVector items);
        public void SetExplicitItems(pxr.UsdGeomLongVector items);
        public void SetItems(pxr.UsdGeomLongVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.UsdGeomLongVector items);
        public void SetPrependedItems(pxr.UsdGeomLongVector items);
        public void Swap(pxr.SdfInt64ListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfInt64ListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfInt64ListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfInt64ListOp this[int index] { get; set; }
        public SdfInt64ListOpVector() {}
        public SdfInt64ListOpVector(pxr.SdfInt64ListOpVector other) {}
        public SdfInt64ListOpVector(System.Collections.ICollection c) {}
        public SdfInt64ListOpVector(int capacity) {}
        public void Add(pxr.SdfInt64ListOp x);
        public void AddRange(pxr.SdfInt64ListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfInt64ListOp[] array);
        public void CopyTo(pxr.SdfInt64ListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfInt64ListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfInt64ListOpVector.SdfInt64ListOpVectorEnumerator GetEnumerator();
        public pxr.SdfInt64ListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfInt64ListOp x);
        public void InsertRange(int index, pxr.SdfInt64ListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfInt64ListOpVector Repeat(pxr.SdfInt64ListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfInt64ListOpVector values);
        public sealed class SdfInt64ListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfInt64ListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfInt64ListOp Current { get; }
            public SdfInt64ListOpVectorEnumerator(pxr.SdfInt64ListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfIntListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfIntListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfIntListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfIntListOp Create();
        public static pxr.SdfIntListOp Create(pxr.StdIntVector prependedItems);
        public static pxr.SdfIntListOp Create(pxr.StdIntVector prependedItems, pxr.StdIntVector appendedItems);
        public static pxr.SdfIntListOp Create(pxr.StdIntVector prependedItems, pxr.StdIntVector appendedItems, pxr.StdIntVector deletedItems);
        public static pxr.SdfIntListOp CreateExplicit();
        public static pxr.SdfIntListOp CreateExplicit(pxr.StdIntVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdIntVector GetAddedItems();
        public pxr.StdIntVector GetAppendedItems();
        public pxr.StdIntVector GetDeletedItems();
        public pxr.StdIntVector GetExplicitItems();
        public pxr.StdIntVector GetItems(pxr.SdfListOpType type);
        public pxr.StdIntVector GetOrderedItems();
        public pxr.StdIntVector GetPrependedItems();
        public bool HasItem(int item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.StdIntVector newItems);
        public void SetAddedItems(pxr.StdIntVector items);
        public void SetAppendedItems(pxr.StdIntVector items);
        public void SetDeletedItems(pxr.StdIntVector items);
        public void SetExplicitItems(pxr.StdIntVector items);
        public void SetItems(pxr.StdIntVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.StdIntVector items);
        public void SetPrependedItems(pxr.StdIntVector items);
        public void Swap(pxr.SdfIntListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfIntListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfIntListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfIntListOp this[int index] { get; set; }
        public SdfIntListOpVector() {}
        public SdfIntListOpVector(pxr.SdfIntListOpVector other) {}
        public SdfIntListOpVector(System.Collections.ICollection c) {}
        public SdfIntListOpVector(int capacity) {}
        public void Add(pxr.SdfIntListOp x);
        public void AddRange(pxr.SdfIntListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfIntListOp[] array);
        public void CopyTo(pxr.SdfIntListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfIntListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfIntListOpVector.SdfIntListOpVectorEnumerator GetEnumerator();
        public pxr.SdfIntListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfIntListOp x);
        public void InsertRange(int index, pxr.SdfIntListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfIntListOpVector Repeat(pxr.SdfIntListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfIntListOpVector values);
        public sealed class SdfIntListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfIntListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfIntListOp Current { get; }
            public SdfIntListOpVectorEnumerator(pxr.SdfIntListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfLayer : System.IDisposable
    {
        public static void AddToMutedLayers(string mutedPath);
        public bool Apply(pxr.SdfBatchNamespaceEdit arg0);
        public void ApplyRootPrimOrder(pxr.TfTokenVector vec);
        public pxr.SdfNamespaceEditDetail.Result CanApply(pxr.SdfBatchNamespaceEdit arg0);
        public pxr.SdfNamespaceEditDetail.Result CanApply(pxr.SdfBatchNamespaceEdit arg0, pxr.SdfNamespaceEditDetailVector details);
        public void Clear();
        public void ClearColorConfiguration();
        public void ClearColorManagementSystem();
        public void ClearCustomLayerData();
        public void ClearDefaultPrim();
        public void ClearEndTimeCode();
        public void ClearFramePrecision();
        public void ClearFramesPerSecond();
        public void ClearOwner();
        public void ClearSessionOwner();
        public void ClearStartTimeCode();
        public void ClearTimeCodesPerSecond();
        public string ComputeAbsolutePath(string relativePath);
        public static string ComputeRealPath(string layerPath);
        public static pxr.SdfLayer CreateAnonymous();
        public static pxr.SdfLayer CreateAnonymous(string tag);
        public static pxr.SdfLayer CreateAnonymous(string tag, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public static pxr.SdfLayer CreateAnonymous(string tag, pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr format);
        public static pxr.SdfLayer CreateAnonymous(string tag, pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr format, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public static string CreateIdentifier(string layerPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t arguments);
        public static pxr.SdfLayer CreateNew(string identifier);
        public static pxr.SdfLayer CreateNew(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier);
        public static pxr.SdfLayer CreateNew(string identifier, string realPath);
        public static pxr.SdfLayer CreateNew(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath);
        public static pxr.SdfLayer CreateNew(string identifier, string realPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public static pxr.SdfLayer CreateNew(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public virtual void Dispose();
        public static void DumpLayerInfo();
        public void EraseField(pxr.SdfPath path, pxr.TfToken fieldName);
        public void EraseFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath);
        public void EraseTimeSample(pxr.SdfPath path, double time);
        public bool Export(string filename);
        public bool Export(string filename, string comment);
        public bool Export(string filename, string comment, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public string ExportToString();
        protected virtual void Finalize();
        public static pxr.SdfLayerHandle Find(string identifier);
        public static pxr.SdfLayerHandle Find(string identifier, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public static pxr.SdfLayer FindOrOpen(string identifier);
        public static pxr.SdfLayer FindOrOpen(string identifier, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public static pxr.SdfLayerHandle FindRelativeToLayer(pxr.SdfLayerHandle anchor, string layerPath);
        public static pxr.SdfLayerHandle FindRelativeToLayer(pxr.SdfLayerHandle anchor, string layerPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.VtValue GetAssetInfo();
        public string GetAssetName();
        public pxr.SdfAttributeSpecHandle GetAttributeAtPath(pxr.SdfPath path);
        public bool GetBracketingTimeSamples(double time, ref double tLower, ref double tUpper);
        public bool GetBracketingTimeSamplesForPath(pxr.SdfPath path, double time, ref double tLower, ref double tUpper);
        public pxr.SdfAssetPath GetColorConfiguration();
        public pxr.TfToken GetColorManagementSystem();
        public string GetComment();
        public pxr.VtDictionary GetCustomLayerData();
        public pxr.TfToken GetDefaultPrim();
        public string GetDisplayName();
        public static string GetDisplayNameFromIdentifier(string identifier);
        public string GetDocumentation();
        public double GetEndTimeCode();
        public pxr.SWIGTYPE_p_std__setT_std__string_t GetExternalReferences();
        public pxr.VtValue GetField(pxr.SdfPath path, pxr.TfToken fieldName);
        public pxr.VtValue GetFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath);
        public pxr.SWIGTYPE_p_std__type_info GetFieldTypeid(pxr.SdfPath path, pxr.TfToken name);
        public string GetFileExtension();
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr GetFileFormat();
        public pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t GetFileFormatArguments();
        public int GetFramePrecision();
        public double GetFramesPerSecond();
        public bool GetHasOwnedSubLayers();
        public string GetIdentifier();
        public static pxr.SWIGTYPE_p_SdfLayerHandleSet GetLoadedLayers();
        public static pxr.SWIGTYPE_p_std__setT_std__string_t GetMutedLayers();
        public System.UInt32 GetNumSubLayerPaths();
        public System.UInt32 GetNumTimeSamplesForPath(pxr.SdfPath path);
        public pxr.SdfSpecHandle GetObjectAtPath(pxr.SdfPath path);
        public string GetOwner();
        public pxr.SdfPrimSpecHandle GetPrimAtPath(pxr.SdfPath path);
        public pxr.SdfPropertySpecHandle GetPropertyAtPath(pxr.SdfPath path);
        public pxr.SdfPrimSpecHandle GetPseudoRoot();
        public string GetRealPath();
        public pxr.SdfRelationshipSpecHandle GetRelationshipAtPath(pxr.SdfPath path);
        public string GetRepositoryPath();
        public pxr.SWIGTYPE_p_SdfPrimSpecView GetRootPrims();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public string GetSessionOwner();
        public pxr.SdfSpecType GetSpecType(pxr.SdfPath path);
        public double GetStartTimeCode();
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__Ptr GetStateDelegate();
        public pxr.SdfLayerOffset GetSubLayerOffset(int index);
        public pxr.SdfLayerOffsetVector GetSubLayerOffsets();
        public pxr.SdfSubLayerProxy GetSubLayerPaths();
        public double GetTimeCodesPerSecond();
        public string GetVersion();
        public bool HasColorConfiguration();
        public bool HasColorManagementSystem();
        public bool HasCustomLayerData();
        public bool HasDefaultPrim();
        public bool HasEndTimeCode();
        public bool HasField(pxr.SdfPath path, pxr.TfToken fieldName);
        public bool HasField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.SWIGTYPE_p_SdfAbstractDataValue value);
        public bool HasField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.VtValue value);
        public bool HasFieldDictKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath);
        public bool HasFieldDictKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.SWIGTYPE_p_SdfAbstractDataValue value);
        public bool HasFieldDictKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.VtValue value);
        public bool HasFramePrecision();
        public bool HasFramesPerSecond();
        public bool HasOwner();
        public bool HasSessionOwner();
        public bool HasSpec(pxr.SdfPath path);
        public bool HasStartTimeCode();
        public bool HasTimeCodesPerSecond();
        public bool Import(string layerPath);
        public bool ImportFromString(string arg0);
        public void InsertInRootPrimOrder(pxr.TfToken name);
        public void InsertInRootPrimOrder(pxr.TfToken name, int index);
        public bool InsertRootPrim(pxr.SdfPrimSpecHandle prim);
        public bool InsertRootPrim(pxr.SdfPrimSpecHandle prim, int index);
        public void InsertSubLayerPath(string path);
        public void InsertSubLayerPath(string path, int index);
        public bool IsAnonymous();
        public static bool IsAnonymousLayerIdentifier(string identifier);
        public bool IsDirty();
        public bool IsEmpty();
        public bool IsMuted();
        public static bool IsMuted(string path);
        public pxr.SWIGTYPE_p_std__setT_double_t ListAllTimeSamples();
        public pxr.TfTokenVector ListFields(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_std__setT_double_t ListTimeSamplesForPath(pxr.SdfPath path);
        public static pxr.SdfLayer New(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier);
        public static pxr.SdfLayer New(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath);
        public static pxr.SdfLayer New(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public static pxr.SdfLayer OpenAsAnonymous(string layerPath);
        public static pxr.SdfLayer OpenAsAnonymous(string layerPath, bool metadataOnly);
        public static pxr.SdfLayer OpenAsAnonymous(string layerPath, bool metadataOnly, string tag);
        public bool PermissionToEdit();
        public bool PermissionToSave();
        public bool QueryTimeSample(pxr.SdfPath path, double time);
        public bool QueryTimeSample(pxr.SdfPath path, double time, pxr.SWIGTYPE_p_SdfAbstractDataValue value);
        public bool QueryTimeSample(pxr.SdfPath path, double time, pxr.VtValue value);
        public bool Reload();
        public bool Reload(bool force);
        public static bool ReloadLayers(pxr.SWIGTYPE_p_std__setT_SdfLayerHandle_t layers);
        public static bool ReloadLayers(pxr.SWIGTYPE_p_std__setT_SdfLayerHandle_t layers, bool force);
        public static void RemoveFromMutedLayers(string mutedPath);
        public void RemoveFromRootPrimOrder(pxr.TfToken name);
        public void RemoveFromRootPrimOrderByIndex(int index);
        public void RemoveInertSceneDescription();
        public void RemovePrimIfInert(pxr.SdfPrimSpecHandle prim);
        public void RemovePropertyIfHasOnlyRequiredFields(pxr.SdfPropertySpecHandle prop);
        public void RemoveRootPrim(pxr.SdfPrimSpecHandle prim);
        public void RemoveSubLayerPath(int index);
        public bool Save();
        public bool Save(bool force);
        public void ScheduleRemoveIfInert(pxr.SdfSpec spec);
        public void SetColorConfiguration(pxr.SdfAssetPath colorConfiguration);
        public void SetColorManagementSystem(pxr.TfToken cms);
        public void SetComment(string comment);
        public void SetCustomLayerData(pxr.VtDictionary value);
        public void SetDefaultPrim(pxr.TfToken name);
        public void SetDocumentation(string documentation);
        public void SetEndTimeCode(double endTimeCode);
        public void SetField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.SWIGTYPE_p_SdfAbstractDataConstValue value);
        public void SetField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.VtValue value);
        public void SetFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.SWIGTYPE_p_SdfAbstractDataConstValue value);
        public void SetFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.VtValue value);
        public void SetFramePrecision(int framePrecision);
        public void SetFramesPerSecond(double framesPerSecond);
        public void SetHasOwnedSubLayers(bool arg0);
        public void SetIdentifier(string identifier);
        public void SetMuted(bool muted);
        public void SetOwner(string owner);
        public void SetPermissionToEdit(bool allow);
        public void SetPermissionToSave(bool allow);
        public void SetRootPrimOrder(pxr.TfTokenVector names);
        public void SetRootPrims(pxr.SdfPrimSpecHandleVector rootPrims);
        public void SetSessionOwner(string owner);
        public void SetStartTimeCode(double startTimecode);
        public void SetStateDelegate(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__RefPtr arg0);
        public void SetSubLayerOffset(pxr.SdfLayerOffset offset, int index);
        public void SetSubLayerPaths(pxr.StdStringVector newPaths);
        public void SetTimeCodesPerSecond(double timeCodesPerSecond);
        public void SetTimeSample(pxr.SdfPath path, double time, pxr.SWIGTYPE_p_SdfAbstractDataConstValue value);
        public void SetTimeSample(pxr.SdfPath path, double time, pxr.VtValue value);
        public static bool SplitIdentifier(string identifier, pxr.SWIGTYPE_p_std__string layerPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t arguments);
        public void TransferContent(pxr.SdfLayerHandle layer);
        public void UpdateAssetInfo();
        public void UpdateAssetInfo(string fileVersion);
        public bool UpdateExternalReference(string oldAssetPath);
        public bool UpdateExternalReference(string oldAssetPath, string newAssetPath);
        public bool WriteDataFile(string filename);
    }

    public class SdfLayerHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfLayerHandle(pxr.SdfLayer layer) {}
        public pxr.SdfLayer __deref__();
        public void AddToMutedLayers(string mutedPath);
        public bool Apply(pxr.SdfBatchNamespaceEdit arg0);
        public void ApplyRootPrimOrder(pxr.TfTokenVector vec);
        public pxr.SdfNamespaceEditDetail.Result CanApply(pxr.SdfBatchNamespaceEdit arg0);
        public pxr.SdfNamespaceEditDetail.Result CanApply(pxr.SdfBatchNamespaceEdit arg0, pxr.SdfNamespaceEditDetailVector details);
        public void Clear();
        public void ClearColorConfiguration();
        public void ClearColorManagementSystem();
        public void ClearCustomLayerData();
        public void ClearDefaultPrim();
        public void ClearEndTimeCode();
        public void ClearFramePrecision();
        public void ClearFramesPerSecond();
        public void ClearOwner();
        public void ClearSessionOwner();
        public void ClearStartTimeCode();
        public void ClearTimeCodesPerSecond();
        public string ComputeAbsolutePath(string relativePath);
        public string ComputeRealPath(string layerPath);
        public pxr.SdfLayer CreateAnonymous();
        public pxr.SdfLayer CreateAnonymous(string tag);
        public pxr.SdfLayer CreateAnonymous(string tag, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.SdfLayer CreateAnonymous(string tag, pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr format);
        public pxr.SdfLayer CreateAnonymous(string tag, pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr format, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public string CreateIdentifier(string layerPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t arguments);
        public pxr.SdfLayer CreateNew(string identifier);
        public pxr.SdfLayer CreateNew(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier);
        public pxr.SdfLayer CreateNew(string identifier, string realPath);
        public pxr.SdfLayer CreateNew(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath);
        public pxr.SdfLayer CreateNew(string identifier, string realPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.SdfLayer CreateNew(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public virtual void Dispose();
        public void DumpLayerInfo();
        public void EraseField(pxr.SdfPath path, pxr.TfToken fieldName);
        public void EraseFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath);
        public void EraseTimeSample(pxr.SdfPath path, double time);
        public bool Export(string filename);
        public bool Export(string filename, string comment);
        public bool Export(string filename, string comment, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public string ExportToString();
        protected virtual void Finalize();
        public pxr.SdfLayerHandle Find(string identifier);
        public pxr.SdfLayerHandle Find(string identifier, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.SdfLayer FindOrOpen(string identifier);
        public pxr.SdfLayer FindOrOpen(string identifier, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.SdfLayerHandle FindRelativeToLayer(pxr.SdfLayerHandle anchor, string layerPath);
        public pxr.SdfLayerHandle FindRelativeToLayer(pxr.SdfLayerHandle anchor, string layerPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.VtValue GetAssetInfo();
        public string GetAssetName();
        public pxr.SdfAttributeSpecHandle GetAttributeAtPath(pxr.SdfPath path);
        public bool GetBracketingTimeSamples(double time, ref double tLower, ref double tUpper);
        public bool GetBracketingTimeSamplesForPath(pxr.SdfPath path, double time, ref double tLower, ref double tUpper);
        public pxr.SdfAssetPath GetColorConfiguration();
        public pxr.TfToken GetColorManagementSystem();
        public string GetComment();
        public pxr.VtDictionary GetCustomLayerData();
        public pxr.TfToken GetDefaultPrim();
        public string GetDisplayName();
        public string GetDisplayNameFromIdentifier(string identifier);
        public string GetDocumentation();
        public double GetEndTimeCode();
        public pxr.SWIGTYPE_p_std__setT_std__string_t GetExternalReferences();
        public pxr.VtValue GetField(pxr.SdfPath path, pxr.TfToken fieldName);
        public pxr.VtValue GetFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath);
        public pxr.SWIGTYPE_p_std__type_info GetFieldTypeid(pxr.SdfPath path, pxr.TfToken name);
        public string GetFileExtension();
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr GetFileFormat();
        public pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t GetFileFormatArguments();
        public int GetFramePrecision();
        public double GetFramesPerSecond();
        public bool GetHasOwnedSubLayers();
        public string GetIdentifier();
        public pxr.SWIGTYPE_p_SdfLayerHandleSet GetLoadedLayers();
        public pxr.SWIGTYPE_p_std__setT_std__string_t GetMutedLayers();
        public System.UInt32 GetNumSubLayerPaths();
        public System.UInt32 GetNumTimeSamplesForPath(pxr.SdfPath path);
        public pxr.SdfSpecHandle GetObjectAtPath(pxr.SdfPath path);
        public string GetOwner();
        public pxr.SdfPrimSpecHandle GetPrimAtPath(pxr.SdfPath path);
        public pxr.SdfPropertySpecHandle GetPropertyAtPath(pxr.SdfPath path);
        public pxr.SdfPrimSpecHandle GetPseudoRoot();
        public string GetRealPath();
        public pxr.SdfRelationshipSpecHandle GetRelationshipAtPath(pxr.SdfPath path);
        public string GetRepositoryPath();
        public pxr.SWIGTYPE_p_SdfPrimSpecView GetRootPrims();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public string GetSessionOwner();
        public pxr.SdfSpecType GetSpecType(pxr.SdfPath path);
        public double GetStartTimeCode();
        public pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__Ptr GetStateDelegate();
        public pxr.SdfLayerOffset GetSubLayerOffset(int index);
        public pxr.SdfLayerOffsetVector GetSubLayerOffsets();
        public pxr.SdfSubLayerProxy GetSubLayerPaths();
        public double GetTimeCodesPerSecond();
        public string GetVersion();
        public bool HasColorConfiguration();
        public bool HasColorManagementSystem();
        public bool HasCustomLayerData();
        public bool HasDefaultPrim();
        public bool HasEndTimeCode();
        public bool HasField(pxr.SdfPath path, pxr.TfToken fieldName);
        public bool HasField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.SWIGTYPE_p_SdfAbstractDataValue value);
        public bool HasField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.VtValue value);
        public bool HasFieldDictKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath);
        public bool HasFieldDictKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.SWIGTYPE_p_SdfAbstractDataValue value);
        public bool HasFieldDictKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.VtValue value);
        public bool HasFramePrecision();
        public bool HasFramesPerSecond();
        public bool HasOwner();
        public bool HasSessionOwner();
        public bool HasSpec(pxr.SdfPath path);
        public bool HasStartTimeCode();
        public bool HasTimeCodesPerSecond();
        public bool Import(string layerPath);
        public bool ImportFromString(string arg0);
        public void InsertInRootPrimOrder(pxr.TfToken name);
        public void InsertInRootPrimOrder(pxr.TfToken name, int index);
        public bool InsertRootPrim(pxr.SdfPrimSpecHandle prim);
        public bool InsertRootPrim(pxr.SdfPrimSpecHandle prim, int index);
        public void InsertSubLayerPath(string path);
        public void InsertSubLayerPath(string path, int index);
        public bool IsAnonymous();
        public bool IsAnonymousLayerIdentifier(string identifier);
        public bool IsDirty();
        public bool IsEmpty();
        public bool IsMuted();
        public bool IsMuted(string path);
        public pxr.SWIGTYPE_p_std__setT_double_t ListAllTimeSamples();
        public pxr.TfTokenVector ListFields(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_std__setT_double_t ListTimeSamplesForPath(pxr.SdfPath path);
        public pxr.SdfLayer New(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier);
        public pxr.SdfLayer New(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath);
        public pxr.SdfLayer New(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr fileFormat, string identifier, string realPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public pxr.SdfLayer OpenAsAnonymous(string layerPath);
        public pxr.SdfLayer OpenAsAnonymous(string layerPath, bool metadataOnly);
        public pxr.SdfLayer OpenAsAnonymous(string layerPath, bool metadataOnly, string tag);
        public bool PermissionToEdit();
        public bool PermissionToSave();
        public bool QueryTimeSample(pxr.SdfPath path, double time);
        public bool QueryTimeSample(pxr.SdfPath path, double time, pxr.SWIGTYPE_p_SdfAbstractDataValue value);
        public bool QueryTimeSample(pxr.SdfPath path, double time, pxr.VtValue value);
        public bool Reload();
        public bool Reload(bool force);
        public bool ReloadLayers(pxr.SWIGTYPE_p_std__setT_SdfLayerHandle_t layers);
        public bool ReloadLayers(pxr.SWIGTYPE_p_std__setT_SdfLayerHandle_t layers, bool force);
        public void RemoveFromMutedLayers(string mutedPath);
        public void RemoveFromRootPrimOrder(pxr.TfToken name);
        public void RemoveFromRootPrimOrderByIndex(int index);
        public void RemoveInertSceneDescription();
        public void RemovePrimIfInert(pxr.SdfPrimSpecHandle prim);
        public void RemovePropertyIfHasOnlyRequiredFields(pxr.SdfPropertySpecHandle prop);
        public void RemoveRootPrim(pxr.SdfPrimSpecHandle prim);
        public void RemoveSubLayerPath(int index);
        public bool Save();
        public bool Save(bool force);
        public void ScheduleRemoveIfInert(pxr.SdfSpec spec);
        public void SetColorConfiguration(pxr.SdfAssetPath colorConfiguration);
        public void SetColorManagementSystem(pxr.TfToken cms);
        public void SetComment(string comment);
        public void SetCustomLayerData(pxr.VtDictionary value);
        public void SetDefaultPrim(pxr.TfToken name);
        public void SetDocumentation(string documentation);
        public void SetEndTimeCode(double endTimeCode);
        public void SetField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.SWIGTYPE_p_SdfAbstractDataConstValue value);
        public void SetField(pxr.SdfPath path, pxr.TfToken fieldName, pxr.VtValue value);
        public void SetFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.SWIGTYPE_p_SdfAbstractDataConstValue value);
        public void SetFieldDictValueByKey(pxr.SdfPath path, pxr.TfToken fieldName, pxr.TfToken keyPath, pxr.VtValue value);
        public void SetFramePrecision(int framePrecision);
        public void SetFramesPerSecond(double framesPerSecond);
        public void SetHasOwnedSubLayers(bool arg0);
        public void SetIdentifier(string identifier);
        public void SetMuted(bool muted);
        public void SetOwner(string owner);
        public void SetPermissionToEdit(bool allow);
        public void SetPermissionToSave(bool allow);
        public void SetRootPrimOrder(pxr.TfTokenVector names);
        public void SetRootPrims(pxr.SdfPrimSpecHandleVector rootPrims);
        public void SetSessionOwner(string owner);
        public void SetStartTimeCode(double startTimecode);
        public void SetStateDelegate(pxr.SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__RefPtr arg0);
        public void SetSubLayerOffset(pxr.SdfLayerOffset offset, int index);
        public void SetSubLayerPaths(pxr.StdStringVector newPaths);
        public void SetTimeCodesPerSecond(double timeCodesPerSecond);
        public void SetTimeSample(pxr.SdfPath path, double time, pxr.SWIGTYPE_p_SdfAbstractDataConstValue value);
        public void SetTimeSample(pxr.SdfPath path, double time, pxr.VtValue value);
        public bool SplitIdentifier(string identifier, pxr.SWIGTYPE_p_std__string layerPath, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t arguments);
        public void TransferContent(pxr.SdfLayerHandle layer);
        public void UpdateAssetInfo();
        public void UpdateAssetInfo(string fileVersion);
        public bool UpdateExternalReference(string oldAssetPath);
        public bool UpdateExternalReference(string oldAssetPath, string newAssetPath);
        public bool WriteDataFile(string filename);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfLayerHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfLayerHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfLayerHandle this[int index] { get; set; }
        public SdfLayerHandleVector() {}
        public SdfLayerHandleVector(pxr.SdfLayerHandleVector other) {}
        public SdfLayerHandleVector(System.Collections.ICollection c) {}
        public SdfLayerHandleVector(int capacity) {}
        public void Add(pxr.SdfLayerHandle x);
        public void AddRange(pxr.SdfLayerHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfLayerHandle[] array);
        public void CopyTo(pxr.SdfLayerHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfLayerHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayerHandleVector.SdfLayerHandleVectorEnumerator GetEnumerator();
        public pxr.SdfLayerHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfLayerHandle x);
        public void InsertRange(int index, pxr.SdfLayerHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfLayerHandleVector Repeat(pxr.SdfLayerHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfLayerHandleVector values);
        public sealed class SdfLayerHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfLayerHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfLayerHandle Current { get; }
            public SdfLayerHandleVectorEnumerator(pxr.SdfLayerHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfLayerOffset : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfLayerOffset() {}
        public SdfLayerOffset(double offset) {}
        public SdfLayerOffset(double offset, double scale) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public System.UInt32 GetHash();
        public pxr.SdfLayerOffset GetInverse();
        public double GetOffset();
        public double GetScale();
        public bool IsIdentity();
        public bool IsValid();
        public void SetOffset(double newOffset);
        public void SetScale(double newScale);
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfLayerOffsetVector : System.Collections.Generic.IEnumerable<pxr.SdfLayerOffset>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfLayerOffset this[int index] { get; set; }
        public SdfLayerOffsetVector() {}
        public SdfLayerOffsetVector(pxr.SdfLayerOffsetVector other) {}
        public SdfLayerOffsetVector(System.Collections.ICollection c) {}
        public SdfLayerOffsetVector(int capacity) {}
        public void Add(pxr.SdfLayerOffset x);
        public void AddRange(pxr.SdfLayerOffsetVector values);
        public void Clear();
        public void CopyTo(pxr.SdfLayerOffset[] array);
        public void CopyTo(pxr.SdfLayerOffset[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfLayerOffset[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayerOffsetVector.SdfLayerOffsetVectorEnumerator GetEnumerator();
        public pxr.SdfLayerOffsetVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfLayerOffset x);
        public void InsertRange(int index, pxr.SdfLayerOffsetVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfLayerOffsetVector Repeat(pxr.SdfLayerOffset value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfLayerOffsetVector values);
        public sealed class SdfLayerOffsetVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfLayerOffset>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfLayerOffset Current { get; }
            public SdfLayerOffsetVectorEnumerator(pxr.SdfLayerOffsetVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfLayerRefPtrVector : System.Collections.Generic.IEnumerable<pxr.SdfLayer>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfLayer this[int index] { get; set; }
        public SdfLayerRefPtrVector() {}
        public SdfLayerRefPtrVector(pxr.SdfLayerRefPtrVector other) {}
        public SdfLayerRefPtrVector(System.Collections.ICollection c) {}
        public SdfLayerRefPtrVector(int capacity) {}
        public void Add(pxr.SdfLayer x);
        public void AddRange(pxr.SdfLayerRefPtrVector values);
        public void Clear();
        public void CopyTo(pxr.SdfLayer[] array);
        public void CopyTo(pxr.SdfLayer[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfLayer[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayerRefPtrVector.SdfLayerRefPtrVectorEnumerator GetEnumerator();
        public pxr.SdfLayerRefPtrVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfLayer x);
        public void InsertRange(int index, pxr.SdfLayerRefPtrVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfLayerRefPtrVector Repeat(pxr.SdfLayer value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfLayerRefPtrVector values);
        public sealed class SdfLayerRefPtrVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfLayer>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfLayer Current { get; }
            public SdfLayerRefPtrVectorEnumerator(pxr.SdfLayerRefPtrVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfLayerTree : System.IDisposable
    {
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayerTreeHandleVector GetChildTrees();
        public pxr.SdfLayerHandle GetLayer();
        public pxr.SdfLayerOffset GetOffset();
        public static pxr.SdfLayerTreeHandle New(pxr.SdfLayerHandle layer, pxr.SdfLayerTreeHandleVector childTrees);
        public static pxr.SdfLayerTreeHandle New(pxr.SdfLayerHandle layer, pxr.SdfLayerTreeHandleVector childTrees, pxr.SdfLayerOffset cumulativeOffset);
    }

    public class SdfLayerTreeHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfLayerTreeHandle(pxr.SdfLayerTree layer) {}
        public pxr.SdfLayerTree __deref__();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayerTreeHandleVector GetChildTrees();
        public pxr.SdfLayerHandle GetLayer();
        public pxr.SdfLayerOffset GetOffset();
        public pxr.SdfLayerTreeHandle New(pxr.SdfLayerHandle layer, pxr.SdfLayerTreeHandleVector childTrees);
        public pxr.SdfLayerTreeHandle New(pxr.SdfLayerHandle layer, pxr.SdfLayerTreeHandleVector childTrees, pxr.SdfLayerOffset cumulativeOffset);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfLayerTreeHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfLayerTreeHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfLayerTreeHandle this[int index] { get; set; }
        public SdfLayerTreeHandleVector() {}
        public SdfLayerTreeHandleVector(pxr.SdfLayerTreeHandleVector other) {}
        public SdfLayerTreeHandleVector(System.Collections.ICollection c) {}
        public SdfLayerTreeHandleVector(int capacity) {}
        public void Add(pxr.SdfLayerTreeHandle x);
        public void AddRange(pxr.SdfLayerTreeHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfLayerTreeHandle[] array);
        public void CopyTo(pxr.SdfLayerTreeHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfLayerTreeHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayerTreeHandleVector.SdfLayerTreeHandleVectorEnumerator GetEnumerator();
        public pxr.SdfLayerTreeHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfLayerTreeHandle x);
        public void InsertRange(int index, pxr.SdfLayerTreeHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfLayerTreeHandleVector Repeat(pxr.SdfLayerTreeHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfLayerTreeHandleVector values);
        public sealed class SdfLayerTreeHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfLayerTreeHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfLayerTreeHandle Current { get; }
            public SdfLayerTreeHandleVectorEnumerator(pxr.SdfLayerTreeHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public enum SdfListOpType
    {
        public const pxr.SdfListOpType SdfListOpTypeAdded = 1;
        public const pxr.SdfListOpType SdfListOpTypeAppended = 5;
        public const pxr.SdfListOpType SdfListOpTypeDeleted = 2;
        public const pxr.SdfListOpType SdfListOpTypeExplicit = 0;
        public const pxr.SdfListOpType SdfListOpTypeOrdered = 3;
        public const pxr.SdfListOpType SdfListOpTypePrepended = 4;
        public int value__;
    }

    public class SdfNamespaceEdit : System.IDisposable
    {
        public static readonly int AtEnd;
        public static readonly int Same;
        protected bool swigCMemOwn;
        public pxr.SdfPath currentPath { get; set; }
        public int index { get; set; }
        public pxr.SdfPath newPath { get; set; }
        public SdfNamespaceEdit() {}
        public SdfNamespaceEdit(pxr.SdfPath currentPath_, pxr.SdfPath newPath_) {}
        public SdfNamespaceEdit(pxr.SdfPath currentPath_, pxr.SdfPath newPath_, int index_) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.SdfNamespaceEdit Remove(pxr.SdfPath currentPath);
        public static pxr.SdfNamespaceEdit Rename(pxr.SdfPath currentPath, pxr.TfToken name);
        public static pxr.SdfNamespaceEdit Reorder(pxr.SdfPath currentPath, int index);
        public static pxr.SdfNamespaceEdit Reparent(pxr.SdfPath currentPath, pxr.SdfPath newParentPath, int index);
        public static pxr.SdfNamespaceEdit ReparentAndRename(pxr.SdfPath currentPath, pxr.SdfPath newParentPath, pxr.TfToken name, int index);
    }

    public class SdfNamespaceEditDetail : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.SdfNamespaceEdit edit { get; set; }
        public string reason { get; set; }
        public pxr.SdfNamespaceEditDetail.Result result { get; set; }
        public SdfNamespaceEditDetail() {}
        public SdfNamespaceEditDetail(pxr.SdfNamespaceEditDetail.Result arg0, pxr.SdfNamespaceEdit edit, string reason) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public enum Result
        {
            public const pxr.SdfNamespaceEditDetail.Result Error = 0;
            public const pxr.SdfNamespaceEditDetail.Result Okay = 2;
            public const pxr.SdfNamespaceEditDetail.Result Unbatched = 1;
            public int value__;
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfNamespaceEditDetailVector : System.Collections.Generic.IEnumerable<pxr.SdfNamespaceEditDetail>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfNamespaceEditDetail this[int index] { get; set; }
        public SdfNamespaceEditDetailVector() {}
        public SdfNamespaceEditDetailVector(pxr.SdfNamespaceEditDetailVector other) {}
        public SdfNamespaceEditDetailVector(System.Collections.ICollection c) {}
        public SdfNamespaceEditDetailVector(int capacity) {}
        public void Add(pxr.SdfNamespaceEditDetail x);
        public void AddRange(pxr.SdfNamespaceEditDetailVector values);
        public void Clear();
        public void CopyTo(pxr.SdfNamespaceEditDetail[] array);
        public void CopyTo(pxr.SdfNamespaceEditDetail[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfNamespaceEditDetail[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfNamespaceEditDetailVector.SdfNamespaceEditDetailVectorEnumerator GetEnumerator();
        public pxr.SdfNamespaceEditDetailVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfNamespaceEditDetail x);
        public void InsertRange(int index, pxr.SdfNamespaceEditDetailVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfNamespaceEditDetailVector Repeat(pxr.SdfNamespaceEditDetail value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfNamespaceEditDetailVector values);
        public sealed class SdfNamespaceEditDetailVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfNamespaceEditDetail>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfNamespaceEditDetail Current { get; }
            public SdfNamespaceEditDetailVectorEnumerator(pxr.SdfNamespaceEditDetailVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfNamespaceEditVector : System.Collections.Generic.IEnumerable<pxr.SdfNamespaceEdit>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfNamespaceEdit this[int index] { get; set; }
        public SdfNamespaceEditVector() {}
        public SdfNamespaceEditVector(pxr.SdfNamespaceEditVector other) {}
        public SdfNamespaceEditVector(System.Collections.ICollection c) {}
        public SdfNamespaceEditVector(int capacity) {}
        public void Add(pxr.SdfNamespaceEdit x);
        public void AddRange(pxr.SdfNamespaceEditVector values);
        public void Clear();
        public void CopyTo(pxr.SdfNamespaceEdit[] array);
        public void CopyTo(pxr.SdfNamespaceEdit[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfNamespaceEdit[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfNamespaceEditVector.SdfNamespaceEditVectorEnumerator GetEnumerator();
        public pxr.SdfNamespaceEditVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfNamespaceEdit x);
        public void InsertRange(int index, pxr.SdfNamespaceEditVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfNamespaceEditVector Repeat(pxr.SdfNamespaceEdit value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfNamespaceEditVector values);
        public sealed class SdfNamespaceEditVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfNamespaceEdit>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfNamespaceEdit Current { get; }
            public SdfNamespaceEditVectorEnumerator(pxr.SdfNamespaceEditVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfPath : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfPath() {}
        public SdfPath(string path) {}
        public static pxr.SdfPath AbsoluteRootPath();
        public pxr.SdfPath AppendChild(pxr.TfToken childName);
        public pxr.SdfPath AppendElementString(string element);
        public pxr.SdfPath AppendElementToken(pxr.TfToken elementTok);
        public pxr.SdfPath AppendExpression();
        public pxr.SdfPath AppendMapper(pxr.SdfPath targetPath);
        public pxr.SdfPath AppendMapperArg(pxr.TfToken argName);
        public pxr.SdfPath AppendPath(pxr.SdfPath newSuffix);
        public pxr.SdfPath AppendProperty(pxr.TfToken propName);
        public pxr.SdfPath AppendRelationalAttribute(pxr.TfToken attrName);
        public pxr.SdfPath AppendTarget(pxr.SdfPath targetPath);
        public pxr.SdfPath AppendVariantSelection(string variantSet, string variant);
        public bool ContainsPrimVariantSelection();
        public bool ContainsPropertyElements();
        public bool ContainsTargetPath();
        public virtual void Dispose();
        public static pxr.SdfPath EmptyPath();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.SdfPath lhs, pxr.SdfPath rhs);
        protected virtual void Finalize();
        public pxr.SdfPath GetAbsoluteRootOrPrimPath();
        public void GetAllTargetPathsRecursively(pxr.SdfPathVector result);
        public pxr.SdfPathAncestorsRange GetAncestorsRange();
        public pxr.SdfPath GetCommonPrefix(pxr.SdfPath path);
        public static pxr.SdfPathVector GetConciseRelativePaths(pxr.SdfPathVector paths);
        public string GetElementString();
        public pxr.TfToken GetElementToken();
        public System.UInt32 GetHash();
        public virtual int GetHashCode();
        public string GetName();
        public pxr.TfToken GetNameToken();
        public pxr.SdfPath GetParentPath();
        public System.UInt32 GetPathElementCount();
        public pxr.SdfPathVector GetPrefixes();
        public void GetPrefixes(pxr.SdfPathVector prefixes);
        public pxr.SdfPath GetPrimOrPrimVariantSelectionPath();
        public pxr.SdfPath GetPrimPath();
        public string GetString();
        public pxr.SdfPath GetTargetPath();
        public string GetText();
        public pxr.TfToken GetToken();
        public pxr.SdfPathStringPair GetVariantSelection();
        public bool HasPrefix(pxr.SdfPath prefix);
        public bool IsAbsolutePath();
        public bool IsAbsoluteRootOrPrimPath();
        public bool IsAbsoluteRootPath();
        public bool IsEmpty();
        public bool IsExpressionPath();
        public bool IsMapperArgPath();
        public bool IsMapperPath();
        public bool IsNamespacedPropertyPath();
        public bool IsPrimOrPrimVariantSelectionPath();
        public bool IsPrimPath();
        public bool IsPrimPropertyPath();
        public bool IsPrimVariantSelectionPath();
        public bool IsPropertyPath();
        public bool IsRelationalAttributePath();
        public bool IsRootPrimPath();
        public bool IsTargetPath();
        public static bool IsValidIdentifier(string name);
        public static bool IsValidNamespacedIdentifier(string name);
        public static bool IsValidPathString(string pathString);
        public static bool IsValidPathString(string pathString, pxr.SWIGTYPE_p_std__string errMsg);
        public static string JoinIdentifier(pxr.StdStringVector names);
        public static string JoinIdentifier(pxr.TfTokenVector names);
        public static string JoinIdentifier(pxr.TfToken lhs, pxr.TfToken rhs);
        public static string JoinIdentifier(string lhs, string rhs);
        public pxr.SdfPath MakeAbsolutePath(pxr.SdfPath anchor);
        public pxr.SdfPath MakeRelativePath(pxr.SdfPath anchor);
        public static bool operator ==(pxr.SdfPath lhs, pxr.SdfPath rhs);
        public static string op_Implicit(pxr.SdfPath value);
        public static bool operator !=(pxr.SdfPath lhs, pxr.SdfPath rhs);
        public static pxr.SdfPath ReflexiveRelativePath();
        public static void RemoveAncestorPaths(pxr.SdfPathVector paths);
        public pxr.SdfPathPair RemoveCommonSuffix(pxr.SdfPath otherPath);
        public pxr.SdfPathPair RemoveCommonSuffix(pxr.SdfPath otherPath, bool stopAtRootPrim);
        public static void RemoveDescendentPaths(pxr.SdfPathVector paths);
        public pxr.SdfPath ReplaceName(pxr.TfToken newName);
        public pxr.SdfPath ReplacePrefix(pxr.SdfPath oldPrefix, pxr.SdfPath newPrefix);
        public pxr.SdfPath ReplacePrefix(pxr.SdfPath oldPrefix, pxr.SdfPath newPrefix, bool fixTargetPaths);
        public pxr.SdfPath ReplaceTargetPath(pxr.SdfPath newTargetPath);
        public pxr.SdfPath StripAllVariantSelections();
        public static pxr.TfToken StripNamespace(pxr.TfToken name);
        public static string StripNamespace(string name);
        public static pxr.SWIGTYPE_p_std__pairT_std__string_bool_t StripPrefixNamespace(string name, string matchNamespace);
        public static pxr.StdStringVector TokenizeIdentifier(string name);
        public static pxr.TfTokenVector TokenizeIdentifierAsTokens(string name);
        public virtual string ToString();
        public class FastLessThan : System.IDisposable
        {
            protected bool swigCMemOwn;
            public FastLessThan() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class SdfPathAncestorsRange : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfPathAncestorsRange(pxr.SdfPath path) {}
        public pxr.SdfPathAncestorsRange.iterator begin();
        public virtual void Dispose();
        public pxr.SdfPathAncestorsRange.iterator end();
        protected virtual void Finalize();
        public pxr.SdfPath GetPath();
        public class iterator : System.IDisposable
        {
            protected bool swigCMemOwn;
            public iterator() {}
            public iterator(pxr.SdfPath path) {}
            public pxr.SdfPath __deref__();
            public pxr.SdfPath __ref__();
            public pxr.SdfPath AppendChild(pxr.TfToken childName);
            public pxr.SdfPath AppendElementString(string element);
            public pxr.SdfPath AppendElementToken(pxr.TfToken elementTok);
            public pxr.SdfPath AppendExpression();
            public pxr.SdfPath AppendMapper(pxr.SdfPath targetPath);
            public pxr.SdfPath AppendMapperArg(pxr.TfToken argName);
            public pxr.SdfPath AppendPath(pxr.SdfPath newSuffix);
            public pxr.SdfPath AppendProperty(pxr.TfToken propName);
            public pxr.SdfPath AppendRelationalAttribute(pxr.TfToken attrName);
            public pxr.SdfPath AppendTarget(pxr.SdfPath targetPath);
            public pxr.SdfPath AppendVariantSelection(string variantSet, string variant);
            public bool ContainsPrimVariantSelection();
            public bool ContainsPropertyElements();
            public bool ContainsTargetPath();
            public virtual void Dispose();
            protected virtual void Finalize();
            public pxr.SdfPath GetAbsoluteRootOrPrimPath();
            public void GetAllTargetPathsRecursively(pxr.SdfPathVector result);
            public pxr.SdfPathAncestorsRange GetAncestorsRange();
            public pxr.SdfPath GetCommonPrefix(pxr.SdfPath path);
            public string GetElementString();
            public pxr.TfToken GetElementToken();
            public System.UInt32 GetHash();
            public string GetName();
            public pxr.TfToken GetNameToken();
            public pxr.SdfPath GetParentPath();
            public System.UInt32 GetPathElementCount();
            public pxr.SdfPathVector GetPrefixes();
            public void GetPrefixes(pxr.SdfPathVector prefixes);
            public pxr.SdfPath GetPrimOrPrimVariantSelectionPath();
            public pxr.SdfPath GetPrimPath();
            public string GetString();
            public pxr.SdfPath GetTargetPath();
            public string GetText();
            public pxr.TfToken GetToken();
            public pxr.SdfPathStringPair GetVariantSelection();
            public bool HasPrefix(pxr.SdfPath prefix);
            public bool IsAbsolutePath();
            public bool IsAbsoluteRootOrPrimPath();
            public bool IsAbsoluteRootPath();
            public bool IsEmpty();
            public bool IsExpressionPath();
            public bool IsMapperArgPath();
            public bool IsMapperPath();
            public bool IsNamespacedPropertyPath();
            public bool IsPrimOrPrimVariantSelectionPath();
            public bool IsPrimPath();
            public bool IsPrimPropertyPath();
            public bool IsPrimVariantSelectionPath();
            public bool IsPropertyPath();
            public bool IsRelationalAttributePath();
            public bool IsRootPrimPath();
            public bool IsTargetPath();
            public pxr.SdfPath MakeAbsolutePath(pxr.SdfPath anchor);
            public pxr.SdfPath MakeRelativePath(pxr.SdfPath anchor);
            public pxr.SdfPathPair RemoveCommonSuffix(pxr.SdfPath otherPath);
            public pxr.SdfPathPair RemoveCommonSuffix(pxr.SdfPath otherPath, bool stopAtRootPrim);
            public pxr.SdfPath ReplaceName(pxr.TfToken newName);
            public pxr.SdfPath ReplacePrefix(pxr.SdfPath oldPrefix, pxr.SdfPath newPrefix);
            public pxr.SdfPath ReplacePrefix(pxr.SdfPath oldPrefix, pxr.SdfPath newPrefix, bool fixTargetPaths);
            public pxr.SdfPath ReplaceTargetPath(pxr.SdfPath newTargetPath);
            public pxr.SdfPath StripAllVariantSelections();
        }
    }

    public class SdfPathListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfPathListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfPathListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfPathListOp Create();
        public static pxr.SdfPathListOp Create(pxr.SdfPathVector prependedItems);
        public static pxr.SdfPathListOp Create(pxr.SdfPathVector prependedItems, pxr.SdfPathVector appendedItems);
        public static pxr.SdfPathListOp Create(pxr.SdfPathVector prependedItems, pxr.SdfPathVector appendedItems, pxr.SdfPathVector deletedItems);
        public static pxr.SdfPathListOp CreateExplicit();
        public static pxr.SdfPathListOp CreateExplicit(pxr.SdfPathVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPathVector GetAddedItems();
        public pxr.SdfPathVector GetAppendedItems();
        public pxr.SdfPathVector GetDeletedItems();
        public pxr.SdfPathVector GetExplicitItems();
        public pxr.SdfPathVector GetItems(pxr.SdfListOpType type);
        public pxr.SdfPathVector GetOrderedItems();
        public pxr.SdfPathVector GetPrependedItems();
        public bool HasItem(pxr.SdfPath item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.SdfPathVector newItems);
        public void SetAddedItems(pxr.SdfPathVector items);
        public void SetAppendedItems(pxr.SdfPathVector items);
        public void SetDeletedItems(pxr.SdfPathVector items);
        public void SetExplicitItems(pxr.SdfPathVector items);
        public void SetItems(pxr.SdfPathVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.SdfPathVector items);
        public void SetPrependedItems(pxr.SdfPathVector items);
        public void Swap(pxr.SdfPathListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfPathListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfPathListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfPathListOp this[int index] { get; set; }
        public SdfPathListOpVector() {}
        public SdfPathListOpVector(pxr.SdfPathListOpVector other) {}
        public SdfPathListOpVector(System.Collections.ICollection c) {}
        public SdfPathListOpVector(int capacity) {}
        public void Add(pxr.SdfPathListOp x);
        public void AddRange(pxr.SdfPathListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfPathListOp[] array);
        public void CopyTo(pxr.SdfPathListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfPathListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPathListOpVector.SdfPathListOpVectorEnumerator GetEnumerator();
        public pxr.SdfPathListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfPathListOp x);
        public void InsertRange(int index, pxr.SdfPathListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfPathListOpVector Repeat(pxr.SdfPathListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfPathListOpVector values);
        public sealed class SdfPathListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfPathListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfPathListOp Current { get; }
            public SdfPathListOpVectorEnumerator(pxr.SdfPathListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfPathPair : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.SdfPath first { get; set; }
        public pxr.SdfPath second { get; set; }
        public SdfPathPair() {}
        public SdfPathPair(pxr.SdfPathPair p) {}
        public SdfPathPair(pxr.SdfPath t, pxr.SdfPath u) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class SdfPathStringPair : System.IDisposable
    {
        protected bool swigCMemOwn;
        public string first { get; set; }
        public string second { get; set; }
        public SdfPathStringPair() {}
        public SdfPathStringPair(pxr.SdfPathStringPair p) {}
        public SdfPathStringPair(string t, string u) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfPathVector : System.Collections.Generic.IEnumerable<pxr.SdfPath>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfPath this[int index] { get; set; }
        public SdfPathVector() {}
        public SdfPathVector(pxr.SdfPathVector other) {}
        public SdfPathVector(System.Collections.ICollection c) {}
        public SdfPathVector(int capacity) {}
        public void Add(pxr.SdfPath x);
        public void AddRange(pxr.SdfPathVector values);
        public void Clear();
        public void CopyTo(pxr.SdfPath[] array);
        public void CopyTo(pxr.SdfPath[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfPath[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPathVector.SdfPathVectorEnumerator GetEnumerator();
        public pxr.SdfPathVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfPath x);
        public void InsertRange(int index, pxr.SdfPathVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfPathVector Repeat(pxr.SdfPath value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfPathVector values);
        public sealed class SdfPathVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfPath>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfPath Current { get; }
            public SdfPathVectorEnumerator(pxr.SdfPathVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfPayload : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfPayload() {}
        public SdfPayload(string assetPath) {}
        public SdfPayload(string assetPath, pxr.SdfPath primPath) {}
        public SdfPayload(string assetPath, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public string GetAssetPath();
        public pxr.SdfLayerOffset GetLayerOffset();
        public pxr.SdfPath GetPrimPath();
        public void SetAssetPath(string assetPath);
        public void SetLayerOffset(pxr.SdfLayerOffset layerOffset);
        public void SetPrimPath(pxr.SdfPath primPath);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfPayloadVector : System.Collections.Generic.IEnumerable<pxr.SdfPayload>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfPayload this[int index] { get; set; }
        public SdfPayloadVector() {}
        public SdfPayloadVector(pxr.SdfPayloadVector other) {}
        public SdfPayloadVector(System.Collections.ICollection c) {}
        public SdfPayloadVector(int capacity) {}
        public void Add(pxr.SdfPayload x);
        public void AddRange(pxr.SdfPayloadVector values);
        public void Clear();
        public void CopyTo(pxr.SdfPayload[] array);
        public void CopyTo(pxr.SdfPayload[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfPayload[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPayloadVector.SdfPayloadVectorEnumerator GetEnumerator();
        public pxr.SdfPayloadVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfPayload x);
        public void InsertRange(int index, pxr.SdfPayloadVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfPayloadVector Repeat(pxr.SdfPayload value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfPayloadVector values);
        public sealed class SdfPayloadVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfPayload>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfPayload Current { get; }
            public SdfPayloadVectorEnumerator(pxr.SdfPayloadVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public enum SdfPermission
    {
        public const pxr.SdfPermission SdfNumPermissions = 2;
        public const pxr.SdfPermission SdfPermissionPrivate = 1;
        public const pxr.SdfPermission SdfPermissionPublic = 0;
        public int value__;
    }

    public class SdfPrimSpec : pxr.SdfSpec
    {
        public void ApplyNameChildrenOrder(pxr.TfTokenVector vec);
        public void ApplyPropertyOrder(pxr.TfTokenVector vec);
        public bool CanSetName(string newName, pxr.SWIGTYPE_p_std__string whyNot);
        public void ClearActive();
        public void ClearInheritPathList();
        public void ClearInstanceable();
        public void ClearKind();
        public void ClearPayloadList();
        public void ClearReferenceList();
        public void ClearRelocates();
        public void ClearSpecializesList();
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool GetActive();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetAssetInfo();
        public pxr.SdfAttributeSpecHandle GetAttributeAtPath(pxr.SdfPath path);
        public string GetComment();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetCustomData();
        public string GetDocumentation();
        public bool GetHidden();
        public pxr.SWIGTYPE_p_SdfInheritsProxy GetInheritPathList();
        public bool GetInstanceable();
        public pxr.TfToken GetKind();
        public string GetName();
        public pxr.SWIGTYPE_p_SdfPrimSpecView GetNameChildren();
        public pxr.SdfPrimSpecHandle GetNameParent();
        public pxr.SdfPrimSpecHandle GetNameRoot();
        public pxr.TfToken GetNameToken();
        public pxr.SdfSpecHandle GetObjectAtPath(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_SdfPayloadsProxy GetPayloadList();
        public pxr.SdfPermission GetPermission();
        public string GetPrefix();
        public pxr.VtDictionary GetPrefixSubstitutions();
        public pxr.SdfPrimSpecHandle GetPrimAtPath(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_SdfPropertySpecView GetProperties();
        public pxr.SdfPropertySpecHandle GetPropertyAtPath(pxr.SdfPath path);
        public pxr.SdfPrimSpecHandle GetRealNameParent();
        public pxr.SWIGTYPE_p_SdfReferencesProxy GetReferenceList();
        public pxr.SdfRelationshipSpecHandle GetRelationshipAtPath(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_SdfRelocatesMapProxy GetRelocates();
        public pxr.SWIGTYPE_p_SdfSpecializesProxy GetSpecializesList();
        public pxr.SdfSpecifier GetSpecifier();
        public string GetSuffix();
        public pxr.VtDictionary GetSuffixSubstitutions();
        public string GetSymmetricPeer();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetSymmetryArguments();
        public pxr.TfToken GetSymmetryFunction();
        public pxr.TfToken GetTypeName();
        public pxr.StdStringVector GetVariantNames(string name);
        public pxr.SWIGTYPE_p_SdfVariantSelectionProxy GetVariantSelections();
        public pxr.SWIGTYPE_p_SdfVariantSetNamesProxy GetVariantSetNameList();
        public bool HasActive();
        public bool HasInheritPaths();
        public bool HasInstanceable();
        public bool HasKind();
        public bool HasNameChildrenOrder();
        public bool HasPayloads();
        public bool HasPropertyOrder();
        public bool HasReferences();
        public bool HasRelocates();
        public bool HasSpecializes();
        public bool HasVariantSetNames();
        public void InsertInNameChildrenOrder(pxr.TfToken name);
        public void InsertInNameChildrenOrder(pxr.TfToken name, int index);
        public void InsertInPropertyOrder(pxr.TfToken name);
        public void InsertInPropertyOrder(pxr.TfToken name, int index);
        public bool InsertNameChild(pxr.SdfPrimSpecHandle child);
        public bool InsertNameChild(pxr.SdfPrimSpecHandle child, int index);
        public bool InsertProperty(pxr.SdfPropertySpecHandle property);
        public bool InsertProperty(pxr.SdfPropertySpecHandle property, int index);
        public static bool IsValidName(string name);
        public static pxr.SdfPrimSpecHandle New(pxr.SdfLayerHandle parentLayer, string name, pxr.SdfSpecifier spec);
        public static pxr.SdfPrimSpecHandle New(pxr.SdfPrimSpecHandle parentPrim, string name, pxr.SdfSpecifier spec);
        public static pxr.SdfPrimSpecHandle New(pxr.SdfLayerHandle parentLayer, string name, pxr.SdfSpecifier spec, string typeName);
        public static pxr.SdfPrimSpecHandle New(pxr.SdfPrimSpecHandle parentPrim, string name, pxr.SdfSpecifier spec, string typeName);
        public void RemoveFromNameChildrenOrder(pxr.TfToken name);
        public void RemoveFromNameChildrenOrderByIndex(int index);
        public void RemoveFromPropertyOrder(pxr.TfToken name);
        public void RemoveFromPropertyOrderByIndex(int index);
        public bool RemoveNameChild(pxr.SdfPrimSpecHandle child);
        public void RemoveProperty(pxr.SdfPropertySpecHandle property);
        public void RemoveVariantSet(string name);
        public void SetActive(bool value);
        public void SetAssetInfo(string name, pxr.VtValue value);
        public void SetComment(string value);
        public void SetCustomData(string name, pxr.VtValue value);
        public void SetDocumentation(string value);
        public void SetHidden(bool value);
        public void SetInstanceable(bool instanceable);
        public void SetKind(pxr.TfToken value);
        public bool SetName(string newName);
        public bool SetName(string newName, bool validate);
        public void SetNameChildren(pxr.SdfPrimSpecHandleVector arg0);
        public void SetNameChildrenOrder(pxr.TfTokenVector names);
        public void SetPermission(pxr.SdfPermission value);
        public void SetPrefix(string value);
        public void SetPrefixSubstitutions(pxr.VtDictionary prefixSubstitutions);
        public void SetProperties(pxr.SdfPropertySpecHandleVector arg0);
        public void SetPropertyOrder(pxr.TfTokenVector names);
        public void SetRelocates(pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t newMap);
        public void SetSpecifier(pxr.SdfSpecifier value);
        public void SetSuffix(string value);
        public void SetSuffixSubstitutions(pxr.VtDictionary suffixSubstitutions);
        public void SetSymmetricPeer(string peerName);
        public void SetSymmetryArgument(string name, pxr.VtValue value);
        public void SetSymmetryFunction(pxr.TfToken functionName);
        public void SetTypeName(string value);
        public void SetVariantSelection(string variantSetName, string variantName);
    }

    public class SdfPrimSpecHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfPrimSpecHandle() {}
        public SdfPrimSpecHandle(pxr.SdfPrimSpec spec) {}
        public SdfPrimSpecHandle(pxr.SdfPrimSpecHandle handle) {}
        public pxr.SdfPrimSpec __deref__();
        public void ApplyNameChildrenOrder(pxr.TfTokenVector vec);
        public void ApplyPropertyOrder(pxr.TfTokenVector vec);
        public bool CanSetName(string newName, pxr.SWIGTYPE_p_std__string whyNot);
        public void ClearActive();
        public bool ClearField(pxr.TfToken name);
        public void ClearInfo(pxr.TfToken key);
        public void ClearInheritPathList();
        public void ClearInstanceable();
        public void ClearKind();
        public void ClearPayloadList();
        public void ClearReferenceList();
        public void ClearRelocates();
        public void ClearSpecializesList();
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool GetActive();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetAssetInfo();
        public pxr.SdfAttributeSpecHandle GetAttributeAtPath(pxr.SdfPath path);
        public string GetComment();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetCustomData();
        public string GetDocumentation();
        public pxr.VtValue GetFallbackForInfo(pxr.TfToken key);
        public pxr.VtValue GetField(pxr.TfToken name);
        public bool GetHidden();
        public pxr.VtValue GetInfo(pxr.TfToken key);
        public pxr.SWIGTYPE_p_SdfInheritsProxy GetInheritPathList();
        public bool GetInstanceable();
        public pxr.TfToken GetKind();
        public pxr.SdfLayerHandle GetLayer();
        public pxr.TfToken GetMetaDataDisplayGroup(pxr.TfToken key);
        public pxr.TfTokenVector GetMetaDataInfoKeys();
        public string GetName();
        public pxr.SWIGTYPE_p_SdfPrimSpecView GetNameChildren();
        public pxr.SdfPrimSpecHandle GetNameParent();
        public pxr.SdfPrimSpecHandle GetNameRoot();
        public pxr.TfToken GetNameToken();
        public pxr.SdfSpecHandle GetObjectAtPath(pxr.SdfPath path);
        public pxr.SdfPath GetPath();
        public pxr.SWIGTYPE_p_SdfPayloadsProxy GetPayloadList();
        public pxr.SdfPermission GetPermission();
        public string GetPrefix();
        public pxr.VtDictionary GetPrefixSubstitutions();
        public pxr.SdfPrimSpecHandle GetPrimAtPath(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_SdfPropertySpecView GetProperties();
        public pxr.SdfPropertySpecHandle GetPropertyAtPath(pxr.SdfPath path);
        public pxr.SdfPrimSpecHandle GetRealNameParent();
        public pxr.SWIGTYPE_p_SdfReferencesProxy GetReferenceList();
        public pxr.SdfRelationshipSpecHandle GetRelationshipAtPath(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_SdfRelocatesMapProxy GetRelocates();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public pxr.SWIGTYPE_p_SdfSpecializesProxy GetSpecializesList();
        public pxr.SdfSpecifier GetSpecifier();
        public pxr.SdfSpecType GetSpecType();
        public string GetSuffix();
        public pxr.VtDictionary GetSuffixSubstitutions();
        public string GetSymmetricPeer();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetSymmetryArguments();
        public pxr.TfToken GetSymmetryFunction();
        public pxr.TfType GetTypeForInfo(pxr.TfToken key);
        public pxr.TfToken GetTypeName();
        public pxr.StdStringVector GetVariantNames(string name);
        public pxr.SWIGTYPE_p_SdfVariantSelectionProxy GetVariantSelections();
        public pxr.SWIGTYPE_p_SdfVariantSetNamesProxy GetVariantSetNameList();
        public bool HasActive();
        public bool HasField(pxr.TfToken name);
        public bool HasInfo(pxr.TfToken key);
        public bool HasInheritPaths();
        public bool HasInstanceable();
        public bool HasKind();
        public bool HasNameChildrenOrder();
        public bool HasPayloads();
        public bool HasPropertyOrder();
        public bool HasReferences();
        public bool HasRelocates();
        public bool HasSpecializes();
        public bool HasVariantSetNames();
        public void InsertInNameChildrenOrder(pxr.TfToken name);
        public void InsertInNameChildrenOrder(pxr.TfToken name, int index);
        public void InsertInPropertyOrder(pxr.TfToken name);
        public void InsertInPropertyOrder(pxr.TfToken name, int index);
        public bool InsertNameChild(pxr.SdfPrimSpecHandle child);
        public bool InsertNameChild(pxr.SdfPrimSpecHandle child, int index);
        public bool InsertProperty(pxr.SdfPropertySpecHandle property);
        public bool InsertProperty(pxr.SdfPropertySpecHandle property, int index);
        public bool IsDormant();
        public bool IsInert();
        public bool IsInert(bool ignoreChildren);
        public bool IsValidName(string name);
        public pxr.TfTokenVector ListFields();
        public pxr.TfTokenVector ListInfoKeys();
        public pxr.SdfPrimSpecHandle New(pxr.SdfLayerHandle parentLayer, string name, pxr.SdfSpecifier spec);
        public pxr.SdfPrimSpecHandle New(pxr.SdfPrimSpecHandle parentPrim, string name, pxr.SdfSpecifier spec);
        public pxr.SdfPrimSpecHandle New(pxr.SdfLayerHandle parentLayer, string name, pxr.SdfSpecifier spec, string typeName);
        public pxr.SdfPrimSpecHandle New(pxr.SdfPrimSpecHandle parentPrim, string name, pxr.SdfSpecifier spec, string typeName);
        public bool PermissionToEdit();
        public void RemoveFromNameChildrenOrder(pxr.TfToken name);
        public void RemoveFromNameChildrenOrderByIndex(int index);
        public void RemoveFromPropertyOrder(pxr.TfToken name);
        public void RemoveFromPropertyOrderByIndex(int index);
        public bool RemoveNameChild(pxr.SdfPrimSpecHandle child);
        public void RemoveProperty(pxr.SdfPropertySpecHandle property);
        public void RemoveVariantSet(string name);
        public void SetActive(bool value);
        public void SetAssetInfo(string name, pxr.VtValue value);
        public void SetComment(string value);
        public void SetCustomData(string name, pxr.VtValue value);
        public void SetDocumentation(string value);
        public bool SetField(pxr.TfToken name, pxr.VtValue value);
        public void SetHidden(bool value);
        public void SetInfo(pxr.TfToken key, pxr.VtValue value);
        public void SetInfoDictionaryValue(pxr.TfToken dictionaryKey, pxr.TfToken entryKey, pxr.VtValue value);
        public void SetInstanceable(bool instanceable);
        public void SetKind(pxr.TfToken value);
        public bool SetName(string newName);
        public bool SetName(string newName, bool validate);
        public void SetNameChildren(pxr.SdfPrimSpecHandleVector arg0);
        public void SetNameChildrenOrder(pxr.TfTokenVector names);
        public void SetPermission(pxr.SdfPermission value);
        public void SetPrefix(string value);
        public void SetPrefixSubstitutions(pxr.VtDictionary prefixSubstitutions);
        public void SetProperties(pxr.SdfPropertySpecHandleVector arg0);
        public void SetPropertyOrder(pxr.TfTokenVector names);
        public void SetRelocates(pxr.SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t newMap);
        public void SetSpecifier(pxr.SdfSpecifier value);
        public void SetSuffix(string value);
        public void SetSuffixSubstitutions(pxr.VtDictionary suffixSubstitutions);
        public void SetSymmetricPeer(string peerName);
        public void SetSymmetryArgument(string name, pxr.VtValue value);
        public void SetSymmetryFunction(pxr.TfToken functionName);
        public void SetTypeName(string value);
        public void SetVariantSelection(string variantSetName, string variantName);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0, System.UInt32 indent);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfPrimSpecHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfPrimSpecHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfPrimSpecHandle this[int index] { get; set; }
        public SdfPrimSpecHandleVector() {}
        public SdfPrimSpecHandleVector(pxr.SdfPrimSpecHandleVector other) {}
        public SdfPrimSpecHandleVector(System.Collections.ICollection c) {}
        public SdfPrimSpecHandleVector(int capacity) {}
        public void Add(pxr.SdfPrimSpecHandle x);
        public void AddRange(pxr.SdfPrimSpecHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfPrimSpecHandle[] array);
        public void CopyTo(pxr.SdfPrimSpecHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfPrimSpecHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPrimSpecHandleVector.SdfPrimSpecHandleVectorEnumerator GetEnumerator();
        public pxr.SdfPrimSpecHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfPrimSpecHandle x);
        public void InsertRange(int index, pxr.SdfPrimSpecHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfPrimSpecHandleVector Repeat(pxr.SdfPrimSpecHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfPrimSpecHandleVector values);
        public sealed class SdfPrimSpecHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfPrimSpecHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfPrimSpecHandle Current { get; }
            public SdfPrimSpecHandleVectorEnumerator(pxr.SdfPrimSpecHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfPropertySpec : pxr.SdfSpec
    {
        public bool CanSetName(string newName, pxr.SWIGTYPE_p_std__string whyNot);
        public void ClearDefaultValue();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetAssetInfo();
        public string GetComment();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetCustomData();
        public pxr.VtValue GetDefaultValue();
        public string GetDisplayGroup();
        public string GetDisplayName();
        public string GetDocumentation();
        public bool GetHidden();
        public string GetName();
        public pxr.TfToken GetNameToken();
        public pxr.SdfSpecHandle GetOwner();
        public pxr.SdfPermission GetPermission();
        public string GetPrefix();
        public string GetSuffix();
        public string GetSymmetricPeer();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetSymmetryArguments();
        public pxr.TfToken GetSymmetryFunction();
        public pxr.SWIGTYPE_p_std__mapT_double_VtValue_std__lessT_double_t_t GetTimeSampleMap();
        public pxr.SdfValueTypeName GetTypeName();
        public pxr.TfType GetValueType();
        public pxr.SdfVariability GetVariability();
        public bool HasDefaultValue();
        public bool HasOnlyRequiredFields();
        public bool IsCustom();
        public static bool IsValidName(string name);
        public void SetAssetInfo(string name, pxr.VtValue value);
        public void SetComment(string value);
        public void SetCustom(bool custom);
        public void SetCustomData(string name, pxr.VtValue value);
        public bool SetDefaultValue(pxr.VtValue defaultValue);
        public void SetDisplayGroup(string value);
        public void SetDisplayName(string value);
        public void SetDocumentation(string value);
        public void SetHidden(bool value);
        public bool SetName(string newName);
        public bool SetName(string newName, bool validate);
        public void SetPermission(pxr.SdfPermission value);
        public void SetPrefix(string value);
        public void SetSuffix(string value);
        public void SetSymmetricPeer(string peerName);
        public void SetSymmetryArgument(string name, pxr.VtValue value);
        public void SetSymmetryFunction(pxr.TfToken functionName);
    }

    public class SdfPropertySpecHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfPropertySpecHandle() {}
        public SdfPropertySpecHandle(pxr.SdfPropertySpec spec) {}
        public SdfPropertySpecHandle(pxr.SdfPropertySpecHandle handle) {}
        public pxr.SdfPropertySpec __deref__();
        public bool CanSetName(string newName, pxr.SWIGTYPE_p_std__string whyNot);
        public void ClearDefaultValue();
        public bool ClearField(pxr.TfToken name);
        public void ClearInfo(pxr.TfToken key);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetAssetInfo();
        public string GetComment();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetCustomData();
        public pxr.VtValue GetDefaultValue();
        public string GetDisplayGroup();
        public string GetDisplayName();
        public string GetDocumentation();
        public pxr.VtValue GetFallbackForInfo(pxr.TfToken key);
        public pxr.VtValue GetField(pxr.TfToken name);
        public bool GetHidden();
        public pxr.VtValue GetInfo(pxr.TfToken key);
        public pxr.SdfLayerHandle GetLayer();
        public pxr.TfToken GetMetaDataDisplayGroup(pxr.TfToken key);
        public pxr.TfTokenVector GetMetaDataInfoKeys();
        public string GetName();
        public pxr.TfToken GetNameToken();
        public pxr.SdfSpecHandle GetOwner();
        public pxr.SdfPath GetPath();
        public pxr.SdfPermission GetPermission();
        public string GetPrefix();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public pxr.SdfSpecType GetSpecType();
        public string GetSuffix();
        public string GetSymmetricPeer();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetSymmetryArguments();
        public pxr.TfToken GetSymmetryFunction();
        public pxr.SWIGTYPE_p_std__mapT_double_VtValue_std__lessT_double_t_t GetTimeSampleMap();
        public pxr.TfType GetTypeForInfo(pxr.TfToken key);
        public pxr.SdfValueTypeName GetTypeName();
        public pxr.TfType GetValueType();
        public pxr.SdfVariability GetVariability();
        public bool HasDefaultValue();
        public bool HasField(pxr.TfToken name);
        public bool HasInfo(pxr.TfToken key);
        public bool HasOnlyRequiredFields();
        public bool IsCustom();
        public bool IsDormant();
        public bool IsInert();
        public bool IsInert(bool ignoreChildren);
        public bool IsValidName(string name);
        public pxr.TfTokenVector ListFields();
        public pxr.TfTokenVector ListInfoKeys();
        public bool PermissionToEdit();
        public void SetAssetInfo(string name, pxr.VtValue value);
        public void SetComment(string value);
        public void SetCustom(bool custom);
        public void SetCustomData(string name, pxr.VtValue value);
        public bool SetDefaultValue(pxr.VtValue defaultValue);
        public void SetDisplayGroup(string value);
        public void SetDisplayName(string value);
        public void SetDocumentation(string value);
        public bool SetField(pxr.TfToken name, pxr.VtValue value);
        public void SetHidden(bool value);
        public void SetInfo(pxr.TfToken key, pxr.VtValue value);
        public void SetInfoDictionaryValue(pxr.TfToken dictionaryKey, pxr.TfToken entryKey, pxr.VtValue value);
        public bool SetName(string newName);
        public bool SetName(string newName, bool validate);
        public void SetPermission(pxr.SdfPermission value);
        public void SetPrefix(string value);
        public void SetSuffix(string value);
        public void SetSymmetricPeer(string peerName);
        public void SetSymmetryArgument(string name, pxr.VtValue value);
        public void SetSymmetryFunction(pxr.TfToken functionName);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0, System.UInt32 indent);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfPropertySpecHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfPropertySpecHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfPropertySpecHandle this[int index] { get; set; }
        public SdfPropertySpecHandleVector() {}
        public SdfPropertySpecHandleVector(pxr.SdfPropertySpecHandleVector other) {}
        public SdfPropertySpecHandleVector(System.Collections.ICollection c) {}
        public SdfPropertySpecHandleVector(int capacity) {}
        public void Add(pxr.SdfPropertySpecHandle x);
        public void AddRange(pxr.SdfPropertySpecHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfPropertySpecHandle[] array);
        public void CopyTo(pxr.SdfPropertySpecHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfPropertySpecHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPropertySpecHandleVector.SdfPropertySpecHandleVectorEnumerator GetEnumerator();
        public pxr.SdfPropertySpecHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfPropertySpecHandle x);
        public void InsertRange(int index, pxr.SdfPropertySpecHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfPropertySpecHandleVector Repeat(pxr.SdfPropertySpecHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfPropertySpecHandleVector values);
        public sealed class SdfPropertySpecHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfPropertySpecHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfPropertySpecHandle Current { get; }
            public SdfPropertySpecHandleVectorEnumerator(pxr.SdfPropertySpecHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfReference : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfReference() {}
        public SdfReference(string assetPath) {}
        public SdfReference(string assetPath, pxr.SdfPath primPath) {}
        public SdfReference(string assetPath, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset) {}
        public SdfReference(string assetPath, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset, pxr.VtDictionary customData) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public string GetAssetPath();
        public pxr.VtDictionary GetCustomData();
        public pxr.SdfLayerOffset GetLayerOffset();
        public pxr.SdfPath GetPrimPath();
        public bool IsInternal();
        public void SetAssetPath(string assetPath);
        public void SetCustomData(pxr.VtDictionary customData);
        public void SetCustomData(string name, pxr.VtValue value);
        public void SetLayerOffset(pxr.SdfLayerOffset layerOffset);
        public void SetPrimPath(pxr.SdfPath primPath);
        public void SwapCustomData(pxr.VtDictionary customData);
        public class IdentityEqual : System.IDisposable
        {
            protected bool swigCMemOwn;
            public IdentityEqual() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
        public class IdentityLessThan : System.IDisposable
        {
            protected bool swigCMemOwn;
            public IdentityLessThan() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class SdfReferenceListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfReferenceListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfReferenceListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfReferenceListOp Create();
        public static pxr.SdfReferenceListOp Create(pxr.StdReferenceVector prependedItems);
        public static pxr.SdfReferenceListOp Create(pxr.StdReferenceVector prependedItems, pxr.StdReferenceVector appendedItems);
        public static pxr.SdfReferenceListOp Create(pxr.StdReferenceVector prependedItems, pxr.StdReferenceVector appendedItems, pxr.StdReferenceVector deletedItems);
        public static pxr.SdfReferenceListOp CreateExplicit();
        public static pxr.SdfReferenceListOp CreateExplicit(pxr.StdReferenceVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdReferenceVector GetAddedItems();
        public pxr.StdReferenceVector GetAppendedItems();
        public pxr.StdReferenceVector GetDeletedItems();
        public pxr.StdReferenceVector GetExplicitItems();
        public pxr.StdReferenceVector GetItems(pxr.SdfListOpType type);
        public pxr.StdReferenceVector GetOrderedItems();
        public pxr.StdReferenceVector GetPrependedItems();
        public bool HasItem(pxr.SdfReference item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.StdReferenceVector newItems);
        public void SetAddedItems(pxr.StdReferenceVector items);
        public void SetAppendedItems(pxr.StdReferenceVector items);
        public void SetDeletedItems(pxr.StdReferenceVector items);
        public void SetExplicitItems(pxr.StdReferenceVector items);
        public void SetItems(pxr.StdReferenceVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.StdReferenceVector items);
        public void SetPrependedItems(pxr.StdReferenceVector items);
        public void Swap(pxr.SdfReferenceListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfReferenceListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfReferenceListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfReferenceListOp this[int index] { get; set; }
        public SdfReferenceListOpVector() {}
        public SdfReferenceListOpVector(pxr.SdfReferenceListOpVector other) {}
        public SdfReferenceListOpVector(System.Collections.ICollection c) {}
        public SdfReferenceListOpVector(int capacity) {}
        public void Add(pxr.SdfReferenceListOp x);
        public void AddRange(pxr.SdfReferenceListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfReferenceListOp[] array);
        public void CopyTo(pxr.SdfReferenceListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfReferenceListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfReferenceListOpVector.SdfReferenceListOpVectorEnumerator GetEnumerator();
        public pxr.SdfReferenceListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfReferenceListOp x);
        public void InsertRange(int index, pxr.SdfReferenceListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfReferenceListOpVector Repeat(pxr.SdfReferenceListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfReferenceListOpVector values);
        public sealed class SdfReferenceListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfReferenceListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfReferenceListOp Current { get; }
            public SdfReferenceListOpVectorEnumerator(pxr.SdfReferenceListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfRelationshipSpec : pxr.SdfPropertySpec
    {
        public void ClearTargetPathList();
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool GetNoLoadHint();
        public pxr.SWIGTYPE_p_SdfTargetsProxy GetTargetPathList();
        public bool HasTargetPathList();
        public static pxr.SdfRelationshipSpecHandle New(pxr.SdfPrimSpecHandle owner, string name);
        public static pxr.SdfRelationshipSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, bool custom);
        public static pxr.SdfRelationshipSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, bool custom, pxr.SdfVariability variability);
        public void RemoveTargetPath(pxr.SdfPath path);
        public void RemoveTargetPath(pxr.SdfPath path, bool preserveTargetOrder);
        public void ReplaceTargetPath(pxr.SdfPath oldPath, pxr.SdfPath newPath);
        public void SetNoLoadHint(bool noload);
    }

    public class SdfRelationshipSpecHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfRelationshipSpecHandle() {}
        public SdfRelationshipSpecHandle(pxr.SdfRelationshipSpec spec) {}
        public SdfRelationshipSpecHandle(pxr.SdfRelationshipSpecHandle handle) {}
        public pxr.SdfRelationshipSpec __deref__();
        public bool CanSetName(string newName, pxr.SWIGTYPE_p_std__string whyNot);
        public void ClearDefaultValue();
        public bool ClearField(pxr.TfToken name);
        public void ClearInfo(pxr.TfToken key);
        public void ClearTargetPathList();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetAssetInfo();
        public string GetComment();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetCustomData();
        public pxr.VtValue GetDefaultValue();
        public string GetDisplayGroup();
        public string GetDisplayName();
        public string GetDocumentation();
        public pxr.VtValue GetFallbackForInfo(pxr.TfToken key);
        public pxr.VtValue GetField(pxr.TfToken name);
        public bool GetHidden();
        public pxr.VtValue GetInfo(pxr.TfToken key);
        public pxr.SdfLayerHandle GetLayer();
        public pxr.TfToken GetMetaDataDisplayGroup(pxr.TfToken key);
        public pxr.TfTokenVector GetMetaDataInfoKeys();
        public string GetName();
        public pxr.TfToken GetNameToken();
        public bool GetNoLoadHint();
        public pxr.SdfSpecHandle GetOwner();
        public pxr.SdfPath GetPath();
        public pxr.SdfPermission GetPermission();
        public string GetPrefix();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public pxr.SdfSpecType GetSpecType();
        public string GetSuffix();
        public string GetSymmetricPeer();
        public pxr.SWIGTYPE_p_SdfDictionaryProxy GetSymmetryArguments();
        public pxr.TfToken GetSymmetryFunction();
        public pxr.SWIGTYPE_p_SdfTargetsProxy GetTargetPathList();
        public pxr.SWIGTYPE_p_std__mapT_double_VtValue_std__lessT_double_t_t GetTimeSampleMap();
        public pxr.TfType GetTypeForInfo(pxr.TfToken key);
        public pxr.SdfValueTypeName GetTypeName();
        public pxr.TfType GetValueType();
        public pxr.SdfVariability GetVariability();
        public bool HasDefaultValue();
        public bool HasField(pxr.TfToken name);
        public bool HasInfo(pxr.TfToken key);
        public bool HasOnlyRequiredFields();
        public bool HasTargetPathList();
        public bool IsCustom();
        public bool IsDormant();
        public bool IsInert();
        public bool IsInert(bool ignoreChildren);
        public bool IsValidName(string name);
        public pxr.TfTokenVector ListFields();
        public pxr.TfTokenVector ListInfoKeys();
        public pxr.SdfRelationshipSpecHandle New(pxr.SdfPrimSpecHandle owner, string name);
        public pxr.SdfRelationshipSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, bool custom);
        public pxr.SdfRelationshipSpecHandle New(pxr.SdfPrimSpecHandle owner, string name, bool custom, pxr.SdfVariability variability);
        public bool PermissionToEdit();
        public void RemoveTargetPath(pxr.SdfPath path);
        public void RemoveTargetPath(pxr.SdfPath path, bool preserveTargetOrder);
        public void ReplaceTargetPath(pxr.SdfPath oldPath, pxr.SdfPath newPath);
        public void SetAssetInfo(string name, pxr.VtValue value);
        public void SetComment(string value);
        public void SetCustom(bool custom);
        public void SetCustomData(string name, pxr.VtValue value);
        public bool SetDefaultValue(pxr.VtValue defaultValue);
        public void SetDisplayGroup(string value);
        public void SetDisplayName(string value);
        public void SetDocumentation(string value);
        public bool SetField(pxr.TfToken name, pxr.VtValue value);
        public void SetHidden(bool value);
        public void SetInfo(pxr.TfToken key, pxr.VtValue value);
        public void SetInfoDictionaryValue(pxr.TfToken dictionaryKey, pxr.TfToken entryKey, pxr.VtValue value);
        public bool SetName(string newName);
        public bool SetName(string newName, bool validate);
        public void SetNoLoadHint(bool noload);
        public void SetPermission(pxr.SdfPermission value);
        public void SetPrefix(string value);
        public void SetSuffix(string value);
        public void SetSymmetricPeer(string peerName);
        public void SetSymmetryArgument(string name, pxr.VtValue value);
        public void SetSymmetryFunction(pxr.TfToken functionName);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0, System.UInt32 indent);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfRelationshipSpecHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfRelationshipSpecHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfRelationshipSpecHandle this[int index] { get; set; }
        public SdfRelationshipSpecHandleVector() {}
        public SdfRelationshipSpecHandleVector(pxr.SdfRelationshipSpecHandleVector other) {}
        public SdfRelationshipSpecHandleVector(System.Collections.ICollection c) {}
        public SdfRelationshipSpecHandleVector(int capacity) {}
        public void Add(pxr.SdfRelationshipSpecHandle x);
        public void AddRange(pxr.SdfRelationshipSpecHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfRelationshipSpecHandle[] array);
        public void CopyTo(pxr.SdfRelationshipSpecHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfRelationshipSpecHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfRelationshipSpecHandleVector.SdfRelationshipSpecHandleVectorEnumerator GetEnumerator();
        public pxr.SdfRelationshipSpecHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfRelationshipSpecHandle x);
        public void InsertRange(int index, pxr.SdfRelationshipSpecHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfRelationshipSpecHandleVector Repeat(pxr.SdfRelationshipSpecHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfRelationshipSpecHandleVector values);
        public sealed class SdfRelationshipSpecHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfRelationshipSpecHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfRelationshipSpecHandle Current { get; }
            public SdfRelationshipSpecHandleVectorEnumerator(pxr.SdfRelationshipSpecHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfSpec : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool ClearField(pxr.TfToken name);
        public void ClearInfo(pxr.TfToken key);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtValue GetFallbackForInfo(pxr.TfToken key);
        public pxr.VtValue GetField(pxr.TfToken name);
        public pxr.VtValue GetInfo(pxr.TfToken key);
        public pxr.SdfLayerHandle GetLayer();
        public pxr.TfToken GetMetaDataDisplayGroup(pxr.TfToken key);
        public pxr.TfTokenVector GetMetaDataInfoKeys();
        public pxr.SdfPath GetPath();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public pxr.SdfSpecType GetSpecType();
        public pxr.TfType GetTypeForInfo(pxr.TfToken key);
        public bool HasField(pxr.TfToken name);
        public bool HasInfo(pxr.TfToken key);
        public bool IsDormant();
        public bool IsInert();
        public bool IsInert(bool ignoreChildren);
        public pxr.TfTokenVector ListFields();
        public pxr.TfTokenVector ListInfoKeys();
        public bool PermissionToEdit();
        public bool SetField(pxr.TfToken name, pxr.VtValue value);
        public void SetInfo(pxr.TfToken key, pxr.VtValue value);
        public void SetInfoDictionaryValue(pxr.TfToken dictionaryKey, pxr.TfToken entryKey, pxr.VtValue value);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0, System.UInt32 indent);
    }

    public class SdfSpecHandle : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfSpecHandle() {}
        public SdfSpecHandle(pxr.SdfAttributeSpecHandle handle) {}
        public SdfSpecHandle(pxr.SdfPrimSpecHandle handle) {}
        public SdfSpecHandle(pxr.SdfRelationshipSpecHandle handle) {}
        public SdfSpecHandle(pxr.SdfSpec spec) {}
        public SdfSpecHandle(pxr.SdfSpecHandle handle) {}
        public pxr.SdfSpec __deref__();
        public bool ClearField(pxr.TfToken name);
        public void ClearInfo(pxr.TfToken key);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtValue GetFallbackForInfo(pxr.TfToken key);
        public pxr.VtValue GetField(pxr.TfToken name);
        public pxr.VtValue GetInfo(pxr.TfToken key);
        public pxr.SdfLayerHandle GetLayer();
        public pxr.TfToken GetMetaDataDisplayGroup(pxr.TfToken key);
        public pxr.TfTokenVector GetMetaDataInfoKeys();
        public pxr.SdfPath GetPath();
        public pxr.SWIGTYPE_p_SdfSchemaBase GetSchema();
        public pxr.SdfSpecType GetSpecType();
        public pxr.TfType GetTypeForInfo(pxr.TfToken key);
        public bool HasField(pxr.TfToken name);
        public bool HasInfo(pxr.TfToken key);
        public bool IsDormant();
        public bool IsInert();
        public bool IsInert(bool ignoreChildren);
        public pxr.TfTokenVector ListFields();
        public pxr.TfTokenVector ListInfoKeys();
        public bool PermissionToEdit();
        public bool SetField(pxr.TfToken name, pxr.VtValue value);
        public void SetInfo(pxr.TfToken key, pxr.VtValue value);
        public void SetInfoDictionaryValue(pxr.TfToken dictionaryKey, pxr.TfToken entryKey, pxr.VtValue value);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0);
        public bool WriteToStream(pxr.SWIGTYPE_p_std__ostream arg0, System.UInt32 indent);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfSpecHandleVector : System.Collections.Generic.IEnumerable<pxr.SdfSpecHandle>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfSpecHandle this[int index] { get; set; }
        public SdfSpecHandleVector() {}
        public SdfSpecHandleVector(pxr.SdfSpecHandleVector other) {}
        public SdfSpecHandleVector(System.Collections.ICollection c) {}
        public SdfSpecHandleVector(int capacity) {}
        public void Add(pxr.SdfSpecHandle x);
        public void AddRange(pxr.SdfSpecHandleVector values);
        public void Clear();
        public void CopyTo(pxr.SdfSpecHandle[] array);
        public void CopyTo(pxr.SdfSpecHandle[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfSpecHandle[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfSpecHandleVector.SdfSpecHandleVectorEnumerator GetEnumerator();
        public pxr.SdfSpecHandleVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfSpecHandle x);
        public void InsertRange(int index, pxr.SdfSpecHandleVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfSpecHandleVector Repeat(pxr.SdfSpecHandle value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfSpecHandleVector values);
        public sealed class SdfSpecHandleVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfSpecHandle>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfSpecHandle Current { get; }
            public SdfSpecHandleVectorEnumerator(pxr.SdfSpecHandleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public enum SdfSpecifier
    {
        public const pxr.SdfSpecifier SdfNumSpecifiers = 3;
        public const pxr.SdfSpecifier SdfSpecifierClass = 2;
        public const pxr.SdfSpecifier SdfSpecifierDef = 0;
        public const pxr.SdfSpecifier SdfSpecifierOver = 1;
        public int value__;
    }

    public enum SdfSpecType
    {
        public const pxr.SdfSpecType SdfNumSpecTypes = 12;
        public const pxr.SdfSpecType SdfSpecTypeAttribute = 1;
        public const pxr.SdfSpecType SdfSpecTypeConnection = 2;
        public const pxr.SdfSpecType SdfSpecTypeExpression = 3;
        public const pxr.SdfSpecType SdfSpecTypeMapper = 4;
        public const pxr.SdfSpecType SdfSpecTypeMapperArg = 5;
        public const pxr.SdfSpecType SdfSpecTypePrim = 6;
        public const pxr.SdfSpecType SdfSpecTypePseudoRoot = 7;
        public const pxr.SdfSpecType SdfSpecTypeRelationship = 8;
        public const pxr.SdfSpecType SdfSpecTypeRelationshipTarget = 9;
        public const pxr.SdfSpecType SdfSpecTypeUnknown = 0;
        public const pxr.SdfSpecType SdfSpecTypeVariant = 10;
        public const pxr.SdfSpecType SdfSpecTypeVariantSet = 11;
        public int value__;
    }

    public class SdfStringListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfStringListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfStringListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfStringListOp Create();
        public static pxr.SdfStringListOp Create(pxr.StdStringVector prependedItems);
        public static pxr.SdfStringListOp Create(pxr.StdStringVector prependedItems, pxr.StdStringVector appendedItems);
        public static pxr.SdfStringListOp Create(pxr.StdStringVector prependedItems, pxr.StdStringVector appendedItems, pxr.StdStringVector deletedItems);
        public static pxr.SdfStringListOp CreateExplicit();
        public static pxr.SdfStringListOp CreateExplicit(pxr.StdStringVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdStringVector GetAddedItems();
        public pxr.StdStringVector GetAppendedItems();
        public pxr.StdStringVector GetDeletedItems();
        public pxr.StdStringVector GetExplicitItems();
        public pxr.StdStringVector GetItems(pxr.SdfListOpType type);
        public pxr.StdStringVector GetOrderedItems();
        public pxr.StdStringVector GetPrependedItems();
        public bool HasItem(string item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.StdStringVector newItems);
        public void SetAddedItems(pxr.StdStringVector items);
        public void SetAppendedItems(pxr.StdStringVector items);
        public void SetDeletedItems(pxr.StdStringVector items);
        public void SetExplicitItems(pxr.StdStringVector items);
        public void SetItems(pxr.StdStringVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.StdStringVector items);
        public void SetPrependedItems(pxr.StdStringVector items);
        public void Swap(pxr.SdfStringListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfStringListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfStringListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfStringListOp this[int index] { get; set; }
        public SdfStringListOpVector() {}
        public SdfStringListOpVector(pxr.SdfStringListOpVector other) {}
        public SdfStringListOpVector(System.Collections.ICollection c) {}
        public SdfStringListOpVector(int capacity) {}
        public void Add(pxr.SdfStringListOp x);
        public void AddRange(pxr.SdfStringListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfStringListOp[] array);
        public void CopyTo(pxr.SdfStringListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfStringListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfStringListOpVector.SdfStringListOpVectorEnumerator GetEnumerator();
        public pxr.SdfStringListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfStringListOp x);
        public void InsertRange(int index, pxr.SdfStringListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfStringListOpVector Repeat(pxr.SdfStringListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfStringListOpVector values);
        public sealed class SdfStringListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfStringListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfStringListOp Current { get; }
            public SdfStringListOpVectorEnumerator(pxr.SdfStringListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfSubLayerProxy : System.IDisposable
    {
        protected bool swigCMemOwn;
        public System.UInt32 Count(string value);
        public virtual void Dispose();
        public void Erase(System.UInt32 index);
        protected virtual void Finalize();
        public System.UInt32 Find(string value);
        public pxr.SdfPath GetPath();
        public void Insert(int index, string value);
        public bool IsExpired();
        public void push_back(string layerPath);
        public void Remove(string value);
        public void Replace(string oldValue, string newValue);
        public System.UInt32 size();
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfTfTokenListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfTokenListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfTokenListOp this[int index] { get; set; }
        public SdfTfTokenListOpVector() {}
        public SdfTfTokenListOpVector(pxr.SdfTfTokenListOpVector other) {}
        public SdfTfTokenListOpVector(System.Collections.ICollection c) {}
        public SdfTfTokenListOpVector(int capacity) {}
        public void Add(pxr.SdfTokenListOp x);
        public void AddRange(pxr.SdfTfTokenListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfTokenListOp[] array);
        public void CopyTo(pxr.SdfTokenListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfTokenListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfTfTokenListOpVector.SdfTfTokenListOpVectorEnumerator GetEnumerator();
        public pxr.SdfTfTokenListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfTokenListOp x);
        public void InsertRange(int index, pxr.SdfTfTokenListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfTfTokenListOpVector Repeat(pxr.SdfTokenListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfTfTokenListOpVector values);
        public sealed class SdfTfTokenListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfTokenListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfTokenListOp Current { get; }
            public SdfTfTokenListOpVectorEnumerator(pxr.SdfTfTokenListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfTimeCode : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfTimeCode() {}
        public SdfTimeCode(double time) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public System.UInt32 GetHash();
        public double GetValue();
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfTimeCodeArray : pxr.Vt_ArrayBase
    {
        public pxr.SdfTimeCode this[int index] { get; set; }
        public SdfTimeCodeArray() {}
        public SdfTimeCodeArray(pxr.SdfTimeCodeArray other) {}
        public SdfTimeCodeArray(System.UInt32 n) {}
        public SdfTimeCodeArray(System.UInt32 n, pxr.SdfTimeCode value) {}
        public void assign(System.UInt32 n, pxr.SdfTimeCode fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.SdfTimeCode[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.SdfTimeCode[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.SdfTimeCodeArray lhs, pxr.SdfTimeCodeArray rhs);
        protected virtual void Finalize();
        protected pxr.SdfTimeCode GetValue(int index);
        public bool IsIdentical(pxr.SdfTimeCodeArray other);
        public void pop_back();
        public void push_back(pxr.SdfTimeCode elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.SdfTimeCode value);
        public System.UInt32 size();
        public void swap(pxr.SdfTimeCodeArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfTimeCodeVector : System.Collections.Generic.IEnumerable<pxr.SdfTimeCode>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfTimeCode this[int index] { get; set; }
        public SdfTimeCodeVector() {}
        public SdfTimeCodeVector(pxr.SdfTimeCodeVector other) {}
        public SdfTimeCodeVector(System.Collections.ICollection c) {}
        public SdfTimeCodeVector(int capacity) {}
        public void Add(pxr.SdfTimeCode x);
        public void AddRange(pxr.SdfTimeCodeVector values);
        public void Clear();
        public void CopyTo(pxr.SdfTimeCode[] array);
        public void CopyTo(pxr.SdfTimeCode[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfTimeCode[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfTimeCodeVector.SdfTimeCodeVectorEnumerator GetEnumerator();
        public pxr.SdfTimeCodeVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfTimeCode x);
        public void InsertRange(int index, pxr.SdfTimeCodeVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfTimeCodeVector Repeat(pxr.SdfTimeCode value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfTimeCodeVector values);
        public sealed class SdfTimeCodeVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfTimeCode>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfTimeCode Current { get; }
            public SdfTimeCodeVectorEnumerator(pxr.SdfTimeCodeVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfTokenListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfTokenListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfTokenListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfTokenListOp Create();
        public static pxr.SdfTokenListOp Create(pxr.TfTokenVector prependedItems);
        public static pxr.SdfTokenListOp Create(pxr.TfTokenVector prependedItems, pxr.TfTokenVector appendedItems);
        public static pxr.SdfTokenListOp Create(pxr.TfTokenVector prependedItems, pxr.TfTokenVector appendedItems, pxr.TfTokenVector deletedItems);
        public static pxr.SdfTokenListOp CreateExplicit();
        public static pxr.SdfTokenListOp CreateExplicit(pxr.TfTokenVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.TfTokenVector GetAddedItems();
        public pxr.TfTokenVector GetAppendedItems();
        public pxr.TfTokenVector GetDeletedItems();
        public pxr.TfTokenVector GetExplicitItems();
        public pxr.TfTokenVector GetItems(pxr.SdfListOpType type);
        public pxr.TfTokenVector GetOrderedItems();
        public pxr.TfTokenVector GetPrependedItems();
        public bool HasItem(pxr.TfToken item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.TfTokenVector newItems);
        public void SetAddedItems(pxr.TfTokenVector items);
        public void SetAppendedItems(pxr.TfTokenVector items);
        public void SetDeletedItems(pxr.TfTokenVector items);
        public void SetExplicitItems(pxr.TfTokenVector items);
        public void SetItems(pxr.TfTokenVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.TfTokenVector items);
        public void SetPrependedItems(pxr.TfTokenVector items);
        public void Swap(pxr.SdfTokenListOp rhs);
    }

    public class SdfTupleDimensions : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.SWIGTYPE_p_size_t d { get; set; }
        public System.UInt32 size { get; set; }
        public SdfTupleDimensions() {}
        public SdfTupleDimensions(pxr.SWIGTYPE_p_a_2__size_t s) {}
        public SdfTupleDimensions(System.UInt32 m) {}
        public SdfTupleDimensions(System.UInt32 m, System.UInt32 n) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class SdfUInt64ListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfUInt64ListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfUInt64ListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfUInt64ListOp Create();
        public static pxr.SdfUInt64ListOp Create(pxr.StdUInt64Vector prependedItems);
        public static pxr.SdfUInt64ListOp Create(pxr.StdUInt64Vector prependedItems, pxr.StdUInt64Vector appendedItems);
        public static pxr.SdfUInt64ListOp Create(pxr.StdUInt64Vector prependedItems, pxr.StdUInt64Vector appendedItems, pxr.StdUInt64Vector deletedItems);
        public static pxr.SdfUInt64ListOp CreateExplicit();
        public static pxr.SdfUInt64ListOp CreateExplicit(pxr.StdUInt64Vector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdUInt64Vector GetAddedItems();
        public pxr.StdUInt64Vector GetAppendedItems();
        public pxr.StdUInt64Vector GetDeletedItems();
        public pxr.StdUInt64Vector GetExplicitItems();
        public pxr.StdUInt64Vector GetItems(pxr.SdfListOpType type);
        public pxr.StdUInt64Vector GetOrderedItems();
        public pxr.StdUInt64Vector GetPrependedItems();
        public bool HasItem(System.UInt64 item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.StdUInt64Vector newItems);
        public void SetAddedItems(pxr.StdUInt64Vector items);
        public void SetAppendedItems(pxr.StdUInt64Vector items);
        public void SetDeletedItems(pxr.StdUInt64Vector items);
        public void SetExplicitItems(pxr.StdUInt64Vector items);
        public void SetItems(pxr.StdUInt64Vector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.StdUInt64Vector items);
        public void SetPrependedItems(pxr.StdUInt64Vector items);
        public void Swap(pxr.SdfUInt64ListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfUInt64ListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfUInt64ListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfUInt64ListOp this[int index] { get; set; }
        public SdfUInt64ListOpVector() {}
        public SdfUInt64ListOpVector(pxr.SdfUInt64ListOpVector other) {}
        public SdfUInt64ListOpVector(System.Collections.ICollection c) {}
        public SdfUInt64ListOpVector(int capacity) {}
        public void Add(pxr.SdfUInt64ListOp x);
        public void AddRange(pxr.SdfUInt64ListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfUInt64ListOp[] array);
        public void CopyTo(pxr.SdfUInt64ListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfUInt64ListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfUInt64ListOpVector.SdfUInt64ListOpVectorEnumerator GetEnumerator();
        public pxr.SdfUInt64ListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfUInt64ListOp x);
        public void InsertRange(int index, pxr.SdfUInt64ListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfUInt64ListOpVector Repeat(pxr.SdfUInt64ListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfUInt64ListOpVector values);
        public sealed class SdfUInt64ListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfUInt64ListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfUInt64ListOp Current { get; }
            public SdfUInt64ListOpVectorEnumerator(pxr.SdfUInt64ListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfUIntListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfUIntListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfUIntListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfUIntListOp Create();
        public static pxr.SdfUIntListOp Create(pxr.StdUIntVector prependedItems);
        public static pxr.SdfUIntListOp Create(pxr.StdUIntVector prependedItems, pxr.StdUIntVector appendedItems);
        public static pxr.SdfUIntListOp Create(pxr.StdUIntVector prependedItems, pxr.StdUIntVector appendedItems, pxr.StdUIntVector deletedItems);
        public static pxr.SdfUIntListOp CreateExplicit();
        public static pxr.SdfUIntListOp CreateExplicit(pxr.StdUIntVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdUIntVector GetAddedItems();
        public pxr.StdUIntVector GetAppendedItems();
        public pxr.StdUIntVector GetDeletedItems();
        public pxr.StdUIntVector GetExplicitItems();
        public pxr.StdUIntVector GetItems(pxr.SdfListOpType type);
        public pxr.StdUIntVector GetOrderedItems();
        public pxr.StdUIntVector GetPrependedItems();
        public bool HasItem(System.UInt32 item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.StdUIntVector newItems);
        public void SetAddedItems(pxr.StdUIntVector items);
        public void SetAppendedItems(pxr.StdUIntVector items);
        public void SetDeletedItems(pxr.StdUIntVector items);
        public void SetExplicitItems(pxr.StdUIntVector items);
        public void SetItems(pxr.StdUIntVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.StdUIntVector items);
        public void SetPrependedItems(pxr.StdUIntVector items);
        public void Swap(pxr.SdfUIntListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfUIntListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfUIntListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfUIntListOp this[int index] { get; set; }
        public SdfUIntListOpVector() {}
        public SdfUIntListOpVector(pxr.SdfUIntListOpVector other) {}
        public SdfUIntListOpVector(System.Collections.ICollection c) {}
        public SdfUIntListOpVector(int capacity) {}
        public void Add(pxr.SdfUIntListOp x);
        public void AddRange(pxr.SdfUIntListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfUIntListOp[] array);
        public void CopyTo(pxr.SdfUIntListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfUIntListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfUIntListOpVector.SdfUIntListOpVectorEnumerator GetEnumerator();
        public pxr.SdfUIntListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfUIntListOp x);
        public void InsertRange(int index, pxr.SdfUIntListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfUIntListOpVector Repeat(pxr.SdfUIntListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfUIntListOpVector values);
        public sealed class SdfUIntListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfUIntListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfUIntListOp Current { get; }
            public SdfUIntListOpVectorEnumerator(pxr.SdfUIntListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfUnregisteredValue : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfUnregisteredValue() {}
        public SdfUnregisteredValue(pxr.SdfUnregisteredValueListOp value) {}
        public SdfUnregisteredValue(pxr.VtDictionary value) {}
        public SdfUnregisteredValue(string value) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtValue GetValue();
    }

    public class SdfUnregisteredValueListOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfUnregisteredValueListOp() {}
        public void Clear();
        public void ClearAndMakeExplicit();
        public void ComposeOperations(pxr.SdfUnregisteredValueListOp stronger, pxr.SdfListOpType op);
        public static pxr.SdfUnregisteredValueListOp Create();
        public static pxr.SdfUnregisteredValueListOp Create(pxr.StdUnregisteredValueVector prependedItems);
        public static pxr.SdfUnregisteredValueListOp Create(pxr.StdUnregisteredValueVector prependedItems, pxr.StdUnregisteredValueVector appendedItems);
        public static pxr.SdfUnregisteredValueListOp Create(pxr.StdUnregisteredValueVector prependedItems, pxr.StdUnregisteredValueVector appendedItems, pxr.StdUnregisteredValueVector deletedItems);
        public static pxr.SdfUnregisteredValueListOp CreateExplicit();
        public static pxr.SdfUnregisteredValueListOp CreateExplicit(pxr.StdUnregisteredValueVector explicitItems);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdUnregisteredValueVector GetAddedItems();
        public pxr.StdUnregisteredValueVector GetAppendedItems();
        public pxr.StdUnregisteredValueVector GetDeletedItems();
        public pxr.StdUnregisteredValueVector GetExplicitItems();
        public pxr.StdUnregisteredValueVector GetItems(pxr.SdfListOpType type);
        public pxr.StdUnregisteredValueVector GetOrderedItems();
        public pxr.StdUnregisteredValueVector GetPrependedItems();
        public bool HasItem(pxr.SdfUnregisteredValue item);
        public bool HasKeys();
        public bool IsExplicit();
        public bool ReplaceOperations(pxr.SdfListOpType op, System.UInt32 index, System.UInt32 n, pxr.StdUnregisteredValueVector newItems);
        public void SetAddedItems(pxr.StdUnregisteredValueVector items);
        public void SetAppendedItems(pxr.StdUnregisteredValueVector items);
        public void SetDeletedItems(pxr.StdUnregisteredValueVector items);
        public void SetExplicitItems(pxr.StdUnregisteredValueVector items);
        public void SetItems(pxr.StdUnregisteredValueVector items, pxr.SdfListOpType type);
        public void SetOrderedItems(pxr.StdUnregisteredValueVector items);
        public void SetPrependedItems(pxr.StdUnregisteredValueVector items);
        public void Swap(pxr.SdfUnregisteredValueListOp rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SdfUnregisteredValueListOpVector : System.Collections.Generic.IEnumerable<pxr.SdfUnregisteredValueListOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfUnregisteredValueListOp this[int index] { get; set; }
        public SdfUnregisteredValueListOpVector() {}
        public SdfUnregisteredValueListOpVector(pxr.SdfUnregisteredValueListOpVector other) {}
        public SdfUnregisteredValueListOpVector(System.Collections.ICollection c) {}
        public SdfUnregisteredValueListOpVector(int capacity) {}
        public void Add(pxr.SdfUnregisteredValueListOp x);
        public void AddRange(pxr.SdfUnregisteredValueListOpVector values);
        public void Clear();
        public void CopyTo(pxr.SdfUnregisteredValueListOp[] array);
        public void CopyTo(pxr.SdfUnregisteredValueListOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfUnregisteredValueListOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfUnregisteredValueListOpVector.SdfUnregisteredValueListOpVectorEnumerator GetEnumerator();
        public pxr.SdfUnregisteredValueListOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfUnregisteredValueListOp x);
        public void InsertRange(int index, pxr.SdfUnregisteredValueListOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.SdfUnregisteredValueListOpVector Repeat(pxr.SdfUnregisteredValueListOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.SdfUnregisteredValueListOpVector values);
        public sealed class SdfUnregisteredValueListOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfUnregisteredValueListOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfUnregisteredValueListOp Current { get; }
            public SdfUnregisteredValueListOpVectorEnumerator(pxr.SdfUnregisteredValueListOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SdfValueBlock : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfValueBlock() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class SdfValueTypeName : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfValueTypeName() {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.SdfValueTypeName lhs, pxr.SdfValueTypeName rhs);
        protected virtual void Finalize();
        public pxr.TfTokenVector GetAliasesAsTokens();
        public pxr.SdfValueTypeName GetArrayType();
        public pxr.TfToken GetAsToken();
        public string GetCPPTypeName();
        public pxr.VtValue GetDefaultValue();
        public System.UInt32 GetHash();
        public virtual int GetHashCode();
        public pxr.TfToken GetRole();
        public pxr.SdfValueTypeName GetScalarType();
        public pxr.TfType GetTfType();
        public bool IsArray();
        public bool IsScalar();
        public static bool operator ==(pxr.SdfValueTypeName lhs, pxr.SdfValueTypeName rhs);
        public static bool operator !=(pxr.SdfValueTypeName lhs, pxr.SdfValueTypeName rhs);
    }

    public class SdfValueTypeNameHash : System.IDisposable
    {
        protected bool swigCMemOwn;
        public SdfValueTypeNameHash() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public enum SdfVariability
    {
        public const pxr.SdfVariability SdfNumVariabilities = 2;
        public const pxr.SdfVariability SdfVariabilityUniform = 1;
        public const pxr.SdfVariability SdfVariabilityVarying = 0;
        public int value__;
    }

    public class SdrRegistry : pxr.NdrRegistry
    {
        public virtual void Dispose();
        public static pxr.SdrRegistry GetInstance();
        public pxr.SdrShaderNode GetShaderNodeByIdentifier(pxr.TfToken identifier);
        public pxr.SdrShaderNode GetShaderNodeByIdentifier(pxr.TfToken identifier, pxr.TfTokenVector typePriority);
        public pxr.SdrShaderNode GetShaderNodeByIdentifierAndType(pxr.TfToken identifier, pxr.TfToken nodeType);
        public pxr.SdrShaderNode GetShaderNodeByName(string name);
        public pxr.SdrShaderNode GetShaderNodeByName(string name, pxr.TfTokenVector typePriority);
        public pxr.SdrShaderNode GetShaderNodeByName(string name, pxr.TfTokenVector typePriority, pxr.NdrVersionFilter filter);
        public pxr.SdrShaderNode GetShaderNodeByNameAndType(string name, pxr.TfToken nodeType);
        public pxr.SdrShaderNode GetShaderNodeByNameAndType(string name, pxr.TfToken nodeType, pxr.NdrVersionFilter filter);
        public pxr.SdrShaderNode GetShaderNodeFromAsset(pxr.SdfAssetPath shaderAsset);
        public pxr.SdrShaderNode GetShaderNodeFromAsset(pxr.SdfAssetPath shaderAsset, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public pxr.SdrShaderNode GetShaderNodeFromAsset(pxr.SdfAssetPath shaderAsset, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, pxr.TfToken subIdentifier);
        public pxr.SdrShaderNode GetShaderNodeFromAsset(pxr.SdfAssetPath shaderAsset, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, pxr.TfToken subIdentifier, pxr.TfToken sourceType);
        public pxr.SdrShaderNode GetShaderNodeFromSourceCode(string sourceCode, pxr.TfToken sourceType);
        public pxr.SdrShaderNode GetShaderNodeFromSourceCode(string sourceCode, pxr.TfToken sourceType, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public pxr.SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t GetShaderNodesByFamily();
        public pxr.SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t GetShaderNodesByFamily(pxr.TfToken family);
        public pxr.SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t GetShaderNodesByFamily(pxr.TfToken family, pxr.NdrVersionFilter filter);
        public pxr.SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t GetShaderNodesByIdentifier(pxr.TfToken identifier);
        public pxr.SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t GetShaderNodesByName(string name);
        public pxr.SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t GetShaderNodesByName(string name, pxr.NdrVersionFilter filter);
    }

    public class SdrShaderNode : pxr.NdrNode
    {
        public SdrShaderNode(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken context, pxr.TfToken sourceType, string definitionURI, string implementationURI, pxr.SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t properties) {}
        public SdrShaderNode(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken context, pxr.TfToken sourceType, string definitionURI, string implementationURI, pxr.SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t properties, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata) {}
        public SdrShaderNode(pxr.TfToken identifier, pxr.NdrVersion version, string name, pxr.TfToken family, pxr.TfToken context, pxr.TfToken sourceType, string definitionURI, string implementationURI, pxr.SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t properties, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, string sourceCode) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.TfTokenVector GetAdditionalPrimvarProperties();
        public pxr.TfTokenVector GetAllVstructNames();
        public pxr.TfTokenVector GetAssetIdentifierInputNames();
        public pxr.TfToken GetCategory();
        public pxr.SdrShaderProperty GetDefaultInput();
        public pxr.TfTokenVector GetDepartments();
        public string GetHelp();
        public string GetImplementationName();
        public pxr.TfToken GetLabel();
        public pxr.TfTokenVector GetPages();
        public pxr.TfTokenVector GetPrimvars();
        public pxr.TfTokenVector GetPropertyNamesForPage(string pageName);
        public string GetRole();
        public pxr.SdrShaderProperty GetShaderInput(pxr.TfToken inputName);
        public pxr.SdrShaderProperty GetShaderOutput(pxr.TfToken outputName);
    }

    public class SdrShaderProperty : pxr.NdrProperty
    {
        public SdrShaderProperty(pxr.TfToken name, pxr.TfToken type, pxr.VtValue defaultValue, bool isOutput, System.UInt32 arraySize, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t hints, pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_TfToken_t_t options) {}
        public virtual bool CanConnectTo(pxr.NdrProperty other);
        public virtual void Dispose();
        protected virtual void Finalize();
        public string GetHelp();
        public pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t GetHints();
        public string GetImplementationName();
        public pxr.TfToken GetLabel();
        public pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_TfToken_t_t GetOptions();
        public pxr.TfToken GetPage();
        public virtual pxr.SWIGTYPE_p_std__pairT_SdfValueTypeName_TfToken_t GetTypeAsSdfType();
        public pxr.TfTokenVector GetValidConnectionTypes();
        public pxr.TfToken GetVStructConditionalExpr();
        public pxr.TfToken GetVStructMemberName();
        public pxr.TfToken GetVStructMemberOf();
        public pxr.TfToken GetWidget();
        public bool IsAssetIdentifier();
        public virtual bool IsConnectable();
        public bool IsDefaultInput();
        public bool IsVStruct();
        public bool IsVStructMember();
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdDoubleVector : System.Collections.Generic.ICollection<double>, System.Collections.Generic.IEnumerable<double>, System.Collections.Generic.IList<double>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual double this[int index] { get; set; }
        public StdDoubleVector() {}
        public StdDoubleVector(pxr.StdDoubleVector other) {}
        public StdDoubleVector(System.Collections.ICollection c) {}
        public StdDoubleVector(int capacity) {}
        public virtual void Add(double x);
        public void AddRange(pxr.StdDoubleVector values);
        public virtual void Clear();
        public virtual bool Contains(double value);
        public void CopyTo(double[] array);
        public virtual void CopyTo(double[] array, int arrayIndex);
        public void CopyTo(int index, double[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdDoubleVector.StdDoubleVectorEnumerator GetEnumerator();
        public pxr.StdDoubleVector GetRange(int index, int count);
        public virtual int IndexOf(double value);
        public virtual void Insert(int index, double x);
        public void InsertRange(int index, pxr.StdDoubleVector values);
        public int LastIndexOf(double value);
        public virtual bool Remove(double value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdDoubleVector Repeat(double value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdDoubleVector values);
        public sealed class StdDoubleVectorEnumerator : System.Collections.Generic.IEnumerator<double>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual double Current { get; }
            public StdDoubleVectorEnumerator(pxr.StdDoubleVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdDoubleVectorVector : System.Collections.Generic.IEnumerable<pxr.StdDoubleVector>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.StdDoubleVector this[int index] { get; set; }
        public StdDoubleVectorVector() {}
        public StdDoubleVectorVector(pxr.StdDoubleVectorVector other) {}
        public StdDoubleVectorVector(System.Collections.ICollection c) {}
        public StdDoubleVectorVector(int capacity) {}
        public void Add(pxr.StdDoubleVector x);
        public void AddRange(pxr.StdDoubleVectorVector values);
        public void Clear();
        public void CopyTo(pxr.StdDoubleVector[] array);
        public void CopyTo(pxr.StdDoubleVector[] array, int arrayIndex);
        public void CopyTo(int index, pxr.StdDoubleVector[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdDoubleVectorVector.StdDoubleVectorVectorEnumerator GetEnumerator();
        public pxr.StdDoubleVectorVector GetRange(int index, int count);
        public void Insert(int index, pxr.StdDoubleVector x);
        public void InsertRange(int index, pxr.StdDoubleVectorVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdDoubleVectorVector Repeat(pxr.StdDoubleVector value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdDoubleVectorVector values);
        public sealed class StdDoubleVectorVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.StdDoubleVector>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.StdDoubleVector Current { get; }
            public StdDoubleVectorVectorEnumerator(pxr.StdDoubleVectorVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdFloatVector : System.Collections.Generic.ICollection<float>, System.Collections.Generic.IEnumerable<float>, System.Collections.Generic.IList<float>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual float this[int index] { get; set; }
        public StdFloatVector() {}
        public StdFloatVector(pxr.StdFloatVector other) {}
        public StdFloatVector(System.Collections.ICollection c) {}
        public StdFloatVector(int capacity) {}
        public virtual void Add(float x);
        public void AddRange(pxr.StdFloatVector values);
        public virtual void Clear();
        public virtual bool Contains(float value);
        public void CopyTo(float[] array);
        public virtual void CopyTo(float[] array, int arrayIndex);
        public void CopyTo(int index, float[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdFloatVector.StdFloatVectorEnumerator GetEnumerator();
        public pxr.StdFloatVector GetRange(int index, int count);
        public virtual int IndexOf(float value);
        public virtual void Insert(int index, float x);
        public void InsertRange(int index, pxr.StdFloatVector values);
        public int LastIndexOf(float value);
        public virtual bool Remove(float value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdFloatVector Repeat(float value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdFloatVector values);
        public sealed class StdFloatVectorEnumerator : System.Collections.Generic.IEnumerator<float>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual float Current { get; }
            public StdFloatVectorEnumerator(pxr.StdFloatVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdFloatVectorVector : System.Collections.Generic.IEnumerable<pxr.StdFloatVector>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.StdFloatVector this[int index] { get; set; }
        public StdFloatVectorVector() {}
        public StdFloatVectorVector(pxr.StdFloatVectorVector other) {}
        public StdFloatVectorVector(System.Collections.ICollection c) {}
        public StdFloatVectorVector(int capacity) {}
        public void Add(pxr.StdFloatVector x);
        public void AddRange(pxr.StdFloatVectorVector values);
        public void Clear();
        public void CopyTo(pxr.StdFloatVector[] array);
        public void CopyTo(pxr.StdFloatVector[] array, int arrayIndex);
        public void CopyTo(int index, pxr.StdFloatVector[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdFloatVectorVector.StdFloatVectorVectorEnumerator GetEnumerator();
        public pxr.StdFloatVectorVector GetRange(int index, int count);
        public void Insert(int index, pxr.StdFloatVector x);
        public void InsertRange(int index, pxr.StdFloatVectorVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdFloatVectorVector Repeat(pxr.StdFloatVector value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdFloatVectorVector values);
        public sealed class StdFloatVectorVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.StdFloatVector>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.StdFloatVector Current { get; }
            public StdFloatVectorVectorEnumerator(pxr.StdFloatVectorVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdIntVector : System.Collections.Generic.ICollection<int>, System.Collections.Generic.IEnumerable<int>, System.Collections.Generic.IList<int>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual int this[int index] { get; set; }
        public StdIntVector() {}
        public StdIntVector(pxr.StdIntVector other) {}
        public StdIntVector(System.Collections.ICollection c) {}
        public StdIntVector(int capacity) {}
        public virtual void Add(int x);
        public void AddRange(pxr.StdIntVector values);
        public virtual void Clear();
        public virtual bool Contains(int value);
        public void CopyTo(int[] array);
        public virtual void CopyTo(int[] array, int arrayIndex);
        public void CopyTo(int index, int[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdIntVector.StdIntVectorEnumerator GetEnumerator();
        public pxr.StdIntVector GetRange(int index, int count);
        public virtual int IndexOf(int value);
        public virtual void Insert(int index, int x);
        public void InsertRange(int index, pxr.StdIntVector values);
        public int LastIndexOf(int value);
        public virtual bool Remove(int value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdIntVector Repeat(int value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdIntVector values);
        public sealed class StdIntVectorEnumerator : System.Collections.Generic.IEnumerator<int>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual int Current { get; }
            public StdIntVectorEnumerator(pxr.StdIntVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdReferenceVector : System.Collections.Generic.IEnumerable<pxr.SdfReference>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfReference this[int index] { get; set; }
        public StdReferenceVector() {}
        public StdReferenceVector(pxr.StdReferenceVector other) {}
        public StdReferenceVector(System.Collections.ICollection c) {}
        public StdReferenceVector(int capacity) {}
        public void Add(pxr.SdfReference x);
        public void AddRange(pxr.StdReferenceVector values);
        public void Clear();
        public void CopyTo(pxr.SdfReference[] array);
        public void CopyTo(pxr.SdfReference[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfReference[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdReferenceVector.StdReferenceVectorEnumerator GetEnumerator();
        public pxr.StdReferenceVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfReference x);
        public void InsertRange(int index, pxr.StdReferenceVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdReferenceVector Repeat(pxr.SdfReference value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdReferenceVector values);
        public sealed class StdReferenceVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfReference>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfReference Current { get; }
            public StdReferenceVectorEnumerator(pxr.StdReferenceVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdStringVector : System.Collections.Generic.ICollection<string>, System.Collections.Generic.IEnumerable<string>, System.Collections.Generic.IList<string>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual string this[int index] { get; set; }
        public StdStringVector() {}
        public StdStringVector(pxr.StdStringVector other) {}
        public StdStringVector(System.Collections.ICollection c) {}
        public StdStringVector(int capacity) {}
        public virtual void Add(string x);
        public void AddRange(pxr.StdStringVector values);
        public virtual void Clear();
        public virtual bool Contains(string value);
        public void CopyTo(string[] array);
        public virtual void CopyTo(string[] array, int arrayIndex);
        public void CopyTo(int index, string[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdStringVector.StdStringVectorEnumerator GetEnumerator();
        public pxr.StdStringVector GetRange(int index, int count);
        public virtual int IndexOf(string value);
        public virtual void Insert(int index, string x);
        public void InsertRange(int index, pxr.StdStringVector values);
        public int LastIndexOf(string value);
        public virtual bool Remove(string value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdStringVector Repeat(string value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdStringVector values);
        public sealed class StdStringVectorEnumerator : System.Collections.Generic.IEnumerator<string>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual string Current { get; }
            public StdStringVectorEnumerator(pxr.StdStringVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdUInt64Vector : System.Collections.Generic.ICollection<System.UInt64>, System.Collections.Generic.IEnumerable<System.UInt64>, System.Collections.Generic.IList<System.UInt64>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual System.UInt64 this[int index] { get; set; }
        public StdUInt64Vector() {}
        public StdUInt64Vector(pxr.StdUInt64Vector other) {}
        public StdUInt64Vector(System.Collections.ICollection c) {}
        public StdUInt64Vector(int capacity) {}
        public virtual void Add(System.UInt64 x);
        public void AddRange(pxr.StdUInt64Vector values);
        public virtual void Clear();
        public virtual bool Contains(System.UInt64 value);
        public void CopyTo(System.UInt64[] array);
        public virtual void CopyTo(System.UInt64[] array, int arrayIndex);
        public void CopyTo(int index, System.UInt64[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdUInt64Vector.StdUInt64VectorEnumerator GetEnumerator();
        public pxr.StdUInt64Vector GetRange(int index, int count);
        public virtual int IndexOf(System.UInt64 value);
        public virtual void Insert(int index, System.UInt64 x);
        public void InsertRange(int index, pxr.StdUInt64Vector values);
        public int LastIndexOf(System.UInt64 value);
        public virtual bool Remove(System.UInt64 value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdUInt64Vector Repeat(System.UInt64 value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdUInt64Vector values);
        public sealed class StdUInt64VectorEnumerator : System.Collections.Generic.IEnumerator<System.UInt64>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual System.UInt64 Current { get; }
            public StdUInt64VectorEnumerator(pxr.StdUInt64Vector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdUIntVector : System.Collections.Generic.ICollection<System.UInt32>, System.Collections.Generic.IEnumerable<System.UInt32>, System.Collections.Generic.IList<System.UInt32>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual System.UInt32 this[int index] { get; set; }
        public StdUIntVector() {}
        public StdUIntVector(pxr.StdUIntVector other) {}
        public StdUIntVector(System.Collections.ICollection c) {}
        public StdUIntVector(int capacity) {}
        public virtual void Add(System.UInt32 x);
        public void AddRange(pxr.StdUIntVector values);
        public virtual void Clear();
        public virtual bool Contains(System.UInt32 value);
        public void CopyTo(System.UInt32[] array);
        public virtual void CopyTo(System.UInt32[] array, int arrayIndex);
        public void CopyTo(int index, System.UInt32[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdUIntVector.StdUIntVectorEnumerator GetEnumerator();
        public pxr.StdUIntVector GetRange(int index, int count);
        public virtual int IndexOf(System.UInt32 value);
        public virtual void Insert(int index, System.UInt32 x);
        public void InsertRange(int index, pxr.StdUIntVector values);
        public int LastIndexOf(System.UInt32 value);
        public virtual bool Remove(System.UInt32 value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdUIntVector Repeat(System.UInt32 value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdUIntVector values);
        public sealed class StdUIntVectorEnumerator : System.Collections.Generic.IEnumerator<System.UInt32>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual System.UInt32 Current { get; }
            public StdUIntVectorEnumerator(pxr.StdUIntVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class StdUnregisteredValueVector : System.Collections.Generic.IEnumerable<pxr.SdfUnregisteredValue>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.SdfUnregisteredValue this[int index] { get; set; }
        public StdUnregisteredValueVector() {}
        public StdUnregisteredValueVector(pxr.StdUnregisteredValueVector other) {}
        public StdUnregisteredValueVector(System.Collections.ICollection c) {}
        public StdUnregisteredValueVector(int capacity) {}
        public void Add(pxr.SdfUnregisteredValue x);
        public void AddRange(pxr.StdUnregisteredValueVector values);
        public void Clear();
        public void CopyTo(pxr.SdfUnregisteredValue[] array);
        public void CopyTo(pxr.SdfUnregisteredValue[] array, int arrayIndex);
        public void CopyTo(int index, pxr.SdfUnregisteredValue[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.StdUnregisteredValueVector.StdUnregisteredValueVectorEnumerator GetEnumerator();
        public pxr.StdUnregisteredValueVector GetRange(int index, int count);
        public void Insert(int index, pxr.SdfUnregisteredValue x);
        public void InsertRange(int index, pxr.StdUnregisteredValueVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.StdUnregisteredValueVector Repeat(pxr.SdfUnregisteredValue value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.StdUnregisteredValueVector values);
        public sealed class StdUnregisteredValueVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.SdfUnregisteredValue>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.SdfUnregisteredValue Current { get; }
            public StdUnregisteredValueVectorEnumerator(pxr.StdUnregisteredValueVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class SWIGTYPE_p_a_2__double
    {
        protected SWIGTYPE_p_a_2__double() {}
    }

    public class SWIGTYPE_p_a_2__float
    {
        protected SWIGTYPE_p_a_2__float() {}
    }

    public class SWIGTYPE_p_a_2__size_t
    {
        protected SWIGTYPE_p_a_2__size_t() {}
    }

    public class SWIGTYPE_p_a_3__double
    {
        protected SWIGTYPE_p_a_3__double() {}
    }

    public class SWIGTYPE_p_a_3__float
    {
        protected SWIGTYPE_p_a_3__float() {}
    }

    public class SWIGTYPE_p_a_4__double
    {
        protected SWIGTYPE_p_a_4__double() {}
    }

    public class SWIGTYPE_p_a_4__float
    {
        protected SWIGTYPE_p_a_4__float() {}
    }

    public class SWIGTYPE_p_ArResolver
    {
        protected SWIGTYPE_p_ArResolver() {}
    }

    public class SWIGTYPE_p_bool
    {
        protected SWIGTYPE_p_bool() {}
    }

    public class SWIGTYPE_p_double
    {
        protected SWIGTYPE_p_double() {}
    }

    public class SWIGTYPE_p_f_p_Vt_ArrayForeignDataSource__void
    {
        protected SWIGTYPE_p_f_p_Vt_ArrayForeignDataSource__void() {}
    }

    public class SWIGTYPE_p_float
    {
        protected SWIGTYPE_p_float() {}
    }

    public class SWIGTYPE_p_int
    {
        protected SWIGTYPE_p_int() {}
    }

    public class SWIGTYPE_p_p_char
    {
        protected SWIGTYPE_p_p_char() {}
    }

    public class SWIGTYPE_p_Pcp_CompressedSdSite
    {
        protected SWIGTYPE_p_Pcp_CompressedSdSite() {}
    }

    public class SWIGTYPE_p_PcpCacheChanges
    {
        protected SWIGTYPE_p_PcpCacheChanges() {}
    }

    public class SWIGTYPE_p_PcpChanges
    {
        protected SWIGTYPE_p_PcpChanges() {}
    }

    public class SWIGTYPE_p_PcpDependencyFlags
    {
        protected SWIGTYPE_p_PcpDependencyFlags() {}
    }

    public class SWIGTYPE_p_PcpDependencyVector
    {
        protected SWIGTYPE_p_PcpDependencyVector() {}
    }

    public class SWIGTYPE_p_PcpDynamicFileFormatDependencyData
    {
        protected SWIGTYPE_p_PcpDynamicFileFormatDependencyData() {}
    }

    public class SWIGTYPE_p_PcpErrorVector
    {
        protected SWIGTYPE_p_PcpErrorVector() {}
    }

    public class SWIGTYPE_p_PcpLayerStackChanges
    {
        protected SWIGTYPE_p_PcpLayerStackChanges() {}
    }

    public class SWIGTYPE_p_PcpLayerStackSite
    {
        protected SWIGTYPE_p_PcpLayerStackSite() {}
    }

    public class SWIGTYPE_p_PcpLifeboat
    {
        protected SWIGTYPE_p_PcpLifeboat() {}
    }

    public class SWIGTYPE_p_PcpMapExpression
    {
        protected SWIGTYPE_p_PcpMapExpression() {}
    }

    public class SWIGTYPE_p_PcpMapFunction
    {
        protected SWIGTYPE_p_PcpMapFunction() {}
    }

    public class SWIGTYPE_p_PcpNodeRange
    {
        protected SWIGTYPE_p_PcpNodeRange() {}
    }

    public class SWIGTYPE_p_PcpPrimIndexInputs
    {
        protected SWIGTYPE_p_PcpPrimIndexInputs() {}
    }

    public class SWIGTYPE_p_PcpPrimIndexOutputs
    {
        protected SWIGTYPE_p_PcpPrimIndexOutputs() {}
    }

    public class SWIGTYPE_p_PcpPrimRange
    {
        protected SWIGTYPE_p_PcpPrimRange() {}
    }

    public class SWIGTYPE_p_PcpPropertyRange
    {
        protected SWIGTYPE_p_PcpPropertyRange() {}
    }

    public class SWIGTYPE_p_PcpSiteStr
    {
        protected SWIGTYPE_p_PcpSiteStr() {}
    }

    public class SWIGTYPE_p_Sdf_PathNode
    {
        protected SWIGTYPE_p_Sdf_PathNode() {}
    }

    public class SWIGTYPE_p_SdfAbstractDataConstValue
    {
        protected SWIGTYPE_p_SdfAbstractDataConstValue() {}
    }

    public class SWIGTYPE_p_SdfAbstractDataValue
    {
        protected SWIGTYPE_p_SdfAbstractDataValue() {}
    }

    public class SWIGTYPE_p_SdfConnectionsProxy
    {
        protected SWIGTYPE_p_SdfConnectionsProxy() {}
    }

    public class SWIGTYPE_p_SdfDictionaryProxy
    {
        protected SWIGTYPE_p_SdfDictionaryProxy() {}
    }

    public class SWIGTYPE_p_SdfInheritsProxy
    {
        protected SWIGTYPE_p_SdfInheritsProxy() {}
    }

    public class SWIGTYPE_p_SdfLayerHandleSet
    {
        protected SWIGTYPE_p_SdfLayerHandleSet() {}
    }

    public class SWIGTYPE_p_SdfPayloadsProxy
    {
        protected SWIGTYPE_p_SdfPayloadsProxy() {}
    }

    public class SWIGTYPE_p_SdfPrimSpecView
    {
        protected SWIGTYPE_p_SdfPrimSpecView() {}
    }

    public class SWIGTYPE_p_SdfPropertySpecView
    {
        protected SWIGTYPE_p_SdfPropertySpecView() {}
    }

    public class SWIGTYPE_p_SdfReferencesProxy
    {
        protected SWIGTYPE_p_SdfReferencesProxy() {}
    }

    public class SWIGTYPE_p_SdfRelocatesMapProxy
    {
        protected SWIGTYPE_p_SdfRelocatesMapProxy() {}
    }

    public class SWIGTYPE_p_SdfSchemaBase
    {
        protected SWIGTYPE_p_SdfSchemaBase() {}
    }

    public class SWIGTYPE_p_SdfSpecializesProxy
    {
        protected SWIGTYPE_p_SdfSpecializesProxy() {}
    }

    public class SWIGTYPE_p_SdfTargetsProxy
    {
        protected SWIGTYPE_p_SdfTargetsProxy() {}
    }

    public class SWIGTYPE_p_SdfVariantSelectionProxy
    {
        protected SWIGTYPE_p_SdfVariantSelectionProxy() {}
    }

    public class SWIGTYPE_p_SdfVariantSetNamesProxy
    {
        protected SWIGTYPE_p_SdfVariantSetNamesProxy() {}
    }

    public class SWIGTYPE_p_size_t
    {
        protected SWIGTYPE_p_size_t() {}
    }

    public class SWIGTYPE_p_std__functionT_bool_fTfToken_const_RF_t
    {
        protected SWIGTYPE_p_std__functionT_bool_fTfToken_const_RF_t() {}
    }

    public class SWIGTYPE_p_std__functionT_std__string_fSdfLayerHandle_const_R_std__string_const_RF_t
    {
        protected SWIGTYPE_p_std__functionT_std__string_fSdfLayerHandle_const_R_std__string_const_RF_t() {}
    }

    public class SWIGTYPE_p_std__functionT_std__string_fstd__string_const_RF_t
    {
        protected SWIGTYPE_p_std__functionT_std__string_fstd__string_const_RF_t() {}
    }

    public class SWIGTYPE_p_std__mapT_double_VtValue_std__lessT_double_t_t
    {
        protected SWIGTYPE_p_std__mapT_double_VtValue_std__lessT_double_t_t() {}
    }

    public class SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t
    {
        protected SWIGTYPE_p_std__mapT_SdfPath_SdfPath_std__lessT_SdfPath_t_t() {}
    }

    public class SWIGTYPE_p_std__mapT_SdfPath_std__vectorT_std__string_t_SdfPath__FastLessThan_t
    {
        protected SWIGTYPE_p_std__mapT_SdfPath_std__vectorT_std__string_t_SdfPath__FastLessThan_t() {}
    }

    public class SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t
    {
        protected SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t() {}
    }

    public class SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t
    {
        protected SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t() {}
    }

    public class SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__size_type
    {
        protected SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__size_type() {}
    }

    public class SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__value_type
    {
        protected SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__value_type() {}
    }

    public class SWIGTYPE_p_std__mapT_TfToken_SdfPath_std__lessT_TfToken_t_t
    {
        protected SWIGTYPE_p_std__mapT_TfToken_SdfPath_std__lessT_TfToken_t_t() {}
    }

    public class SWIGTYPE_p_std__ostream
    {
        protected SWIGTYPE_p_std__ostream() {}
    }

    public class SWIGTYPE_p_std__pairT_SdfValueTypeName_TfToken_t
    {
        protected SWIGTYPE_p_std__pairT_SdfValueTypeName_TfToken_t() {}
    }

    public class SWIGTYPE_p_std__pairT_std__string_bool_t
    {
        protected SWIGTYPE_p_std__pairT_std__string_bool_t() {}
    }

    public class SWIGTYPE_p_std__pairT_UsdStageWeakPtr_UsdEditTarget_t
    {
        protected SWIGTYPE_p_std__pairT_UsdStageWeakPtr_UsdEditTarget_t() {}
    }

    public class SWIGTYPE_p_std__pairT_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t_bool_t
    {
        protected SWIGTYPE_p_std__pairT_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t_bool_t() {}
    }

    public class SWIGTYPE_p_std__setT_double_t
    {
        protected SWIGTYPE_p_std__setT_double_t() {}
    }

    public class SWIGTYPE_p_std__setT_SdfLayerHandle_t
    {
        protected SWIGTYPE_p_std__setT_SdfLayerHandle_t() {}
    }

    public class SWIGTYPE_p_std__setT_SdfPath_t
    {
        protected SWIGTYPE_p_std__setT_SdfPath_t() {}
    }

    public class SWIGTYPE_p_std__setT_SdfPath_t__const_iterator
    {
        protected SWIGTYPE_p_std__setT_SdfPath_t__const_iterator() {}
    }

    public class SWIGTYPE_p_std__setT_std__string_t
    {
        protected SWIGTYPE_p_std__setT_std__string_t() {}
    }

    public class SWIGTYPE_p_std__setT_TfToken_TfTokenFastArbitraryLessThan_t
    {
        protected SWIGTYPE_p_std__setT_TfToken_TfTokenFastArbitraryLessThan_t() {}
    }

    public class SWIGTYPE_p_std__setT_TfType_t
    {
        protected SWIGTYPE_p_std__setT_TfType_t() {}
    }

    public class SWIGTYPE_p_std__setT_UsdUtilsRegisteredVariantSet_t
    {
        protected SWIGTYPE_p_std__setT_UsdUtilsRegisteredVariantSet_t() {}
    }

    public class SWIGTYPE_p_std__shared_ptrT_ArAsset_t
    {
        protected SWIGTYPE_p_std__shared_ptrT_ArAsset_t() {}
    }

    public class SWIGTYPE_p_std__shared_ptrT_UsdSkelAnimMapper_t
    {
        protected SWIGTYPE_p_std__shared_ptrT_UsdSkelAnimMapper_t() {}
    }

    public class SWIGTYPE_p_std__string
    {
        protected SWIGTYPE_p_std__string() {}
    }

    public class SWIGTYPE_p_std__type_info
    {
        protected SWIGTYPE_p_std__type_info() {}
    }

    public class SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t
    {
        protected SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t() {}
    }

    public class SWIGTYPE_p_std__unordered_mapT_UsdShadeInput_std__vectorT_UsdShadeInput_t_UsdShadeInput__Hash_t
    {
        protected SWIGTYPE_p_std__unordered_mapT_UsdShadeInput_std__vectorT_UsdShadeInput_t_UsdShadeInput__Hash_t() {}
    }

    public class SWIGTYPE_p_std__unordered_setT_SdfPath_SdfPath__Hash_t
    {
        protected SWIGTYPE_p_std__unordered_setT_SdfPath_SdfPath__Hash_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_NdrNode_const_p_t
    {
        protected SWIGTYPE_p_std__vectorT_NdrNode_const_p_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t
    {
        protected SWIGTYPE_p_std__vectorT_SdrShaderNode_const_p_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_std__pairT_std__string_std__string_t_t
    {
        protected SWIGTYPE_p_std__vectorT_std__pairT_std__string_std__string_t_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_std__pairT_TfToken_std__setT_SdfPath_t_t_t
    {
        protected SWIGTYPE_p_std__vectorT_std__pairT_TfToken_std__setT_SdfPath_t_t_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_std__pairT_TfToken_TfToken_t_t
    {
        protected SWIGTYPE_p_std__vectorT_std__pairT_TfToken_TfToken_t_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t
    {
        protected SWIGTYPE_p_std__vectorT_std__unique_ptrT_NdrProperty_t_t() {}
    }

    public class SWIGTYPE_p_std__vectorT_UsdUtilsSparseAttrValueWriter_t
    {
        protected SWIGTYPE_p_std__vectorT_UsdUtilsSparseAttrValueWriter_t() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_NdrDiscoveryPlugin_t__RefPtr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_NdrDiscoveryPlugin_t__RefPtr() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_NdrDiscoveryPlugin_t__RefPtrVector
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_NdrDiscoveryPlugin_t__RefPtrVector() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__Ptr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__Ptr() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__RefPtr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_PcpPrimIndex_Graph_t__RefPtr() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__Ptr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__Ptr() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__PtrVector
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__PtrVector() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_SdfFileFormat_t__ConstPtr() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__Ptr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__Ptr() {}
    }

    public class SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__RefPtr
    {
        protected SWIGTYPE_p_TfDeclarePtrsT_SdfLayerStateDelegateBase_t__RefPtr() {}
    }

    public class SWIGTYPE_p_TfDenseHashSetT_TfToken_TfToken__HashFunctor_t
    {
        protected SWIGTYPE_p_TfDenseHashSetT_TfToken_TfToken__HashFunctor_t() {}
    }

    public class SWIGTYPE_p_TfEnum
    {
        protected SWIGTYPE_p_TfEnum() {}
    }

    public class SWIGTYPE_p_TfEnvSettingT_bool_t
    {
        protected SWIGTYPE_p_TfEnvSettingT_bool_t() {}
    }

    public class SWIGTYPE_p_TfHashMapT_SdfPath_GfMatrix4d_SdfPath__Hash_t
    {
        protected SWIGTYPE_p_TfHashMapT_SdfPath_GfMatrix4d_SdfPath__Hash_t() {}
    }

    public class SWIGTYPE_p_TfHashSetT_SdfPath_SdfPath__Hash_t
    {
        protected SWIGTYPE_p_TfHashSetT_SdfPath_SdfPath__Hash_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_float_const_t
    {
        protected SWIGTYPE_p_TfSpanT_float_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_float_t
    {
        protected SWIGTYPE_p_TfSpanT_float_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfMatrix3d_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfMatrix3d_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfMatrix3f_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfMatrix3f_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfMatrix4d_t
    {
        protected SWIGTYPE_p_TfSpanT_GfMatrix4d_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfMatrix4f_t
    {
        protected SWIGTYPE_p_TfSpanT_GfMatrix4f_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfQuatf_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfQuatf_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfQuatf_t
    {
        protected SWIGTYPE_p_TfSpanT_GfQuatf_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfVec2f_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfVec2f_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfVec2f_t
    {
        protected SWIGTYPE_p_TfSpanT_GfVec2f_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfVec3f_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfVec3f_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfVec3f_t
    {
        protected SWIGTYPE_p_TfSpanT_GfVec3f_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfVec3h_const_t
    {
        protected SWIGTYPE_p_TfSpanT_GfVec3h_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_GfVec3h_t
    {
        protected SWIGTYPE_p_TfSpanT_GfVec3h_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_int_const_t
    {
        protected SWIGTYPE_p_TfSpanT_int_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_int_t
    {
        protected SWIGTYPE_p_TfSpanT_int_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_SdfPath_const_t
    {
        protected SWIGTYPE_p_TfSpanT_SdfPath_const_t() {}
    }

    public class SWIGTYPE_p_TfSpanT_TfToken_const_t
    {
        protected SWIGTYPE_p_TfSpanT_TfToken_const_t() {}
    }

    public class SWIGTYPE_p_UsdCollectionMembershipQuery
    {
        protected SWIGTYPE_p_UsdCollectionMembershipQuery() {}
    }

    public class SWIGTYPE_p_UsdPrimDefinition
    {
        protected SWIGTYPE_p_UsdPrimDefinition() {}
    }

    public class SWIGTYPE_p_UsdPrimTypeInfo
    {
        protected SWIGTYPE_p_UsdPrimTypeInfo() {}
    }

    public class SWIGTYPE_p_UsdShadeAttributeType
    {
        protected SWIGTYPE_p_UsdShadeAttributeType() {}
    }

    public class SWIGTYPE_p_UsdStageCache__Id
    {
        protected SWIGTYPE_p_UsdStageCache__Id() {}
    }

    public class SWIGTYPE_p_UsdStageLoadRules
    {
        protected SWIGTYPE_p_UsdStageLoadRules() {}
    }

    public class SWIGTYPE_p_UsdZipFile__Iterator
    {
        protected SWIGTYPE_p_UsdZipFile__Iterator() {}
    }

    public class SWIGTYPE_p_void
    {
        protected SWIGTYPE_p_void() {}
    }

    public class SWIGTYPE_p_VtArrayT_UsdSkelSkinningQuery_t
    {
        protected SWIGTYPE_p_VtArrayT_UsdSkelSkinningQuery_t() {}
    }

    public class SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t
    {
        protected SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t() {}
    }

    public class TfDictionaryLessThan : System.IDisposable
    {
        protected bool swigCMemOwn;
        public TfDictionaryLessThan() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class TfStreamDouble : System.IDisposable
    {
        protected bool swigCMemOwn;
        public double value { get; set; }
        public TfStreamDouble(double d) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class TfStreamFloat : System.IDisposable
    {
        protected bool swigCMemOwn;
        public float value { get; set; }
        public TfStreamFloat(float f) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class TfToken : System.IDisposable
    {
        protected bool swigCMemOwn;
        public TfToken() {}
        public TfToken(pxr.TfToken rhs) {}
        public TfToken(string s) {}
        public TfToken(string s, pxr.TfToken._ImmortalTag arg1) {}
        public string data();
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.TfToken lhs, pxr.TfToken rhs);
        protected virtual void Finalize();
        public static pxr.TfToken Find(string s);
        public virtual int GetHashCode();
        public string GetString();
        public string GetText();
        public System.UInt32 Hash();
        public bool IsEmpty();
        public bool IsImmortal();
        public static bool operator ==(pxr.TfToken lhs, pxr.TfToken rhs);
        public static string op_Implicit(pxr.TfToken value);
        public static bool operator !=(pxr.TfToken lhs, pxr.TfToken rhs);
        public System.UInt32 size();
        public void Swap(pxr.TfToken other);
        public virtual string ToString();
        public enum _ImmortalTag
        {
            public const pxr.TfToken._ImmortalTag Immortal = 0;
            public int value__;
        }
        public class HashFunctor : System.IDisposable
        {
            protected bool swigCMemOwn;
            public HashFunctor() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class TfTokenFastArbitraryLessThan : System.IDisposable
    {
        protected bool swigCMemOwn;
        public TfTokenFastArbitraryLessThan() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class TfTokenVector : System.Collections.Generic.IEnumerable<pxr.TfToken>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.TfToken this[int index] { get; set; }
        public TfTokenVector() {}
        public TfTokenVector(pxr.TfTokenVector other) {}
        public TfTokenVector(System.Collections.ICollection c) {}
        public TfTokenVector(int capacity) {}
        public void Add(pxr.TfToken x);
        public void AddRange(pxr.TfTokenVector values);
        public void Clear();
        public void CopyTo(pxr.TfToken[] array);
        public void CopyTo(pxr.TfToken[] array, int arrayIndex);
        public void CopyTo(int index, pxr.TfToken[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.TfTokenVector.TfTokenVectorEnumerator GetEnumerator();
        public pxr.TfTokenVector GetRange(int index, int count);
        public void Insert(int index, pxr.TfToken x);
        public void InsertRange(int index, pxr.TfTokenVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.TfTokenVector Repeat(pxr.TfToken value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.TfTokenVector values);
        public sealed class TfTokenVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.TfToken>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.TfToken Current { get; }
            public TfTokenVectorEnumerator(pxr.TfTokenVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class TfType : System.IDisposable
    {
        protected bool swigCMemOwn;
        public TfType() {}
        public void AddAlias(pxr.TfType arg0, string name);
        public pxr.TfType Alias(pxr.TfType arg0, string name);
        public pxr.SWIGTYPE_p_void CastFromAncestor(pxr.TfType ancestor, pxr.SWIGTYPE_p_void addr);
        public pxr.SWIGTYPE_p_void CastToAncestor(pxr.TfType ancestor, pxr.SWIGTYPE_p_void addr);
        public static pxr.TfType Declare(string typeName);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.TfType Find(pxr.SWIGTYPE_p_std__type_info t);
        public static pxr.TfType FindByName(string name);
        public static pxr.TfType FindByTypeid(pxr.SWIGTYPE_p_std__type_info t);
        public pxr.TfType FindDerivedByName(string name);
        public pxr.StdStringVector GetAliases(pxr.TfType derivedType);
        public void GetAllAncestorTypes(pxr.TfTypeVector result);
        public void GetAllDerivedTypes(pxr.SWIGTYPE_p_std__setT_TfType_t result);
        public pxr.TfTypeVector GetBaseTypes();
        public pxr.TfType GetCanonicalType();
        public static string GetCanonicalTypeName(pxr.SWIGTYPE_p_std__type_info arg0);
        public pxr.TfTypeVector GetDirectlyDerivedTypes();
        public System.UInt32 GetNBaseTypes(pxr.TfType arg0, System.UInt32 maxBases);
        public static pxr.TfType GetRoot();
        public System.UInt32 GetSizeof();
        public pxr.SWIGTYPE_p_std__type_info GetTypeid();
        public string GetTypeName();
        public static pxr.TfType GetUnknownType();
        public bool IsA(pxr.TfType queryType);
        public bool IsEnumType();
        public bool IsPlainOldDataType();
        public bool IsRoot();
        public bool IsUnknown();
        public class FactoryBase : System.IDisposable
        {
            protected bool swigCMemOwn;
            public FactoryBase() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
        public enum LegacyFlags
        {
            public const pxr.TfType.LegacyFlags ABSTRACT = 1;
            public const pxr.TfType.LegacyFlags CONCRETE = 2;
            public const pxr.TfType.LegacyFlags MANUFACTURABLE = 8;
            public int value__;
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class TfTypeVector : System.Collections.Generic.IEnumerable<pxr.TfType>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.TfType this[int index] { get; set; }
        public TfTypeVector() {}
        public TfTypeVector(pxr.TfTypeVector other) {}
        public TfTypeVector(System.Collections.ICollection c) {}
        public TfTypeVector(int capacity) {}
        public void Add(pxr.TfType x);
        public void AddRange(pxr.TfTypeVector values);
        public void Clear();
        public void CopyTo(pxr.TfType[] array);
        public void CopyTo(pxr.TfType[] array, int arrayIndex);
        public void CopyTo(int index, pxr.TfType[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.TfTypeVector.TfTypeVectorEnumerator GetEnumerator();
        public pxr.TfTypeVector GetRange(int index, int count);
        public void Insert(int index, pxr.TfType x);
        public void InsertRange(int index, pxr.TfTypeVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.TfTypeVector Repeat(pxr.TfType value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.TfTypeVector values);
        public sealed class TfTypeVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.TfType>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.TfType Current { get; }
            public TfTypeVectorEnumerator(pxr.TfTypeVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public enum Usd_PrimFlags
    {
        public const pxr.Usd_PrimFlags Usd_PrimAbstractFlag = 4;
        public const pxr.Usd_PrimFlags Usd_PrimActiveFlag = 0;
        public const pxr.Usd_PrimFlags Usd_PrimClipsFlag = 9;
        public const pxr.Usd_PrimFlags Usd_PrimDeadFlag = 10;
        public const pxr.Usd_PrimFlags Usd_PrimDefinedFlag = 5;
        public const pxr.Usd_PrimFlags Usd_PrimGroupFlag = 3;
        public const pxr.Usd_PrimFlags Usd_PrimHasDefiningSpecifierFlag = 6;
        public const pxr.Usd_PrimFlags Usd_PrimHasPayloadFlag = 8;
        public const pxr.Usd_PrimFlags Usd_PrimInstanceFlag = 7;
        public const pxr.Usd_PrimFlags Usd_PrimInstanceProxyFlag = 12;
        public const pxr.Usd_PrimFlags Usd_PrimLoadedFlag = 1;
        public const pxr.Usd_PrimFlags Usd_PrimMasterFlag = 11;
        public const pxr.Usd_PrimFlags Usd_PrimModelFlag = 2;
        public const pxr.Usd_PrimFlags Usd_PrimNumFlags = 14;
        public const pxr.Usd_PrimFlags Usd_PrimPseudoRootFlag = 13;
        public int value__;
    }

    public class Usd_PrimFlagsConjunction : pxr.Usd_PrimFlagsPredicate
    {
        public Usd_PrimFlagsConjunction() {}
        public Usd_PrimFlagsConjunction(pxr.Usd_Term term) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class Usd_PrimFlagsDisjunction : pxr.Usd_PrimFlagsPredicate
    {
        public Usd_PrimFlagsDisjunction() {}
        public Usd_PrimFlagsDisjunction(pxr.Usd_Term term) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class Usd_PrimFlagsPredicate : System.IDisposable
    {
        protected bool swigCMemOwn;
        public Usd_PrimFlagsPredicate() {}
        public Usd_PrimFlagsPredicate(pxr.Usd_PrimFlags flag) {}
        public Usd_PrimFlagsPredicate(pxr.Usd_Term term) {}
        public static pxr.Usd_PrimFlagsPredicate Contradiction();
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool IncludeInstanceProxiesInTraversal();
        public static pxr.Usd_PrimFlagsPredicate Tautology();
        public pxr.Usd_PrimFlagsPredicate TraverseInstanceProxies(bool traverse);
    }

    public class Usd_Term : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.Usd_PrimFlags flag { get; set; }
        public bool negated { get; set; }
        public Usd_Term(pxr.Usd_PrimFlags flag) {}
        public Usd_Term(pxr.Usd_PrimFlags flag, bool negated) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class UsdAPISchemaBase : pxr.UsdSchemaBase
    {
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdAttribute : pxr.UsdProperty
    {
        public UsdAttribute() {}
        public bool AddConnection(pxr.SdfPath source);
        public bool AddConnection(pxr.SdfPath source, pxr.UsdListPosition position);
        public void Block();
        public bool BlockConnections();
        public bool Clear();
        public bool ClearAtTime(pxr.UsdTimeCode time);
        public bool ClearColorSpace();
        public bool ClearConnections();
        public bool ClearDefault();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtValue Get();
        public pxr.VtValue Get(pxr.UsdTimeCode time);
        public bool Get(pxr.VtValue value, pxr.UsdTimeCode time);
        public bool GetBracketingTimeSamples(double desiredTime, out double lower, out double upper, out double hasTimeSamples);
        public pxr.TfToken GetColorSpace();
        public bool GetConnections(pxr.SdfPathVector sources);
        public System.UInt32 GetNumTimeSamples();
        public pxr.UsdResolveInfo GetResolveInfo();
        public pxr.UsdResolveInfo GetResolveInfo(pxr.UsdTimeCode time);
        public pxr.TfToken GetRoleName();
        public pxr.StdDoubleVector GetTimeSamples();
        public pxr.StdDoubleVector GetTimeSamplesInInterval(pxr.GfInterval interval);
        public pxr.SdfValueTypeName GetTypeName();
        public static bool GetUnionedTimeSamples(pxr.UsdAttributeVector attrs, pxr.StdDoubleVector times);
        public static bool GetUnionedTimeSamplesInInterval(pxr.UsdAttributeVector attrs, pxr.GfInterval interval, pxr.StdDoubleVector times);
        public pxr.SdfVariability GetVariability();
        public bool HasAuthoredConnections();
        public bool HasAuthoredValue();
        public bool HasAuthoredValueOpinion();
        public bool HasColorSpace();
        public bool HasFallbackValue();
        public bool HasValue();
        public bool RemoveConnection(pxr.SdfPath source);
        public bool Set(pxr.VtValue value);
        public bool Set(pxr.VtValue value, pxr.UsdTimeCode time);
        public void SetColorSpace(pxr.TfToken colorSpace);
        public bool SetConnections(pxr.SdfPathVector sources);
        public bool SetTypeName(pxr.SdfValueTypeName typeName);
        public bool SetVariability(pxr.SdfVariability variability);
        public bool ValueMightBeTimeVarying();
    }

    public class UsdAttributeQuery : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdAttributeQuery() {}
        public UsdAttributeQuery(pxr.UsdAttribute attr) {}
        public UsdAttributeQuery(pxr.UsdPrim prim, pxr.TfToken attrName) {}
        public static pxr.UsdAttributeQueryVector CreateQueries(pxr.UsdPrim prim, pxr.TfTokenVector attrNames);
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool Get(pxr.VtValue value);
        public bool Get(pxr.VtValue value, pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetAttribute();
        public bool GetBracketingTimeSamples(double desiredTime, out double lower, out double upper, out double hasTimeSamples);
        public System.UInt32 GetNumTimeSamples();
        public bool GetTimeSamples(pxr.StdDoubleVector times);
        public static bool GetUnionedTimeSamples(pxr.UsdAttributeQueryVector attrQueries, pxr.StdDoubleVector times);
        public static bool GetUnionedTimeSamplesInInterval(pxr.UsdAttributeQueryVector attrQueries, pxr.GfInterval interval, pxr.StdDoubleVector times);
        public bool HasAuthoredValue();
        public bool HasAuthoredValueOpinion();
        public bool HasFallbackValue();
        public bool HasValue();
        public bool IsValid();
        public bool ValueMightBeTimeVarying();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdAttributeQueryVector : System.Collections.Generic.IEnumerable<pxr.UsdAttributeQuery>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdAttributeQuery this[int index] { get; set; }
        public UsdAttributeQueryVector() {}
        public UsdAttributeQueryVector(pxr.UsdAttributeQueryVector other) {}
        public UsdAttributeQueryVector(System.Collections.ICollection c) {}
        public UsdAttributeQueryVector(int capacity) {}
        public void Add(pxr.UsdAttributeQuery x);
        public void AddRange(pxr.UsdAttributeQueryVector values);
        public void Clear();
        public void CopyTo(pxr.UsdAttributeQuery[] array);
        public void CopyTo(pxr.UsdAttributeQuery[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdAttributeQuery[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttributeQueryVector.UsdAttributeQueryVectorEnumerator GetEnumerator();
        public pxr.UsdAttributeQueryVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdAttributeQuery x);
        public void InsertRange(int index, pxr.UsdAttributeQueryVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdAttributeQueryVector Repeat(pxr.UsdAttributeQuery value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdAttributeQueryVector values);
        public sealed class UsdAttributeQueryVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdAttributeQuery>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdAttributeQuery Current { get; }
            public UsdAttributeQueryVectorEnumerator(pxr.UsdAttributeQueryVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdAttributeVector : System.Collections.Generic.IEnumerable<pxr.UsdAttribute>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdAttribute this[int index] { get; set; }
        public UsdAttributeVector() {}
        public UsdAttributeVector(pxr.UsdAttributeVector other) {}
        public UsdAttributeVector(System.Collections.ICollection c) {}
        public UsdAttributeVector(int capacity) {}
        public void Add(pxr.UsdAttribute x);
        public void AddRange(pxr.UsdAttributeVector values);
        public void Clear();
        public void CopyTo(pxr.UsdAttribute[] array);
        public void CopyTo(pxr.UsdAttribute[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdAttribute[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttributeVector.UsdAttributeVectorEnumerator GetEnumerator();
        public pxr.UsdAttributeVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdAttribute x);
        public void InsertRange(int index, pxr.UsdAttributeVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdAttributeVector Repeat(pxr.UsdAttribute value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdAttributeVector values);
        public sealed class UsdAttributeVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdAttribute>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdAttribute Current { get; }
            public UsdAttributeVectorEnumerator(pxr.UsdAttributeVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdClipsAPI : pxr.UsdAPISchemaBase
    {
        public UsdClipsAPI() {}
        public UsdClipsAPI(pxr.UsdPrim prim) {}
        public UsdClipsAPI(pxr.UsdSchemaBase schemaObj) {}
        public pxr.SdfAssetPathArray ComputeClipAssetPaths();
        public pxr.SdfAssetPathArray ComputeClipAssetPaths(string clipSet);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfLayer GenerateClipManifest();
        public pxr.SdfLayer GenerateClipManifest(bool writeBlocksForClipsWithMissingValues);
        public pxr.SdfLayer GenerateClipManifest(string clipSet);
        public pxr.SdfLayer GenerateClipManifest(string clipSet, bool writeBlocksForClipsWithMissingValues);
        public static pxr.SdfLayer GenerateClipManifestFromLayers(pxr.SdfLayerHandleVector clipLayers, pxr.SdfPath clipPrimPath);
        public static pxr.UsdClipsAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public bool GetClipActive(pxr.VtVec2dArray activeClips);
        public bool GetClipActive(pxr.VtVec2dArray activeClips, string clipSet);
        public bool GetClipAssetPaths(pxr.SdfAssetPathArray assetPaths);
        public bool GetClipAssetPaths(pxr.SdfAssetPathArray assetPaths, string clipSet);
        public bool GetClipManifestAssetPath(pxr.SdfAssetPath manifestAssetPath);
        public bool GetClipManifestAssetPath(pxr.SdfAssetPath manifestAssetPath, string clipSet);
        public bool GetClipPrimPath(out string primPath);
        public bool GetClipPrimPath(out string primPath, string clipSet);
        public bool GetClips(pxr.VtDictionary clips);
        public bool GetClipSets(pxr.SdfStringListOp clipSets);
        public bool GetClipTemplateActiveOffset(ref double clipTemplateActiveOffset);
        public bool GetClipTemplateActiveOffset(ref double clipTemplateActiveOffset, string clipSet);
        public bool GetClipTemplateAssetPath(out string clipTemplateAssetPath);
        public bool GetClipTemplateAssetPath(out string clipTemplateAssetPath, string clipSet);
        public bool GetClipTemplateEndTime(ref double clipTemplateEndTime);
        public bool GetClipTemplateEndTime(ref double clipTemplateEndTime, string clipSet);
        public bool GetClipTemplateStartTime(ref double clipTemplateStartTime);
        public bool GetClipTemplateStartTime(ref double clipTemplateStartTime, string clipSet);
        public bool GetClipTemplateStride(ref double clipTemplateStride);
        public bool GetClipTemplateStride(ref double clipTemplateStride, string clipSet);
        public bool GetClipTimes(pxr.VtVec2dArray clipTimes);
        public bool GetClipTimes(pxr.VtVec2dArray clipTimes, string clipSet);
        public bool GetInterpolateMissingClipValues(pxr.SWIGTYPE_p_bool interpolate);
        public bool GetInterpolateMissingClipValues(pxr.SWIGTYPE_p_bool interpolate, string clipSet);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool SetClipActive(pxr.VtVec2dArray activeClips);
        public bool SetClipActive(pxr.VtVec2dArray activeClips, string clipSet);
        public bool SetClipAssetPaths(pxr.SdfAssetPathArray assetPaths);
        public bool SetClipAssetPaths(pxr.SdfAssetPathArray assetPaths, string clipSet);
        public bool SetClipManifestAssetPath(pxr.SdfAssetPath manifestAssetPath);
        public bool SetClipManifestAssetPath(pxr.SdfAssetPath manifestAssetPath, string clipSet);
        public bool SetClipPrimPath(string primPath);
        public bool SetClipPrimPath(string primPath, string clipSet);
        public bool SetClips(pxr.VtDictionary clips);
        public bool SetClipSets(pxr.SdfStringListOp clipSets);
        public bool SetClipTemplateActiveOffset(double clipTemplateActiveOffset);
        public bool SetClipTemplateActiveOffset(double clipTemplateActiveOffset, string clipSet);
        public bool SetClipTemplateAssetPath(string clipTemplateAssetPath);
        public bool SetClipTemplateAssetPath(string clipTemplateAssetPath, string clipSet);
        public bool SetClipTemplateEndTime(double clipTemplateEndTime);
        public bool SetClipTemplateEndTime(double clipTemplateEndTime, string clipSet);
        public bool SetClipTemplateStartTime(double clipTemplateStartTime);
        public bool SetClipTemplateStartTime(double clipTemplateStartTime, string clipSet);
        public bool SetClipTemplateStride(double clipTemplateStride);
        public bool SetClipTemplateStride(double clipTemplateStride, string clipSet);
        public bool SetClipTimes(pxr.VtVec2dArray clipTimes);
        public bool SetClipTimes(pxr.VtVec2dArray clipTimes, string clipSet);
        public bool SetInterpolateMissingClipValues(bool interpolate);
        public bool SetInterpolateMissingClipValues(bool interpolate, string clipSet);
    }

    public class UsdCollectionAPI : pxr.UsdAPISchemaBase
    {
        public UsdCollectionAPI() {}
        public UsdCollectionAPI(pxr.UsdPrim prim) {}
        public UsdCollectionAPI(pxr.UsdPrim prim, pxr.TfToken name) {}
        public UsdCollectionAPI(pxr.UsdSchemaBase schemaObj, pxr.TfToken name) {}
        public static pxr.UsdCollectionAPI ApplyCollection(pxr.UsdPrim prim, pxr.TfToken name);
        public static pxr.UsdCollectionAPI ApplyCollection(pxr.UsdPrim prim, pxr.TfToken name, pxr.TfToken expansionRule);
        public bool BlockCollection();
        public static pxr.UsdObjectVector ComputeIncludedObjects(pxr.SWIGTYPE_p_UsdCollectionMembershipQuery query, pxr.UsdStageWeakPtr stage);
        public static pxr.SWIGTYPE_p_std__setT_SdfPath_t ComputeIncludedPaths(pxr.SWIGTYPE_p_UsdCollectionMembershipQuery query, pxr.UsdStageWeakPtr stage);
        public static pxr.SWIGTYPE_p_std__setT_SdfPath_t ComputeIncludedPaths(pxr.SWIGTYPE_p_UsdCollectionMembershipQuery query, pxr.UsdStageWeakPtr stage, pxr.Usd_PrimFlagsPredicate pred);
        public pxr.SWIGTYPE_p_UsdCollectionMembershipQuery ComputeMembershipQuery();
        public void ComputeMembershipQuery(pxr.SWIGTYPE_p_UsdCollectionMembershipQuery query);
        public pxr.UsdRelationship CreateExcludesRel();
        public pxr.UsdAttribute CreateExpansionRuleAttr();
        public pxr.UsdAttribute CreateExpansionRuleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExpansionRuleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateIncludeRootAttr();
        public pxr.UsdAttribute CreateIncludeRootAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIncludeRootAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdRelationship CreateIncludesRel();
        public virtual void Dispose();
        public bool ExcludePath(pxr.SdfPath pathToExclude);
        protected virtual void Finalize();
        public static pxr.UsdCollectionAPI Get(pxr.UsdPrim prim, pxr.TfToken name);
        public static pxr.UsdCollectionAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.UsdCollectionAPIVector GetAllCollections(pxr.UsdPrim prim);
        public static pxr.UsdCollectionAPI GetCollection(pxr.UsdPrim prim, pxr.TfToken name);
        public static pxr.UsdCollectionAPI GetCollection(pxr.UsdStageWeakPtr stage, pxr.SdfPath collectionPath);
        public pxr.SdfPath GetCollectionPath();
        public pxr.UsdRelationship GetExcludesRel();
        public pxr.UsdAttribute GetExpansionRuleAttr();
        public pxr.UsdAttribute GetIncludeRootAttr();
        public pxr.UsdRelationship GetIncludesRel();
        public pxr.TfToken GetName();
        public static pxr.SdfPath GetNamedCollectionPath(pxr.UsdPrim prim, pxr.TfToken collectionName);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited, pxr.TfToken instanceName);
        public bool HasNoIncludedPaths();
        public bool IncludePath(pxr.SdfPath pathToInclude);
        public static bool IsCollectionAPIPath(pxr.SdfPath path, pxr.TfToken name);
        public static bool IsSchemaPropertyBaseName(pxr.TfToken baseName);
        public bool ResetCollection();
        public bool Validate(out string reason);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdCollectionAPIVector : System.Collections.Generic.IEnumerable<pxr.UsdCollectionAPI>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdCollectionAPI this[int index] { get; set; }
        public UsdCollectionAPIVector() {}
        public UsdCollectionAPIVector(pxr.UsdCollectionAPIVector other) {}
        public UsdCollectionAPIVector(System.Collections.ICollection c) {}
        public UsdCollectionAPIVector(int capacity) {}
        public void Add(pxr.UsdCollectionAPI x);
        public void AddRange(pxr.UsdCollectionAPIVector values);
        public void Clear();
        public void CopyTo(pxr.UsdCollectionAPI[] array);
        public void CopyTo(pxr.UsdCollectionAPI[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdCollectionAPI[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdCollectionAPIVector.UsdCollectionAPIVectorEnumerator GetEnumerator();
        public pxr.UsdCollectionAPIVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdCollectionAPI x);
        public void InsertRange(int index, pxr.UsdCollectionAPIVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdCollectionAPIVector Repeat(pxr.UsdCollectionAPI value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdCollectionAPIVector values);
        public sealed class UsdCollectionAPIVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdCollectionAPI>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdCollectionAPI Current { get; }
            public UsdCollectionAPIVectorEnumerator(pxr.UsdCollectionAPIVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdCs
    {
        public static readonly int JS_VALUE_API_VERSION;
        public static readonly int PXR_USE_NAMESPACES;
        public static readonly int USDGEOM_CYLINDER_API_VERSION;
        public static readonly int USDGEOM_XFORM_CACHE_API_VERSION;
        public static System.UInt32 PCP_INVALID_INDEX { get; }
        public static System.UInt32 Sdf_SizeofPrimPathNode { get; }
        public static System.UInt32 Sdf_SizeofPropPathNode { get; }
        public static pxr.SWIGTYPE_p_TfEnvSettingT_bool_t USD_FORCE_DEFAULT_MATERIALS_SCOPE_NAME { get; set; }
        public static pxr.Usd_PrimFlagsPredicate UsdPrimAllPrimsPredicate { get; }
        public static pxr.Usd_PrimFlagsConjunction UsdPrimDefaultPredicate { get; }
        public static pxr.Usd_PrimFlags UsdPrimHasDefiningSpecifier { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsAbstract { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsActive { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsDefined { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsGroup { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsInstance { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsLoaded { get; }
        public static pxr.Usd_PrimFlags UsdPrimIsModel { get; }
        public UsdCs() {}
        public static pxr.SdfNamespaceEditDetail.Result CombineError(pxr.SdfNamespaceEditDetail.Result arg0);
        public static pxr.SdfNamespaceEditDetail.Result CombineResult(pxr.SdfNamespaceEditDetail.Result lhs, pxr.SdfNamespaceEditDetail.Result rhs);
        public static pxr.SdfNamespaceEditDetail.Result CombineUnbatched(pxr.SdfNamespaceEditDetail.Result other);
        public static string CreateStringFromStringVec(pxr.StdStringVector stringVec);
        public static pxr.VtValue GetFusedDisplayColor(pxr.UsdPrim prim, pxr.UsdTimeCode time);
        public static pxr.VtValue GetFusedTransform(pxr.UsdPrim prim, pxr.UsdTimeCode time);
        public static void GetPathFromVector(pxr.SdfPathVector paths, int index, pxr.SdfPath output);
        public static void GetPrimFromVector(pxr.UsdPrimVector prims, int index, pxr.UsdPrim output);
        public static pxr.TfToken GetRoleFromMetadata(pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static void GfBuildOrthonormalFrame(pxr.GfVec3d v0, pxr.GfVec3d v1, pxr.GfVec3d v2);
        public static void GfBuildOrthonormalFrame(pxr.GfVec3f v0, pxr.GfVec3f v1, pxr.GfVec3f v2);
        public static void GfBuildOrthonormalFrame(pxr.GfVec3h v0, pxr.GfVec3h v1, pxr.GfVec3h v2);
        public static void GfBuildOrthonormalFrame(pxr.GfVec3d v0, pxr.GfVec3d v1, pxr.GfVec3d v2, double eps);
        public static void GfBuildOrthonormalFrame(pxr.GfVec3f v0, pxr.GfVec3f v1, pxr.GfVec3f v2, float eps);
        public static void GfBuildOrthonormalFrame(pxr.GfVec3h v0, pxr.GfVec3h v1, pxr.GfVec3h v2, pxr.GfHalf eps);
        public static pxr.GfVec2d GfCompDiv(pxr.GfVec2d v1, pxr.GfVec2d v2);
        public static pxr.GfVec2f GfCompDiv(pxr.GfVec2f v1, pxr.GfVec2f v2);
        public static pxr.GfVec2h GfCompDiv(pxr.GfVec2h v1, pxr.GfVec2h v2);
        public static pxr.GfVec2i GfCompDiv(pxr.GfVec2i v1, pxr.GfVec2i v2);
        public static pxr.GfVec3d GfCompDiv(pxr.GfVec3d v1, pxr.GfVec3d v2);
        public static pxr.GfVec3f GfCompDiv(pxr.GfVec3f v1, pxr.GfVec3f v2);
        public static pxr.GfVec3h GfCompDiv(pxr.GfVec3h v1, pxr.GfVec3h v2);
        public static pxr.GfVec3i GfCompDiv(pxr.GfVec3i v1, pxr.GfVec3i v2);
        public static pxr.GfVec4d GfCompDiv(pxr.GfVec4d v1, pxr.GfVec4d v2);
        public static pxr.GfVec4f GfCompDiv(pxr.GfVec4f v1, pxr.GfVec4f v2);
        public static pxr.GfVec4h GfCompDiv(pxr.GfVec4h v1, pxr.GfVec4h v2);
        public static pxr.GfVec4i GfCompDiv(pxr.GfVec4i v1, pxr.GfVec4i v2);
        public static pxr.GfVec2d GfCompMult(pxr.GfVec2d v1, pxr.GfVec2d v2);
        public static pxr.GfVec2f GfCompMult(pxr.GfVec2f v1, pxr.GfVec2f v2);
        public static pxr.GfVec2h GfCompMult(pxr.GfVec2h v1, pxr.GfVec2h v2);
        public static pxr.GfVec2i GfCompMult(pxr.GfVec2i v1, pxr.GfVec2i v2);
        public static pxr.GfVec3d GfCompMult(pxr.GfVec3d v1, pxr.GfVec3d v2);
        public static pxr.GfVec3f GfCompMult(pxr.GfVec3f v1, pxr.GfVec3f v2);
        public static pxr.GfVec3h GfCompMult(pxr.GfVec3h v1, pxr.GfVec3h v2);
        public static pxr.GfVec3i GfCompMult(pxr.GfVec3i v1, pxr.GfVec3i v2);
        public static pxr.GfVec4d GfCompMult(pxr.GfVec4d v1, pxr.GfVec4d v2);
        public static pxr.GfVec4f GfCompMult(pxr.GfVec4f v1, pxr.GfVec4f v2);
        public static pxr.GfVec4h GfCompMult(pxr.GfVec4h v1, pxr.GfVec4h v2);
        public static pxr.GfVec4i GfCompMult(pxr.GfVec4i v1, pxr.GfVec4i v2);
        public static pxr.GfVec3d GfCross(pxr.GfVec3d v1, pxr.GfVec3d v2);
        public static pxr.GfVec3f GfCross(pxr.GfVec3f v1, pxr.GfVec3f v2);
        public static pxr.GfVec3h GfCross(pxr.GfVec3h v1, pxr.GfVec3h v2);
        public static pxr.GfHalf GfDot(pxr.GfVec2h v1, pxr.GfVec2h v2);
        public static pxr.GfHalf GfDot(pxr.GfVec3h v1, pxr.GfVec3h v2);
        public static pxr.GfHalf GfDot(pxr.GfVec4h v1, pxr.GfVec4h v2);
        public static double GfDot(pxr.GfQuatd q1, pxr.GfQuatd q2);
        public static double GfDot(pxr.GfVec2d v1, pxr.GfVec2d v2);
        public static double GfDot(pxr.GfVec3d v1, pxr.GfVec3d v2);
        public static double GfDot(pxr.GfVec4d v1, pxr.GfVec4d v2);
        public static int GfDot(pxr.GfVec2i v1, pxr.GfVec2i v2);
        public static int GfDot(pxr.GfVec3i v1, pxr.GfVec3i v2);
        public static int GfDot(pxr.GfVec4i v1, pxr.GfVec4i v2);
        public static float GfDot(pxr.GfQuatf q1, pxr.GfQuatf q2);
        public static float GfDot(pxr.GfVec2f v1, pxr.GfVec2f v2);
        public static float GfDot(pxr.GfVec3f v1, pxr.GfVec3f v2);
        public static float GfDot(pxr.GfVec4f v1, pxr.GfVec4f v2);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLine line);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLineSeg seg);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLine line, pxr.GfVec3d rayPoint);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLineSeg seg, pxr.GfVec3d rayPoint);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLine line, pxr.GfVec3d rayPoint, pxr.GfVec3d linePoint);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLineSeg seg, pxr.GfVec3d rayPoint, pxr.GfVec3d segPoint);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLine line, pxr.GfVec3d rayPoint, pxr.GfVec3d linePoint, out double rayDistance);
        public static bool GfFindClosestPoints(pxr.GfRay ray, pxr.GfLineSeg seg, pxr.GfVec3d rayPoint, pxr.GfVec3d segPoint, out double rayDistance);
        public static bool GfFindClosestPoints(pxr.GfRay arg0, pxr.GfLine arg1, pxr.GfVec3d arg2, pxr.GfVec3d arg3, pxr.SWIGTYPE_p_double arg4, pxr.SWIGTYPE_p_double arg5);
        public static bool GfFindClosestPoints(pxr.GfRay arg0, pxr.GfLineSeg arg1, pxr.GfVec3d arg2, pxr.GfVec3d arg3, pxr.SWIGTYPE_p_double arg4, pxr.SWIGTYPE_p_double arg5);
        public static bool GfFitPlaneToPoints(pxr.GfVec3dVector points, pxr.GfPlane fitPlane);
        public static pxr.GfVec2d GfGetComplement(pxr.GfVec2d a, pxr.GfVec2d b);
        public static pxr.GfVec2f GfGetComplement(pxr.GfVec2f a, pxr.GfVec2f b);
        public static pxr.GfVec2h GfGetComplement(pxr.GfVec2h a, pxr.GfVec2h b);
        public static pxr.GfVec3d GfGetComplement(pxr.GfVec3d a, pxr.GfVec3d b);
        public static pxr.GfVec3f GfGetComplement(pxr.GfVec3f a, pxr.GfVec3f b);
        public static pxr.GfVec3h GfGetComplement(pxr.GfVec3h a, pxr.GfVec3h b);
        public static pxr.GfVec4d GfGetComplement(pxr.GfVec4d a, pxr.GfVec4d b);
        public static pxr.GfVec4f GfGetComplement(pxr.GfVec4f a, pxr.GfVec4f b);
        public static pxr.GfVec4h GfGetComplement(pxr.GfVec4h a, pxr.GfVec4h b);
        public static pxr.GfHalf GfGetLength(pxr.GfVec2h v);
        public static pxr.GfHalf GfGetLength(pxr.GfVec3h v);
        public static pxr.GfHalf GfGetLength(pxr.GfVec4h v);
        public static double GfGetLength(pxr.GfVec2d v);
        public static double GfGetLength(pxr.GfVec3d v);
        public static double GfGetLength(pxr.GfVec4d v);
        public static float GfGetLength(pxr.GfVec2f v);
        public static float GfGetLength(pxr.GfVec3f v);
        public static float GfGetLength(pxr.GfVec4f v);
        public static pxr.GfVec2d GfGetNormalized(pxr.GfVec2d v);
        public static pxr.GfVec2f GfGetNormalized(pxr.GfVec2f v);
        public static pxr.GfVec2h GfGetNormalized(pxr.GfVec2h v);
        public static pxr.GfVec3d GfGetNormalized(pxr.GfVec3d v);
        public static pxr.GfVec3f GfGetNormalized(pxr.GfVec3f v);
        public static pxr.GfVec3h GfGetNormalized(pxr.GfVec3h v);
        public static pxr.GfVec4d GfGetNormalized(pxr.GfVec4d v);
        public static pxr.GfVec4f GfGetNormalized(pxr.GfVec4f v);
        public static pxr.GfVec4h GfGetNormalized(pxr.GfVec4h v);
        public static pxr.GfVec2d GfGetNormalized(pxr.GfVec2d v, double eps);
        public static pxr.GfVec2f GfGetNormalized(pxr.GfVec2f v, float eps);
        public static pxr.GfVec2h GfGetNormalized(pxr.GfVec2h v, pxr.GfHalf eps);
        public static pxr.GfVec3d GfGetNormalized(pxr.GfVec3d v, double eps);
        public static pxr.GfVec3f GfGetNormalized(pxr.GfVec3f v, float eps);
        public static pxr.GfVec3h GfGetNormalized(pxr.GfVec3h v, pxr.GfHalf eps);
        public static pxr.GfVec4d GfGetNormalized(pxr.GfVec4d v, double eps);
        public static pxr.GfVec4f GfGetNormalized(pxr.GfVec4f v, float eps);
        public static pxr.GfVec4h GfGetNormalized(pxr.GfVec4h v, pxr.GfHalf eps);
        public static pxr.GfVec2d GfGetProjection(pxr.GfVec2d a, pxr.GfVec2d b);
        public static pxr.GfVec2f GfGetProjection(pxr.GfVec2f a, pxr.GfVec2f b);
        public static pxr.GfVec2h GfGetProjection(pxr.GfVec2h a, pxr.GfVec2h b);
        public static pxr.GfVec3d GfGetProjection(pxr.GfVec3d a, pxr.GfVec3d b);
        public static pxr.GfVec3f GfGetProjection(pxr.GfVec3f a, pxr.GfVec3f b);
        public static pxr.GfVec3h GfGetProjection(pxr.GfVec3h a, pxr.GfVec3h b);
        public static pxr.GfVec4d GfGetProjection(pxr.GfVec4d a, pxr.GfVec4d b);
        public static pxr.GfVec4f GfGetProjection(pxr.GfVec4f a, pxr.GfVec4f b);
        public static pxr.GfVec4h GfGetProjection(pxr.GfVec4h a, pxr.GfVec4h b);
        public static bool GfIsClose(pxr.GfMatrix2d m1, pxr.GfMatrix2d m2, double tolerance);
        public static bool GfIsClose(pxr.GfMatrix2f m1, pxr.GfMatrix2f m2, double tolerance);
        public static bool GfIsClose(pxr.GfMatrix3d m1, pxr.GfMatrix3d m2, double tolerance);
        public static bool GfIsClose(pxr.GfMatrix3f m1, pxr.GfMatrix3f m2, double tolerance);
        public static bool GfIsClose(pxr.GfMatrix4d m1, pxr.GfMatrix4d m2, double tolerance);
        public static bool GfIsClose(pxr.GfMatrix4f m1, pxr.GfMatrix4f m2, double tolerance);
        public static bool GfIsClose(pxr.GfVec2d v1, pxr.GfVec2d v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec2f v1, pxr.GfVec2f v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec2h v1, pxr.GfVec2h v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec3d v1, pxr.GfVec3d v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec3f v1, pxr.GfVec3f v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec3h v1, pxr.GfVec3h v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec4d v1, pxr.GfVec4d v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec4f v1, pxr.GfVec4f v2, double tolerance);
        public static bool GfIsClose(pxr.GfVec4h v1, pxr.GfVec4h v2, double tolerance);
        public static pxr.GfHalf GfNormalize(pxr.GfVec2h v);
        public static pxr.GfHalf GfNormalize(pxr.GfVec3h v);
        public static pxr.GfHalf GfNormalize(pxr.GfVec4h v);
        public static double GfNormalize(pxr.GfVec2d v);
        public static double GfNormalize(pxr.GfVec3d v);
        public static double GfNormalize(pxr.GfVec4d v);
        public static float GfNormalize(pxr.GfVec2f v);
        public static float GfNormalize(pxr.GfVec3f v);
        public static float GfNormalize(pxr.GfVec4f v);
        public static pxr.GfHalf GfNormalize(pxr.GfVec2h v, pxr.GfHalf eps);
        public static pxr.GfHalf GfNormalize(pxr.GfVec3h v, pxr.GfHalf eps);
        public static pxr.GfHalf GfNormalize(pxr.GfVec4h v, pxr.GfHalf eps);
        public static double GfNormalize(pxr.GfVec2d v, double eps);
        public static double GfNormalize(pxr.GfVec3d v, double eps);
        public static double GfNormalize(pxr.GfVec4d v, double eps);
        public static float GfNormalize(pxr.GfVec2f v, float eps);
        public static float GfNormalize(pxr.GfVec3f v, float eps);
        public static float GfNormalize(pxr.GfVec4f v, float eps);
        public static bool GfOrthogonalizeBasis(pxr.GfVec3d tx, pxr.GfVec3d ty, pxr.GfVec3d tz, bool normalize);
        public static bool GfOrthogonalizeBasis(pxr.GfVec3f tx, pxr.GfVec3f ty, pxr.GfVec3f tz, bool normalize);
        public static bool GfOrthogonalizeBasis(pxr.GfVec3h tx, pxr.GfVec3h ty, pxr.GfVec3h tz, bool normalize);
        public static bool GfOrthogonalizeBasis(pxr.GfVec3d tx, pxr.GfVec3d ty, pxr.GfVec3d tz, bool normalize, double eps);
        public static bool GfOrthogonalizeBasis(pxr.GfVec3f tx, pxr.GfVec3f ty, pxr.GfVec3f tz, bool normalize, double eps);
        public static bool GfOrthogonalizeBasis(pxr.GfVec3h tx, pxr.GfVec3h ty, pxr.GfVec3h tz, bool normalize, double eps);
        public static pxr.GfQuatd GfSlerp(pxr.GfQuatd q0, pxr.GfQuatd q1, double alpha);
        public static pxr.GfQuatd GfSlerp(double alpha, pxr.GfQuatd q0, pxr.GfQuatd q1);
        public static pxr.GfQuaternion GfSlerp(pxr.GfQuaternion q0, pxr.GfQuaternion q1, double alpha);
        public static pxr.GfQuaternion GfSlerp(double alpha, pxr.GfQuaternion q0, pxr.GfQuaternion q1);
        public static pxr.GfQuatf GfSlerp(pxr.GfQuatf q0, pxr.GfQuatf q1, double alpha);
        public static pxr.GfQuatf GfSlerp(double alpha, pxr.GfQuatf q0, pxr.GfQuatf q1);
        public static pxr.GfVec3d GfSlerp(double alpha, pxr.GfVec3d v0, pxr.GfVec3d v1);
        public static pxr.GfVec3f GfSlerp(double alpha, pxr.GfVec3f v0, pxr.GfVec3f v1);
        public static pxr.GfVec3h GfSlerp(double alpha, pxr.GfVec3h v0, pxr.GfVec3h v1);
        public static System.UInt32 hash_value(pxr.ArResolverContext context);
        public static System.UInt32 hash_value(pxr.GfBBox3d b);
        public static System.UInt32 hash_value(pxr.GfFrustum f);
        public static System.UInt32 hash_value(pxr.GfInterval i);
        public static System.UInt32 hash_value(pxr.GfMatrix2d m);
        public static System.UInt32 hash_value(pxr.GfMatrix2f m);
        public static System.UInt32 hash_value(pxr.GfMatrix3d m);
        public static System.UInt32 hash_value(pxr.GfMatrix3f m);
        public static System.UInt32 hash_value(pxr.GfMatrix4d m);
        public static System.UInt32 hash_value(pxr.GfMatrix4f m);
        public static System.UInt32 hash_value(pxr.GfQuatd q);
        public static System.UInt32 hash_value(pxr.GfQuaternion q);
        public static System.UInt32 hash_value(pxr.GfQuatf q);
        public static System.UInt32 hash_value(pxr.GfRange1d r);
        public static System.UInt32 hash_value(pxr.GfRange1f r);
        public static System.UInt32 hash_value(pxr.GfRange2d r);
        public static System.UInt32 hash_value(pxr.GfRange3d r);
        public static System.UInt32 hash_value(pxr.GfRotation r);
        public static System.UInt32 hash_value(pxr.GfVec2d vec);
        public static System.UInt32 hash_value(pxr.GfVec2f vec);
        public static System.UInt32 hash_value(pxr.GfVec2h vec);
        public static System.UInt32 hash_value(pxr.GfVec2i vec);
        public static System.UInt32 hash_value(pxr.GfVec3d vec);
        public static System.UInt32 hash_value(pxr.GfVec3f vec);
        public static System.UInt32 hash_value(pxr.GfVec3h vec);
        public static System.UInt32 hash_value(pxr.GfVec3i vec);
        public static System.UInt32 hash_value(pxr.GfVec4d vec);
        public static System.UInt32 hash_value(pxr.GfVec4f vec);
        public static System.UInt32 hash_value(pxr.GfVec4h vec);
        public static System.UInt32 hash_value(pxr.GfVec4i vec);
        public static System.UInt32 hash_value(pxr.PcpLayerStackIdentifier x);
        public static System.UInt32 hash_value(pxr.PcpLayerStackIdentifierStr x);
        public static System.UInt32 hash_value(pxr.PcpNodeRef x);
        public static System.UInt32 hash_value(pxr.SdfAssetPath ap);
        public static System.UInt32 hash_value(pxr.SdfHumanReadableValue hrval);
        public static System.UInt32 hash_value(pxr.SdfInt64ListOp op);
        public static System.UInt32 hash_value(pxr.SdfIntListOp op);
        public static System.UInt32 hash_value(pxr.SdfLayerOffset offset);
        public static System.UInt32 hash_value(pxr.SdfPath path);
        public static System.UInt32 hash_value(pxr.SdfPathListOp op);
        public static System.UInt32 hash_value(pxr.SdfPayload p);
        public static System.UInt32 hash_value(pxr.SdfReference r);
        public static System.UInt32 hash_value(pxr.SdfReferenceListOp op);
        public static System.UInt32 hash_value(pxr.SdfSpec x);
        public static System.UInt32 hash_value(pxr.SdfStringListOp op);
        public static System.UInt32 hash_value(pxr.SdfTimeCode ap);
        public static System.UInt32 hash_value(pxr.SdfTokenListOp op);
        public static System.UInt32 hash_value(pxr.SdfUInt64ListOp op);
        public static System.UInt32 hash_value(pxr.SdfUIntListOp op);
        public static System.UInt32 hash_value(pxr.SdfUnregisteredValue uv);
        public static System.UInt32 hash_value(pxr.SdfUnregisteredValueListOp op);
        public static System.UInt32 hash_value(pxr.SdfValueBlock block);
        public static System.UInt32 hash_value(pxr.SdfValueTypeName typeName);
        public static System.UInt32 hash_value(pxr.TfToken x);
        public static System.UInt32 hash_value(pxr.Usd_PrimFlagsPredicate p);
        public static System.UInt32 hash_value(pxr.UsdGeomPrimvar obj);
        public static System.UInt32 hash_value(pxr.UsdObject obj);
        public static System.UInt32 hash_value(pxr.UsdSkelAnimQuery query);
        public static System.UInt32 hash_value(pxr.UsdSkelSkeletonQuery query);
        public static System.UInt32 hash_value(pxr.UsdStageLoadRules arg0);
        public static System.UInt32 hash_value(pxr.UsdStagePopulationMask arg0);
        public static System.UInt32 hash_value(pxr.UsdTimeCode time);
        public static System.UInt32 hash_value(pxr.VtDictionary dict);
        public static System.UInt32 hash_value(pxr.VtValue val);
        public static void intrusive_ptr_add_ref(pxr.SWIGTYPE_p_Sdf_PathNode arg0);
        public static void intrusive_ptr_release(pxr.SWIGTYPE_p_Sdf_PathNode arg0);
        public static bool IsPropertyAnAssetIdentifier(pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static bool IsPropertyATerminal(pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static bool IsTruthy(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static pxr.NdrNodeDiscoveryResultVector NdrFsHelpersDiscoverNodes(pxr.StdStringVector searchPaths, pxr.StdStringVector allowedExtensions);
        public static pxr.NdrNodeDiscoveryResultVector NdrFsHelpersDiscoverNodes(pxr.StdStringVector searchPaths, pxr.StdStringVector allowedExtensions, bool followSymlinks);
        public static pxr.NdrNodeDiscoveryResultVector NdrFsHelpersDiscoverNodes(pxr.StdStringVector searchPaths, pxr.StdStringVector allowedExtensions, bool followSymlinks, pxr.NdrDiscoveryPluginContext context);
        public static string NdrGetIdentifierString(pxr.TfToken id);
        public static pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_TfToken_t_t OptionVecVal(string optionStr);
        public static void PcpBuildPrimPropertyIndex(pxr.SdfPath propertyPath, pxr.PcpCache cache, pxr.PcpPrimIndex owningPrimIndex, pxr.PcpPropertyIndex propertyIndex, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public static void PcpBuildPropertyIndex(pxr.SdfPath propertyPath, pxr.PcpCache cache, pxr.PcpPropertyIndex propertyIndex, pxr.SWIGTYPE_p_PcpErrorVector allErrors);
        public static void PcpComputePrimIndex(pxr.SdfPath primPath, pxr.PcpLayerStackPtr layerStack, pxr.SWIGTYPE_p_PcpPrimIndexInputs inputs, pxr.SWIGTYPE_p_PcpPrimIndexOutputs outputs);
        public static void PcpComputePrimIndex(pxr.SdfPath primPath, pxr.PcpLayerStackPtr layerStack, pxr.SWIGTYPE_p_PcpPrimIndexInputs inputs, pxr.SWIGTYPE_p_PcpPrimIndexOutputs outputs, pxr.SWIGTYPE_p_ArResolver pathResolver);
        public static pxr.SWIGTYPE_p_std__ostream PcpIdentifierFormatBaseName(pxr.SWIGTYPE_p_std__ostream arg0);
        public static pxr.SWIGTYPE_p_std__ostream PcpIdentifierFormatIdentifier(pxr.SWIGTYPE_p_std__ostream arg0);
        public static pxr.SWIGTYPE_p_std__ostream PcpIdentifierFormatRealPath(pxr.SWIGTYPE_p_std__ostream arg0);
        public static bool PcpIsClassBasedArc(pxr.PcpArcType arcType);
        public static bool PcpIsInheritArc(pxr.PcpArcType arcType);
        public static bool PcpIsNewDefaultStandinBehaviorEnabled();
        public static bool PcpIsSpecializeArc(pxr.PcpArcType arcType);
        public static bool PcpIsTimeScalingForLayerTimeCodesPerSecondDisabled();
        public static string PlugFindPluginResource(pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__Ptr plugin, string path);
        public static string PlugFindPluginResource(pxr.SWIGTYPE_p_TfDeclarePtrsT_PlugPlugin_t__Ptr plugin, string path, bool verify);
        public static bool SdfConvertToValidMetadataDictionary(pxr.VtDictionary dict, pxr.SWIGTYPE_p_std__string errMsg);
        public static double SdfConvertUnit(pxr.SWIGTYPE_p_TfEnum fromUnit, pxr.SWIGTYPE_p_TfEnum toUnit);
        public static pxr.SdfPrimSpecHandle SdfCreatePrimInLayer(pxr.SdfLayerHandle layer, pxr.SdfPath primPath);
        public static pxr.SWIGTYPE_p_TfEnum SdfDefaultUnit(pxr.SWIGTYPE_p_TfEnum unit);
        public static pxr.SWIGTYPE_p_TfEnum SdfDefaultUnit(pxr.TfToken typeName);
        public static int SdfFindReferenceByIdentity(pxr.StdReferenceVector references, pxr.SdfReference referenceId);
        public static string SdfGetNameForUnit(pxr.SWIGTYPE_p_TfEnum unit);
        public static pxr.TfToken SdfGetRoleNameForValueTypeName(pxr.TfToken typeName);
        public static pxr.TfType SdfGetTypeForValueTypeName(pxr.TfToken name);
        public static pxr.SWIGTYPE_p_TfEnum SdfGetUnitFromName(string name);
        public static pxr.SdfValueTypeName SdfGetValueTypeAsset();
        public static pxr.SdfValueTypeName SdfGetValueTypeAssetArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeBool();
        public static pxr.SdfValueTypeName SdfGetValueTypeBoolArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor3d();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor3dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor3f();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor3fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor3h();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor3hArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor4d();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor4dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor4f();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor4fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor4h();
        public static pxr.SdfValueTypeName SdfGetValueTypeColor4hArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble2();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble2Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble3();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble3Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble4();
        public static pxr.SdfValueTypeName SdfGetValueTypeDouble4Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeDoubleArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat2();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat2Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat3();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat3Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat4();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloat4Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeFloatArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeFrame4d();
        public static pxr.SdfValueTypeName SdfGetValueTypeFrame4dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf2();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf2Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf3();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf3Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf4();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalf4Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeHalfArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt2();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt2Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt3();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt3Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt4();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt4Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt64();
        public static pxr.SdfValueTypeName SdfGetValueTypeInt64Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeIntArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeMatrix2d();
        public static pxr.SdfValueTypeName SdfGetValueTypeMatrix2dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeMatrix3d();
        public static pxr.SdfValueTypeName SdfGetValueTypeMatrix3dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeMatrix4d();
        public static pxr.SdfValueTypeName SdfGetValueTypeMatrix4dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeNameForValue(pxr.VtValue value);
        public static pxr.SdfValueTypeName SdfGetValueTypeNormal3d();
        public static pxr.SdfValueTypeName SdfGetValueTypeNormal3dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeNormal3f();
        public static pxr.SdfValueTypeName SdfGetValueTypeNormal3fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeNormal3h();
        public static pxr.SdfValueTypeName SdfGetValueTypeNormal3hArray();
        public static pxr.SdfValueTypeName SdfGetValueTypePoint3d();
        public static pxr.SdfValueTypeName SdfGetValueTypePoint3dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypePoint3f();
        public static pxr.SdfValueTypeName SdfGetValueTypePoint3fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypePoint3h();
        public static pxr.SdfValueTypeName SdfGetValueTypePoint3hArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeQuatd();
        public static pxr.SdfValueTypeName SdfGetValueTypeQuatdArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeQuatf();
        public static pxr.SdfValueTypeName SdfGetValueTypeQuatfArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeQuath();
        public static pxr.SdfValueTypeName SdfGetValueTypeQuathArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeString();
        public static pxr.SdfValueTypeName SdfGetValueTypeStringArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord2d();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord2dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord2f();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord2fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord2h();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord2hArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord3d();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord3dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord3f();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord3fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord3h();
        public static pxr.SdfValueTypeName SdfGetValueTypeTexCoord3hArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeTimeCode();
        public static pxr.SdfValueTypeName SdfGetValueTypeTimeCodeArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeToken();
        public static pxr.SdfValueTypeName SdfGetValueTypeTokenArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeUChar();
        public static pxr.SdfValueTypeName SdfGetValueTypeUCharArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeUInt();
        public static pxr.SdfValueTypeName SdfGetValueTypeUInt64();
        public static pxr.SdfValueTypeName SdfGetValueTypeUInt64Array();
        public static pxr.SdfValueTypeName SdfGetValueTypeUIntArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeVector3d();
        public static pxr.SdfValueTypeName SdfGetValueTypeVector3dArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeVector3f();
        public static pxr.SdfValueTypeName SdfGetValueTypeVector3fArray();
        public static pxr.SdfValueTypeName SdfGetValueTypeVector3h();
        public static pxr.SdfValueTypeName SdfGetValueTypeVector3hArray();
        public static bool SdfIsDefiningSpecifier(pxr.SdfSpecifier spec);
        public static bool SdfJustCreatePrimAttributeInLayer(pxr.SdfLayerHandle layer, pxr.SdfPath attrPath, pxr.SdfValueTypeName typeName);
        public static bool SdfJustCreatePrimAttributeInLayer(pxr.SdfLayerHandle layer, pxr.SdfPath attrPath, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability);
        public static bool SdfJustCreatePrimAttributeInLayer(pxr.SdfLayerHandle layer, pxr.SdfPath attrPath, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability, bool isCustom);
        public static bool SdfJustCreatePrimInLayer(pxr.SdfLayerHandle layer, pxr.SdfPath primPath);
        public static pxr.SWIGTYPE_p_std__setT_SdfPath_t__const_iterator SdfPathFindLongestPrefix(pxr.SWIGTYPE_p_std__setT_SdfPath_t set, pxr.SdfPath path);
        public static pxr.SWIGTYPE_p_std__setT_SdfPath_t__const_iterator SdfPathFindLongestStrictPrefix(pxr.SWIGTYPE_p_std__setT_SdfPath_t set, pxr.SdfPath path);
        public static string SdfUnitCategory(pxr.SWIGTYPE_p_TfEnum unit);
        public static bool SdfValueHasValidType(pxr.VtValue value);
        public static void SetEnv(string name, string value);
        public static bool SetFusedDisplayColor(pxr.UsdPrim prim, pxr.VtVec4fArray values, pxr.UsdTimeCode time);
        public static string StringVal(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static string StringVal(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, string defaultValue);
        public static pxr.StdStringVector StringVecVal(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static void swap(pxr.PcpPrimIndex l, pxr.PcpPrimIndex r);
        public static void swap(pxr.SdfAssetPath lhs, pxr.SdfAssetPath rhs);
        public static void swap(pxr.SdfPath lhs, pxr.SdfPath rhs);
        public static void swap(pxr.SdfTimeCode lhs, pxr.SdfTimeCode rhs);
        public static void swap(pxr.SWIGTYPE_p_PcpPrimIndexOutputs l, pxr.SWIGTYPE_p_PcpPrimIndexOutputs r);
        public static void swap(pxr.TfToken lhs, pxr.TfToken rhs);
        public static void swap(pxr.UsdStageCache lhs, pxr.UsdStageCache rhs);
        public static void swap(pxr.UsdStageLoadRules l, pxr.UsdStageLoadRules r);
        public static void swap(pxr.UsdStagePopulationMask l, pxr.UsdStagePopulationMask r);
        public static void swap(pxr.VtDictionary lhs, pxr.VtDictionary rhs);
        public static void swap(pxr.VtValue lhs, pxr.VtValue rhs);
        public static bool Tf_StringEndsWithImpl(string s, System.UInt32 slen, string suffix, System.UInt32 suflen);
        public static bool Tf_StringStartsWithImpl(string s, System.UInt32 slen, string prefix, System.UInt32 prelen);
        public static bool TfDoubleToString(double d, string buffer, int len, bool emitTrailingZero);
        public static string TfEscapeString(string arg0);
        public static void TfEscapeStringReplaceChar(pxr.SWIGTYPE_p_p_char arg0, pxr.SWIGTYPE_p_p_char arg1);
        public static string TfGetBaseName(string fileName);
        public static string TfGetPathName(string fileName);
        public static string TfGetXmlEscapedString(string arg0);
        public static System.UInt32 TfHashValue(pxr.TfToken x);
        public static string TfIntToString(int i);
        public static bool TfIsValidIdentifier(string identifier);
        public static string TfMakeValidIdentifier(string arg0);
        public static pxr.StdStringVector TfMatchedStringTokenize(string source, char openDelimiter, char closeDelimiter);
        public static pxr.StdStringVector TfMatchedStringTokenize(string source, char openDelimiter, char closeDelimiter, pxr.SWIGTYPE_p_std__string errors);
        public static pxr.StdStringVector TfMatchedStringTokenize(string source, char openDelimiter, char closeDelimiter, char escapeCharacter);
        public static pxr.StdStringVector TfMatchedStringTokenize(string source, char openDelimiter, char closeDelimiter, char escapeCharacter, pxr.SWIGTYPE_p_std__string errors);
        public static pxr.StdStringVector TfQuotedStringTokenize(string source);
        public static pxr.StdStringVector TfQuotedStringTokenize(string source, string delimiters);
        public static pxr.StdStringVector TfQuotedStringTokenize(string source, string delimiters, pxr.SWIGTYPE_p_std__string errors);
        public static string TfSafeString(string ptr);
        public static string TfStringCapitalize(string source);
        public static string TfStringCatPaths(string prefix, string suffix);
        public static bool TfStringContains(string s, pxr.TfToken substring);
        public static bool TfStringContains(string s, string substring);
        public static bool TfStringEndsWith(string s, pxr.TfToken suffix);
        public static bool TfStringEndsWith(string s, string suffix);
        public static string TfStringGetBeforeSuffix(string name);
        public static string TfStringGetBeforeSuffix(string name, char delimiter);
        public static string TfStringGetCommonPrefix(string a, string b);
        public static string TfStringGetSuffix(string name);
        public static string TfStringGetSuffix(string name, char delimiter);
        public static string TfStringGlobToRegex(string s);
        public static string TfStringify(bool v);
        public static string TfStringify(double arg0);
        public static string TfStringify(float arg0);
        public static string TfStringify(string arg0);
        public static string TfStringJoin(pxr.StdStringVector strings);
        public static string TfStringJoin(pxr.SWIGTYPE_p_std__setT_std__string_t strings);
        public static string TfStringJoin(pxr.StdStringVector strings, string separator);
        public static string TfStringJoin(pxr.SWIGTYPE_p_std__setT_std__string_t strings, string separator);
        public static string TfStringPrintf(string fmt);
        public static string TfStringReplace(string source, string from, string to);
        public static pxr.StdStringVector TfStringSplit(string src, string separator);
        public static bool TfStringStartsWith(string s, pxr.TfToken prefix);
        public static bool TfStringStartsWith(string s, string prefix);
        public static double TfStringToDouble(string txt);
        public static long TfStringToInt64(string txt);
        public static long TfStringToInt64(string txt, ref bool outOfRange);
        public static pxr.StdStringVector TfStringTokenize(string source);
        public static pxr.StdStringVector TfStringTokenize(string source, string delimiters);
        public static pxr.SWIGTYPE_p_std__setT_std__string_t TfStringTokenizeToSet(string source);
        public static pxr.SWIGTYPE_p_std__setT_std__string_t TfStringTokenizeToSet(string source, string delimiters);
        public static int TfStringToLong(string txt);
        public static int TfStringToLong(string txt, ref bool outOfRange);
        public static string TfStringToLower(string source);
        public static System.UInt64 TfStringToUInt64(string txt);
        public static System.UInt64 TfStringToUInt64(string txt, ref bool outOfRange);
        public static System.UInt32 TfStringToULong(string txt);
        public static System.UInt32 TfStringToULong(string txt, ref bool outOfRange);
        public static string TfStringToUpper(string source);
        public static string TfStringTrim(string s);
        public static string TfStringTrim(string s, string trimChars);
        public static string TfStringTrimLeft(string s);
        public static string TfStringTrimLeft(string s, string trimChars);
        public static string TfStringTrimRight(string s);
        public static string TfStringTrimRight(string s, string trimChars);
        public static pxr.StdStringVector TfToStringVector(pxr.TfTokenVector tv);
        public static pxr.TfTokenVector TfToTokenVector(pxr.StdStringVector sv);
        public static pxr.TfToken TokenVal(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static pxr.TfToken TokenVal(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata, pxr.TfToken defaultValue);
        public static pxr.TfTokenVector TokenVecVal(pxr.TfToken propName, pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t metadata);
        public static pxr.UsdObjType Usd_GetObjType(pxr.UsdObject obj);
        public static string UsdDescribe(pxr.UsdObject arg0);
        public static string UsdDescribe(pxr.UsdStage arg0);
        public static string UsdDescribe(pxr.UsdStageCache arg0);
        public static string UsdDescribe(pxr.UsdStageWeakPtr arg0);
        public static bool UsdGeomPointInstancerApplyNewStyleListOps();
        public static bool UsdGeomPointInstancerSetOrMergeOverOp(pxr.UsdGeomLongVector items, pxr.SdfListOpType op, pxr.UsdPrim prim, pxr.TfToken metadataName);
        public static bool UsdIsConcrete(pxr.UsdObjType type);
        public static bool UsdIsConvertible(pxr.UsdObjType from, pxr.UsdObjType to);
        public static bool UsdIsSubtype(pxr.UsdObjType baseType, pxr.UsdObjType subType);
        public static pxr.GfVec3f UsdLuxBlackbodyTemperatureAsRgb(float colorTemp);
        public static pxr.TfToken UsdRiConvertFromRManFaceVaryingLinearInterpolation(int i);
        public static pxr.TfToken UsdRiConvertFromRManInterpolateBoundary(int i);
        public static pxr.TfToken UsdRiConvertFromRManTriangleSubdivisionRule(int i);
        public static int UsdRiConvertToRManFaceVaryingLinearInterpolation(pxr.TfToken token);
        public static int UsdRiConvertToRManInterpolateBoundary(pxr.TfToken token);
        public static int UsdRiConvertToRManTriangleSubdivisionRule(pxr.TfToken token);
        public static bool UsdSkelApplyBlendShape(float weight, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_const_t offsets, pxr.SWIGTYPE_p_TfSpanT_int_const_t indices, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.VtMatrix4dArray xforms, pxr.VtMatrix4dArray jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.GfMatrix4d xforms, pxr.GfMatrix4d inverseXforms, pxr.GfMatrix4d jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t inverseXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t jointLocalXforms, pxr.GfMatrix4d rootInverseXform);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t inverseXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t jointLocalXforms, pxr.GfMatrix4f rootInverseXform);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.VtMatrix4dArray xforms, pxr.VtMatrix4dArray jointLocalXforms, pxr.GfMatrix4d rootInverseXform);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.VtMatrix4dArray xforms, pxr.VtMatrix4dArray inverseXforms, pxr.VtMatrix4dArray jointLocalXforms);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.GfMatrix4d xforms, pxr.GfMatrix4d inverseXforms, pxr.GfMatrix4d jointLocalXforms, pxr.GfMatrix4d rootInverseXform);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t inverseXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t jointLocalXforms, pxr.GfMatrix4d rootInverseXform);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t inverseXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t jointLocalXforms, pxr.GfMatrix4f rootInverseXform);
        public static bool UsdSkelComputeJointLocalTransforms(pxr.UsdSkelTopology topology, pxr.VtMatrix4dArray xforms, pxr.VtMatrix4dArray inverseXforms, pxr.VtMatrix4dArray jointLocalXforms, pxr.GfMatrix4d rootInverseXform);
        public static bool UsdSkelComputeJointsExtent(pxr.VtMatrix4dArray joints, pxr.VtVec3fArray extent);
        public static bool UsdSkelComputeJointsExtent(pxr.GfMatrix4d xforms, System.UInt32 numXforms, pxr.VtVec3fArray extent);
        public static bool UsdSkelComputeJointsExtent(pxr.VtMatrix4dArray joints, pxr.VtVec3fArray extent, float pad);
        public static bool UsdSkelComputeJointsExtent(pxr.GfMatrix4d xforms, System.UInt32 numXforms, pxr.VtVec3fArray extent, float pad);
        public static bool UsdSkelComputeJointsExtent(pxr.VtMatrix4dArray joints, pxr.VtVec3fArray extent, float pad, pxr.GfMatrix4d rootXform);
        public static bool UsdSkelComputeJointsExtent(pxr.GfMatrix4d xforms, System.UInt32 numXforms, pxr.VtVec3fArray extent, float pad, pxr.GfMatrix4d rootXform);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.GfMatrix4d jointLocalXforms, pxr.GfMatrix4d xforms);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointLocalXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t xforms);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointLocalXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t xforms);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.VtMatrix4dArray jointLocalXforms, pxr.VtMatrix4dArray xforms);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.GfMatrix4d jointLocalXforms, pxr.GfMatrix4d xforms, pxr.GfMatrix4d rootXform);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointLocalXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t xforms, pxr.GfMatrix4d rootXform);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointLocalXforms, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t xforms, pxr.GfMatrix4f rootXform);
        public static bool UsdSkelConcatJointTransforms(pxr.UsdSkelTopology topology, pxr.VtMatrix4dArray jointLocalXforms, pxr.VtMatrix4dArray xforms, pxr.GfMatrix4d rootXform);
        public static bool UsdSkelDecomposeTransforms(pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t translations, pxr.SWIGTYPE_p_TfSpanT_GfQuatf_t rotations, pxr.SWIGTYPE_p_TfSpanT_GfVec3h_t scales);
        public static bool UsdSkelDecomposeTransforms(pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t xforms, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t translations, pxr.SWIGTYPE_p_TfSpanT_GfQuatf_t rotations, pxr.SWIGTYPE_p_TfSpanT_GfVec3h_t scales);
        public static bool UsdSkelDecomposeTransforms(pxr.VtMatrix4dArray xforms, pxr.VtVec3fArray translations, pxr.VtQuatfArray rotations, pxr.VtVec3hArray scales);
        public static bool UsdSkelDecomposeTransforms(pxr.GfMatrix4d xforms, pxr.GfVec3f translations, pxr.GfQuatf rotations, pxr.GfVec3h scales, System.UInt32 count);
        public static bool UsdSkelExpandConstantInfluencesToVarying(pxr.VtFloatArray weights, System.UInt32 size);
        public static bool UsdSkelExpandConstantInfluencesToVarying(pxr.VtIntArray indices, System.UInt32 size);
        public static bool UsdSkelInterleaveInfluences(pxr.SWIGTYPE_p_TfSpanT_int_const_t indices, pxr.SWIGTYPE_p_TfSpanT_float_const_t weights, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_t interleavedInfluences);
        public static bool UsdSkelIsSkelAnimationPrim(pxr.UsdPrim prim);
        public static bool UsdSkelIsSkinnablePrim(pxr.UsdPrim prim);
        public static bool UsdSkelMakeTransforms(pxr.SWIGTYPE_p_TfSpanT_GfVec3f_const_t translations, pxr.SWIGTYPE_p_TfSpanT_GfQuatf_const_t rotations, pxr.SWIGTYPE_p_TfSpanT_GfVec3h_const_t scales, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_t xforms);
        public static bool UsdSkelMakeTransforms(pxr.SWIGTYPE_p_TfSpanT_GfVec3f_const_t translations, pxr.SWIGTYPE_p_TfSpanT_GfQuatf_const_t rotations, pxr.SWIGTYPE_p_TfSpanT_GfVec3h_const_t scales, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_t xforms);
        public static bool UsdSkelMakeTransforms(pxr.VtVec3fArray translations, pxr.VtQuatfArray rotations, pxr.VtVec3hArray scales, pxr.VtMatrix4dArray xforms);
        public static bool UsdSkelMakeTransforms(pxr.GfVec3f translations, pxr.GfQuatf rotations, pxr.GfVec3h scales, pxr.GfMatrix4d xforms, System.UInt32 count);
        public static bool UsdSkelNormalizeWeights(pxr.SWIGTYPE_p_TfSpanT_float_t weights, int numInfluencesPerComponent);
        public static bool UsdSkelNormalizeWeights(pxr.VtFloatArray weights, int numInfluencesPerComponent);
        public static bool UsdSkelResizeInfluences(pxr.VtFloatArray weights, int srcNumInfluencesPerComponent, int newNumInfluencesPerComponent);
        public static bool UsdSkelResizeInfluences(pxr.VtIntArray indices, int srcNumInfluencesPerComponent, int newNumInfluencesPerComponent);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals, bool inSerial);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals, bool inSerial);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals, bool inSerial);
        public static bool UsdSkelSkinNormalsLBS(pxr.GfMatrix3f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix3f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t normals, bool inSerial);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points, bool inSerial);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.VtMatrix4dArray jointXforms, pxr.VtIntArray jointIndices, pxr.VtFloatArray jointWeights, int numInfluencesPerPoint, pxr.VtVec3fArray points);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points, bool inSerial);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points, bool inSerial);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, int numInfluencesPerPoint, pxr.SWIGTYPE_p_TfSpanT_GfVec3f_t points, bool inSerial);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.GfMatrix4d jointXforms, System.UInt32 numJoints, pxr.SWIGTYPE_p_int jointIndices, pxr.SWIGTYPE_p_float jointWeights, System.UInt32 numInfluences, int numInfluencesPerPoint, pxr.GfVec3f points, System.UInt32 numPoints);
        public static bool UsdSkelSkinPointsLBS(pxr.GfMatrix4d geomBindTransform, pxr.GfMatrix4d jointXforms, System.UInt32 numJoints, pxr.SWIGTYPE_p_int jointIndices, pxr.SWIGTYPE_p_float jointWeights, System.UInt32 numInfluences, int numInfluencesPerPoint, pxr.GfVec3f points, System.UInt32 numPoints, bool inSerial);
        public static bool UsdSkelSkinTransformLBS(pxr.GfMatrix4d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, pxr.GfMatrix4d xform);
        public static bool UsdSkelSkinTransformLBS(pxr.GfMatrix4f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_GfVec2f_const_t influences, pxr.GfMatrix4f xform);
        public static bool UsdSkelSkinTransformLBS(pxr.GfMatrix4d geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4d_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, pxr.GfMatrix4d xform);
        public static bool UsdSkelSkinTransformLBS(pxr.GfMatrix4f geomBindTransform, pxr.SWIGTYPE_p_TfSpanT_GfMatrix4f_const_t jointXforms, pxr.SWIGTYPE_p_TfSpanT_int_const_t jointIndices, pxr.SWIGTYPE_p_TfSpanT_float_const_t jointWeights, pxr.GfMatrix4f xform);
        public static bool UsdSkelSkinTransformLBS(pxr.GfMatrix4d geomBindTransform, pxr.GfMatrix4d jointXforms, System.UInt32 numJoints, pxr.SWIGTYPE_p_int jointIndices, pxr.SWIGTYPE_p_float jointWeights, System.UInt32 numInfluences, pxr.GfMatrix4d xform);
        public static bool UsdSkelSortInfluences(pxr.SWIGTYPE_p_TfSpanT_int_t indices, pxr.SWIGTYPE_p_TfSpanT_float_t weights, int numInfluencesPerComponent);
        public static bool UsdSkelSortInfluences(pxr.VtIntArray indices, pxr.VtFloatArray weights, int numInfluencesPerComponent);
        public static pxr.Usd_PrimFlagsPredicate UsdTraverseInstanceProxies();
        public static pxr.Usd_PrimFlagsPredicate UsdTraverseInstanceProxies(pxr.Usd_PrimFlagsPredicate predicate);
        public static pxr.UsdCollectionAPI UsdUtilsAuthorCollection(pxr.TfToken collectionName, pxr.UsdPrim usdPrim, pxr.SdfPathVector pathsToInclude);
        public static pxr.UsdCollectionAPI UsdUtilsAuthorCollection(pxr.TfToken collectionName, pxr.UsdPrim usdPrim, pxr.SdfPathVector pathsToInclude, pxr.SdfPathVector pathsToExclude);
        public static bool UsdUtilsComputeAllDependencies(pxr.SdfAssetPath assetPath, pxr.SdfLayerRefPtrVector layers, pxr.StdStringVector assets, pxr.StdStringVector unresolvedPaths);
        public static bool UsdUtilsComputeCollectionIncludesAndExcludes(pxr.SWIGTYPE_p_std__setT_SdfPath_t includedRootPaths, pxr.UsdStageWeakPtr usdStage, pxr.SdfPathVector pathsToInclude, pxr.SdfPathVector pathsToExclude);
        public static bool UsdUtilsComputeCollectionIncludesAndExcludes(pxr.SWIGTYPE_p_std__setT_SdfPath_t includedRootPaths, pxr.UsdStageWeakPtr usdStage, pxr.SdfPathVector pathsToInclude, pxr.SdfPathVector pathsToExclude, double minInclusionRatio);
        public static bool UsdUtilsComputeCollectionIncludesAndExcludes(pxr.SWIGTYPE_p_std__setT_SdfPath_t includedRootPaths, pxr.UsdStageWeakPtr usdStage, pxr.SdfPathVector pathsToInclude, pxr.SdfPathVector pathsToExclude, double minInclusionRatio, System.UInt32 maxNumExcludesBelowInclude);
        public static bool UsdUtilsComputeCollectionIncludesAndExcludes(pxr.SWIGTYPE_p_std__setT_SdfPath_t includedRootPaths, pxr.UsdStageWeakPtr usdStage, pxr.SdfPathVector pathsToInclude, pxr.SdfPathVector pathsToExclude, double minInclusionRatio, System.UInt32 maxNumExcludesBelowInclude, System.UInt32 minIncludeExcludeCollectionSize);
        public static bool UsdUtilsComputeCollectionIncludesAndExcludes(pxr.SWIGTYPE_p_std__setT_SdfPath_t includedRootPaths, pxr.UsdStageWeakPtr usdStage, pxr.SdfPathVector pathsToInclude, pxr.SdfPathVector pathsToExclude, double minInclusionRatio, System.UInt32 maxNumExcludesBelowInclude, System.UInt32 minIncludeExcludeCollectionSize, pxr.SWIGTYPE_p_TfHashSetT_SdfPath_SdfPath__Hash_t pathsToIgnore);
        public static pxr.UsdStage UsdUtilsComputeUsdStageStats(string rootLayerPath, pxr.VtDictionary stats);
        public static System.UInt32 UsdUtilsComputeUsdStageStats(pxr.UsdStageWeakPtr stage, pxr.VtDictionary stats);
        public static bool UsdUtilsCopyLayerMetadata(pxr.SdfLayerHandle source, pxr.SdfLayerHandle destination);
        public static bool UsdUtilsCopyLayerMetadata(pxr.SdfLayerHandle source, pxr.SdfLayerHandle destination, bool skipSublayers);
        public static bool UsdUtilsCopyLayerMetadata(pxr.SdfLayerHandle source, pxr.SdfLayerHandle destination, bool skipSublayers, bool bakeUnauthoredFallbacks);
        public static pxr.UsdCollectionAPIVector UsdUtilsCreateCollections(pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_std__setT_SdfPath_t_t_t assignments, pxr.UsdPrim usdPrim);
        public static pxr.UsdCollectionAPIVector UsdUtilsCreateCollections(pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_std__setT_SdfPath_t_t_t assignments, pxr.UsdPrim usdPrim, double minInclusionRatio);
        public static pxr.UsdCollectionAPIVector UsdUtilsCreateCollections(pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_std__setT_SdfPath_t_t_t assignments, pxr.UsdPrim usdPrim, double minInclusionRatio, System.UInt32 maxNumExcludesBelowInclude);
        public static pxr.UsdCollectionAPIVector UsdUtilsCreateCollections(pxr.SWIGTYPE_p_std__vectorT_std__pairT_TfToken_std__setT_SdfPath_t_t_t assignments, pxr.UsdPrim usdPrim, double minInclusionRatio, System.UInt32 maxNumExcludesBelowInclude, System.UInt32 minIncludeExcludeCollectionSize);
        public static bool UsdUtilsCreateNewARKitUsdzPackage(pxr.SdfAssetPath assetPath, string usdzFilePath);
        public static bool UsdUtilsCreateNewARKitUsdzPackage(pxr.SdfAssetPath assetPath, string usdzFilePath, string firstLayerName);
        public static bool UsdUtilsCreateNewUsdzPackage(pxr.SdfAssetPath assetPath, string usdzFilePath);
        public static bool UsdUtilsCreateNewUsdzPackage(pxr.SdfAssetPath assetPath, string usdzFilePath, string firstLayerName);
        public static void UsdUtilsExtractExternalReferences(string filePath, pxr.StdStringVector subLayers, pxr.StdStringVector references, pxr.StdStringVector payloads);
        public static pxr.SdfLayer UsdUtilsFlattenLayerStack(pxr.UsdStageWeakPtr stage);
        public static pxr.SdfLayer UsdUtilsFlattenLayerStack(pxr.UsdStageWeakPtr stage, pxr.SWIGTYPE_p_std__functionT_std__string_fSdfLayerHandle_const_R_std__string_const_RF_t resolveAssetPathFn);
        public static pxr.SdfLayer UsdUtilsFlattenLayerStack(pxr.UsdStageWeakPtr stage, string tag);
        public static pxr.SdfLayer UsdUtilsFlattenLayerStack(pxr.UsdStageWeakPtr stage, pxr.SWIGTYPE_p_std__functionT_std__string_fSdfLayerHandle_const_R_std__string_const_RF_t resolveAssetPathFn, string tag);
        public static string UsdUtilsFlattenLayerStackResolveAssetPath(pxr.SdfLayerHandle sourceLayer, string assetPath);
        public static string UsdUtilsGenerateClipTopologyName(string rootLayerName);
        public static pxr.TfToken UsdUtilsGetAlphaAttributeNameForColor(pxr.TfToken colorAttrName);
        public static pxr.SdfLayerHandleVector UsdUtilsGetDirtyLayers(pxr.UsdStageWeakPtr stage);
        public static pxr.SdfLayerHandleVector UsdUtilsGetDirtyLayers(pxr.UsdStageWeakPtr stage, bool includeClipLayers);
        public static pxr.TfToken UsdUtilsGetMaterialsScopeName();
        public static pxr.TfToken UsdUtilsGetMaterialsScopeName(bool forceDefault);
        public static pxr.TfToken UsdUtilsGetModelNameFromRootLayer(pxr.SdfLayerHandle rootLayer);
        public static pxr.TfToken UsdUtilsGetPrefName();
        public static pxr.TfToken UsdUtilsGetPrimaryCameraName();
        public static pxr.TfToken UsdUtilsGetPrimaryCameraName(bool forceDefault);
        public static pxr.TfToken UsdUtilsGetPrimaryUVSetName();
        public static pxr.UsdPrim UsdUtilsGetPrimAtPathWithForwarding(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.SWIGTYPE_p_std__setT_UsdUtilsRegisteredVariantSet_t UsdUtilsGetRegisteredVariantSets();
        public static void UsdUtilsModifyAssetPaths(pxr.SdfLayerHandle layer, pxr.SWIGTYPE_p_std__functionT_std__string_fstd__string_const_RF_t modifyFn);
        public static bool UsdUtilsStitchClips(pxr.SdfLayerHandle resultLayer, pxr.StdStringVector clipLayerFiles, pxr.SdfPath clipPath);
        public static bool UsdUtilsStitchClips(pxr.SdfLayerHandle resultLayer, pxr.StdStringVector clipLayerFiles, pxr.SdfPath clipPath, double startTimeCode);
        public static bool UsdUtilsStitchClips(pxr.SdfLayerHandle resultLayer, pxr.StdStringVector clipLayerFiles, pxr.SdfPath clipPath, double startTimeCode, double endTimeCode);
        public static bool UsdUtilsStitchClips(pxr.SdfLayerHandle resultLayer, pxr.StdStringVector clipLayerFiles, pxr.SdfPath clipPath, double startTimeCode, double endTimeCode, bool interpolateMissingClipValues);
        public static bool UsdUtilsStitchClips(pxr.SdfLayerHandle resultLayer, pxr.StdStringVector clipLayerFiles, pxr.SdfPath clipPath, double startTimeCode, double endTimeCode, bool interpolateMissingClipValues, pxr.TfToken clipSet);
        public static bool UsdUtilsStitchClipsTemplate(pxr.SdfLayerHandle resultLayer, pxr.SdfLayerHandle topologyLayer, pxr.SdfPath clipPath, string templatePath, double startTime, double endTime, double stride);
        public static bool UsdUtilsStitchClipsTemplate(pxr.SdfLayerHandle resultLayer, pxr.SdfLayerHandle topologyLayer, pxr.SdfPath clipPath, string templatePath, double startTime, double endTime, double stride, double activeOffset);
        public static bool UsdUtilsStitchClipsTemplate(pxr.SdfLayerHandle resultLayer, pxr.SdfLayerHandle topologyLayer, pxr.SdfPath clipPath, string templatePath, double startTime, double endTime, double stride, double activeOffset, bool interpolateMissingClipValues);
        public static bool UsdUtilsStitchClipsTemplate(pxr.SdfLayerHandle resultLayer, pxr.SdfLayerHandle topologyLayer, pxr.SdfPath clipPath, string templatePath, double startTime, double endTime, double stride, double activeOffset, bool interpolateMissingClipValues, pxr.TfToken clipSet);
        public static bool UsdUtilsStitchClipsTopology(pxr.SdfLayerHandle topologyLayer, pxr.StdStringVector clipLayerFiles);
        public static void UsdUtilsStitchInfo(pxr.SdfSpecHandle strongObj, pxr.SdfSpecHandle weakObj);
        public static void UsdUtilsStitchLayers(pxr.SdfLayerHandle strongLayer, pxr.SdfLayerHandle weakLayer);
        public static pxr.UsdPrim UsdUtilsUninstancePrimAtPath(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.VtDictionary VtDictionaryOver(pxr.VtDictionary strong, pxr.VtDictionary weak);
        public static pxr.VtDictionary VtDictionaryOver(pxr.VtDictionary strong, pxr.VtDictionary weak, bool coerceToWeakerOpinionType);
        public static pxr.VtDictionary VtDictionaryOverRecursive(pxr.VtDictionary strong, pxr.VtDictionary weak);
        public static pxr.VtDictionary VtDictionaryOverRecursive(pxr.VtDictionary strong, pxr.VtDictionary weak, bool coerceToWeakerOpinionType);
        public static pxr.VtDictionary VtGetEmptyDictionary();
        public static pxr.SWIGTYPE_p_std__ostream VtStreamOut(pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t arg0, pxr.SWIGTYPE_p_std__ostream arg1);
        public static bool VtValueTobool(pxr.VtValue value);
        public static void VtValueTobool(pxr.VtValue value, ref bool output);
        public static byte VtValueTobyte(pxr.VtValue value);
        public static void VtValueTobyte(pxr.VtValue value, ref byte output);
        public static double VtValueTodouble(pxr.VtValue value);
        public static void VtValueTodouble(pxr.VtValue value, ref double output);
        public static float VtValueTofloat(pxr.VtValue value);
        public static void VtValueTofloat(pxr.VtValue value, ref float output);
        public static pxr.GfHalf VtValueToGfHalf(pxr.VtValue value);
        public static void VtValueToGfHalf(pxr.VtValue value, pxr.GfHalf output);
        public static pxr.GfMatrix2d VtValueToGfMatrix2d(pxr.VtValue value);
        public static void VtValueToGfMatrix2d(pxr.VtValue value, pxr.GfMatrix2d output);
        public static pxr.GfMatrix3d VtValueToGfMatrix3d(pxr.VtValue value);
        public static void VtValueToGfMatrix3d(pxr.VtValue value, pxr.GfMatrix3d output);
        public static pxr.GfMatrix4d VtValueToGfMatrix4d(pxr.VtValue value);
        public static void VtValueToGfMatrix4d(pxr.VtValue value, pxr.GfMatrix4d output);
        public static pxr.GfQuatd VtValueToGfQuatd(pxr.VtValue value);
        public static void VtValueToGfQuatd(pxr.VtValue value, pxr.GfQuatd output);
        public static pxr.GfQuatf VtValueToGfQuatf(pxr.VtValue value);
        public static void VtValueToGfQuatf(pxr.VtValue value, pxr.GfQuatf output);
        public static pxr.GfQuath VtValueToGfQuath(pxr.VtValue value);
        public static void VtValueToGfQuath(pxr.VtValue value, pxr.GfQuath output);
        public static pxr.GfVec2d VtValueToGfVec2d(pxr.VtValue value);
        public static void VtValueToGfVec2d(pxr.VtValue value, pxr.GfVec2d output);
        public static pxr.GfVec2f VtValueToGfVec2f(pxr.VtValue value);
        public static void VtValueToGfVec2f(pxr.VtValue value, pxr.GfVec2f output);
        public static pxr.GfVec2h VtValueToGfVec2h(pxr.VtValue value);
        public static void VtValueToGfVec2h(pxr.VtValue value, pxr.GfVec2h output);
        public static pxr.GfVec2i VtValueToGfVec2i(pxr.VtValue value);
        public static void VtValueToGfVec2i(pxr.VtValue value, pxr.GfVec2i output);
        public static pxr.GfVec3d VtValueToGfVec3d(pxr.VtValue value);
        public static void VtValueToGfVec3d(pxr.VtValue value, pxr.GfVec3d output);
        public static pxr.GfVec3f VtValueToGfVec3f(pxr.VtValue value);
        public static void VtValueToGfVec3f(pxr.VtValue value, pxr.GfVec3f output);
        public static pxr.GfVec3h VtValueToGfVec3h(pxr.VtValue value);
        public static void VtValueToGfVec3h(pxr.VtValue value, pxr.GfVec3h output);
        public static pxr.GfVec3i VtValueToGfVec3i(pxr.VtValue value);
        public static void VtValueToGfVec3i(pxr.VtValue value, pxr.GfVec3i output);
        public static pxr.GfVec4d VtValueToGfVec4d(pxr.VtValue value);
        public static void VtValueToGfVec4d(pxr.VtValue value, pxr.GfVec4d output);
        public static pxr.GfVec4f VtValueToGfVec4f(pxr.VtValue value);
        public static void VtValueToGfVec4f(pxr.VtValue value, pxr.GfVec4f output);
        public static pxr.GfVec4h VtValueToGfVec4h(pxr.VtValue value);
        public static void VtValueToGfVec4h(pxr.VtValue value, pxr.GfVec4h output);
        public static pxr.GfVec4i VtValueToGfVec4i(pxr.VtValue value);
        public static void VtValueToGfVec4i(pxr.VtValue value, pxr.GfVec4i output);
        public static int VtValueToint(pxr.VtValue value);
        public static void VtValueToint(pxr.VtValue value, ref int output);
        public static long VtValueTolong(pxr.VtValue value);
        public static void VtValueTolong(pxr.VtValue value, ref long output);
        public static pxr.SdfAssetPath VtValueToSdfAssetPath(pxr.VtValue value);
        public static void VtValueToSdfAssetPath(pxr.VtValue value, pxr.SdfAssetPath output);
        public static pxr.SdfAssetPathArray VtValueToSdfAssetPathArray(pxr.VtValue value);
        public static void VtValueToSdfAssetPathArray(pxr.VtValue value, pxr.SdfAssetPathArray output);
        public static pxr.SdfTimeCode VtValueToSdfTimeCode(pxr.VtValue value);
        public static void VtValueToSdfTimeCode(pxr.VtValue value, pxr.SdfTimeCode output);
        public static pxr.SdfTimeCodeArray VtValueToSdfTimeCodeArray(pxr.VtValue value);
        public static void VtValueToSdfTimeCodeArray(pxr.VtValue value, pxr.SdfTimeCodeArray output);
        public static string VtValueTostring(pxr.VtValue value);
        public static void VtValueTostring(pxr.VtValue value, pxr.SWIGTYPE_p_std__string output);
        public static pxr.TfToken VtValueToTfToken(pxr.VtValue value);
        public static void VtValueToTfToken(pxr.VtValue value, pxr.TfToken output);
        public static System.UInt32 VtValueTouint(pxr.VtValue value);
        public static void VtValueTouint(pxr.VtValue value, ref System.UInt32 output);
        public static System.UInt64 VtValueToulong(pxr.VtValue value);
        public static void VtValueToulong(pxr.VtValue value, ref System.UInt64 output);
        public static pxr.VtBoolArray VtValueToVtBoolArray(pxr.VtValue value);
        public static void VtValueToVtBoolArray(pxr.VtValue value, pxr.VtBoolArray output);
        public static pxr.VtDoubleArray VtValueToVtDoubleArray(pxr.VtValue value);
        public static void VtValueToVtDoubleArray(pxr.VtValue value, pxr.VtDoubleArray output);
        public static pxr.VtFloatArray VtValueToVtFloatArray(pxr.VtValue value);
        public static void VtValueToVtFloatArray(pxr.VtValue value, pxr.VtFloatArray output);
        public static pxr.VtHalfArray VtValueToVtHalfArray(pxr.VtValue value);
        public static void VtValueToVtHalfArray(pxr.VtValue value, pxr.VtHalfArray output);
        public static pxr.VtInt64Array VtValueToVtInt64Array(pxr.VtValue value);
        public static void VtValueToVtInt64Array(pxr.VtValue value, pxr.VtInt64Array output);
        public static pxr.VtIntArray VtValueToVtIntArray(pxr.VtValue value);
        public static void VtValueToVtIntArray(pxr.VtValue value, pxr.VtIntArray output);
        public static pxr.VtMatrix2dArray VtValueToVtMatrix2dArray(pxr.VtValue value);
        public static void VtValueToVtMatrix2dArray(pxr.VtValue value, pxr.VtMatrix2dArray output);
        public static pxr.VtMatrix3dArray VtValueToVtMatrix3dArray(pxr.VtValue value);
        public static void VtValueToVtMatrix3dArray(pxr.VtValue value, pxr.VtMatrix3dArray output);
        public static pxr.VtMatrix4dArray VtValueToVtMatrix4dArray(pxr.VtValue value);
        public static void VtValueToVtMatrix4dArray(pxr.VtValue value, pxr.VtMatrix4dArray output);
        public static pxr.VtQuatdArray VtValueToVtQuatdArray(pxr.VtValue value);
        public static void VtValueToVtQuatdArray(pxr.VtValue value, pxr.VtQuatdArray output);
        public static pxr.VtQuatfArray VtValueToVtQuatfArray(pxr.VtValue value);
        public static void VtValueToVtQuatfArray(pxr.VtValue value, pxr.VtQuatfArray output);
        public static pxr.VtQuathArray VtValueToVtQuathArray(pxr.VtValue value);
        public static void VtValueToVtQuathArray(pxr.VtValue value, pxr.VtQuathArray output);
        public static pxr.VtStringArray VtValueToVtStringArray(pxr.VtValue value);
        public static void VtValueToVtStringArray(pxr.VtValue value, pxr.VtStringArray output);
        public static pxr.VtTokenArray VtValueToVtTokenArray(pxr.VtValue value);
        public static void VtValueToVtTokenArray(pxr.VtValue value, pxr.VtTokenArray output);
        public static pxr.VtUCharArray VtValueToVtUCharArray(pxr.VtValue value);
        public static void VtValueToVtUCharArray(pxr.VtValue value, pxr.VtUCharArray output);
        public static pxr.VtUInt64Array VtValueToVtUInt64Array(pxr.VtValue value);
        public static void VtValueToVtUInt64Array(pxr.VtValue value, pxr.VtUInt64Array output);
        public static pxr.VtUIntArray VtValueToVtUIntArray(pxr.VtValue value);
        public static void VtValueToVtUIntArray(pxr.VtValue value, pxr.VtUIntArray output);
        public static pxr.VtVec2dArray VtValueToVtVec2dArray(pxr.VtValue value);
        public static void VtValueToVtVec2dArray(pxr.VtValue value, pxr.VtVec2dArray output);
        public static pxr.VtVec2fArray VtValueToVtVec2fArray(pxr.VtValue value);
        public static void VtValueToVtVec2fArray(pxr.VtValue value, pxr.VtVec2fArray output);
        public static pxr.VtVec2hArray VtValueToVtVec2hArray(pxr.VtValue value);
        public static void VtValueToVtVec2hArray(pxr.VtValue value, pxr.VtVec2hArray output);
        public static pxr.VtVec2iArray VtValueToVtVec2iArray(pxr.VtValue value);
        public static void VtValueToVtVec2iArray(pxr.VtValue value, pxr.VtVec2iArray output);
        public static pxr.VtVec3dArray VtValueToVtVec3dArray(pxr.VtValue value);
        public static void VtValueToVtVec3dArray(pxr.VtValue value, pxr.VtVec3dArray output);
        public static pxr.VtVec3fArray VtValueToVtVec3fArray(pxr.VtValue value);
        public static void VtValueToVtVec3fArray(pxr.VtValue value, pxr.VtVec3fArray output);
        public static pxr.VtVec3hArray VtValueToVtVec3hArray(pxr.VtValue value);
        public static void VtValueToVtVec3hArray(pxr.VtValue value, pxr.VtVec3hArray output);
        public static pxr.VtVec3iArray VtValueToVtVec3iArray(pxr.VtValue value);
        public static void VtValueToVtVec3iArray(pxr.VtValue value, pxr.VtVec3iArray output);
        public static pxr.VtVec4dArray VtValueToVtVec4dArray(pxr.VtValue value);
        public static void VtValueToVtVec4dArray(pxr.VtValue value, pxr.VtVec4dArray output);
        public static pxr.VtVec4fArray VtValueToVtVec4fArray(pxr.VtValue value);
        public static void VtValueToVtVec4fArray(pxr.VtValue value, pxr.VtVec4fArray output);
        public static pxr.VtVec4hArray VtValueToVtVec4hArray(pxr.VtValue value);
        public static void VtValueToVtVec4hArray(pxr.VtValue value, pxr.VtVec4hArray output);
        public static pxr.VtVec4iArray VtValueToVtVec4iArray(pxr.VtValue value);
        public static void VtValueToVtVec4iArray(pxr.VtValue value, pxr.VtVec4iArray output);
        public static bool WriteUsdZip(string usdzFilePath, pxr.StdStringVector filesToArchive);
    }

    public class UsdEditTarget : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdEditTarget() {}
        public UsdEditTarget(pxr.SdfLayer layer) {}
        public UsdEditTarget(pxr.SdfLayerHandle layer) {}
        public UsdEditTarget(pxr.SdfLayer layer, pxr.PcpNodeRef node) {}
        public UsdEditTarget(pxr.SdfLayer layer, pxr.SdfLayerOffset offset) {}
        public UsdEditTarget(pxr.SdfLayerHandle layer, pxr.PcpNodeRef node) {}
        public UsdEditTarget(pxr.SdfLayerHandle layer, pxr.SdfLayerOffset offset) {}
        public pxr.UsdEditTarget ComposeOver(pxr.UsdEditTarget weaker);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdEditTarget ForLocalDirectVariant(pxr.SdfLayerHandle layer, pxr.SdfPath varSelPath);
        public pxr.SdfLayerHandle GetLayer();
        public pxr.SWIGTYPE_p_PcpMapFunction GetMapFunction();
        public pxr.SdfPrimSpecHandle GetPrimSpecForScenePath(pxr.SdfPath scenePath);
        public pxr.SdfPropertySpecHandle GetPropertySpecForScenePath(pxr.SdfPath scenePath);
        public pxr.SdfSpecHandle GetSpecForScenePath(pxr.SdfPath scenePath);
        public bool IsNull();
        public bool IsValid();
        public pxr.SdfPath MapToSpecPath(pxr.SdfPath scenePath);
    }

    public class UsdGeomBasisCurves : pxr.UsdGeomCurves
    {
        public UsdGeomBasisCurves() {}
        public UsdGeomBasisCurves(pxr.UsdPrim prim) {}
        public UsdGeomBasisCurves(pxr.UsdSchemaBase schemaObj) {}
        public pxr.TfToken ComputeInterpolationForSize(System.UInt32 n, pxr.UsdTimeCode timeCode);
        public pxr.TfToken ComputeInterpolationForSize(System.UInt32 n, pxr.UsdTimeCode timeCode, pxr.UsdGeomBasisCurvesComputeInterpolationInfo info);
        public System.UInt32 ComputeUniformDataSize(pxr.UsdTimeCode timeCode);
        public System.UInt32 ComputeVaryingDataSize(pxr.UsdTimeCode timeCode);
        public System.UInt32 ComputeVertexDataSize(pxr.UsdTimeCode timeCode);
        public pxr.UsdAttribute CreateBasisAttr();
        public pxr.UsdAttribute CreateBasisAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBasisAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTypeAttr();
        public pxr.UsdAttribute CreateTypeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTypeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWrapAttr();
        public pxr.UsdAttribute CreateWrapAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWrapAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomBasisCurves Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomBasisCurves Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetBasisAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTypeAttr();
        public pxr.UsdAttribute GetWrapAttr();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomBasisCurvesComputeInterpolationInfo : System.Collections.Generic.IEnumerable<pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair this[int index] { get; set; }
        public UsdGeomBasisCurvesComputeInterpolationInfo() {}
        public UsdGeomBasisCurvesComputeInterpolationInfo(pxr.UsdGeomBasisCurvesComputeInterpolationInfo other) {}
        public UsdGeomBasisCurvesComputeInterpolationInfo(System.Collections.ICollection c) {}
        public UsdGeomBasisCurvesComputeInterpolationInfo(int capacity) {}
        public void Add(pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair x);
        public void AddRange(pxr.UsdGeomBasisCurvesComputeInterpolationInfo values);
        public void Clear();
        public void CopyTo(pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair[] array);
        public void CopyTo(pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomBasisCurvesComputeInterpolationInfo.UsdGeomBasisCurvesComputeInterpolationInfoEnumerator GetEnumerator();
        public pxr.UsdGeomBasisCurvesComputeInterpolationInfo GetRange(int index, int count);
        public void Insert(int index, pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair x);
        public void InsertRange(int index, pxr.UsdGeomBasisCurvesComputeInterpolationInfo values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomBasisCurvesComputeInterpolationInfo Repeat(pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomBasisCurvesComputeInterpolationInfo values);
        public sealed class UsdGeomBasisCurvesComputeInterpolationInfoEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair Current { get; }
            public UsdGeomBasisCurvesComputeInterpolationInfoEnumerator(pxr.UsdGeomBasisCurvesComputeInterpolationInfo collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdGeomBasisCurvesComputeInterpolationInfoPair : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.TfToken first { get; set; }
        public System.UInt32 second { get; set; }
        public UsdGeomBasisCurvesComputeInterpolationInfoPair() {}
        public UsdGeomBasisCurvesComputeInterpolationInfoPair(pxr.UsdGeomBasisCurvesComputeInterpolationInfoPair p) {}
        public UsdGeomBasisCurvesComputeInterpolationInfoPair(pxr.TfToken t, System.UInt32 u) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class UsdGeomBBoxCache : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdGeomBBoxCache(pxr.UsdGeomBBoxCache other) {}
        public UsdGeomBBoxCache(pxr.UsdTimeCode time, pxr.TfTokenVector includedPurposes) {}
        public UsdGeomBBoxCache(pxr.UsdTimeCode time, pxr.TfTokenVector includedPurposes, bool useExtentsHint) {}
        public UsdGeomBBoxCache(pxr.UsdTimeCode time, pxr.TfTokenVector includedPurposes, bool useExtentsHint, bool ignoreVisibility) {}
        public void Clear();
        public void ClearBaseTime();
        public pxr.GfBBox3d ComputeLocalBound(pxr.UsdPrim prim);
        public pxr.GfBBox3d ComputePointInstanceLocalBound(pxr.UsdGeomPointInstancer instancer, long instanceId);
        public bool ComputePointInstanceLocalBounds(pxr.UsdGeomPointInstancer instancer, long[] instanceIdBegin, System.UInt32 numIds, pxr.GfBBox3d result);
        public pxr.GfBBox3d ComputePointInstanceRelativeBound(pxr.UsdGeomPointInstancer instancer, long instanceId, pxr.UsdPrim relativeToAncestorPrim);
        public bool ComputePointInstanceRelativeBounds(pxr.UsdGeomPointInstancer instancer, long[] instanceIdBegin, System.UInt32 numIds, pxr.UsdPrim relativeToAncestorPrim, pxr.GfBBox3d result);
        public pxr.GfBBox3d ComputePointInstanceUntransformedBound(pxr.UsdGeomPointInstancer instancer, long instanceId);
        public bool ComputePointInstanceUntransformedBounds(pxr.UsdGeomPointInstancer instancer, long[] instanceIdBegin, System.UInt32 numIds, pxr.GfBBox3d result);
        public pxr.GfBBox3d ComputePointInstanceWorldBound(pxr.UsdGeomPointInstancer instancer, long instanceId);
        public bool ComputePointInstanceWorldBounds(pxr.UsdGeomPointInstancer instancer, long[] instanceIdBegin, System.UInt32 numIds, pxr.GfBBox3d result);
        public pxr.GfBBox3d ComputeRelativeBound(pxr.UsdPrim prim, pxr.UsdPrim relativeToAncestorPrim);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdPrim prim);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdPrim prim, pxr.SWIGTYPE_p_std__setT_SdfPath_t pathsToSkip, pxr.SWIGTYPE_p_TfHashMapT_SdfPath_GfMatrix4d_SdfPath__Hash_t ctmOverrides);
        public pxr.GfBBox3d ComputeWorldBound(pxr.UsdPrim prim);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdTimeCode GetBaseTime();
        public bool GetIgnoreVisibility();
        public pxr.TfTokenVector GetIncludedPurposes();
        public pxr.UsdTimeCode GetTime();
        public bool GetUseExtentsHint();
        public bool HasBaseTime();
        public void SetBaseTime(pxr.UsdTimeCode baseTime);
        public void SetIncludedPurposes(pxr.TfTokenVector includedPurposes);
        public void SetTime(pxr.UsdTimeCode time);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomBoolVector : System.Collections.Generic.ICollection<bool>, System.Collections.Generic.IEnumerable<bool>, System.Collections.Generic.IList<bool>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual bool this[int index] { get; set; }
        public UsdGeomBoolVector() {}
        public UsdGeomBoolVector(pxr.UsdGeomBoolVector other) {}
        public UsdGeomBoolVector(System.Collections.ICollection c) {}
        public UsdGeomBoolVector(int capacity) {}
        public virtual void Add(bool x);
        public void AddRange(pxr.UsdGeomBoolVector values);
        public virtual void Clear();
        public virtual bool Contains(bool value);
        public void CopyTo(bool[] array);
        public virtual void CopyTo(bool[] array, int arrayIndex);
        public void CopyTo(int index, bool[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomBoolVector.UsdGeomBoolVectorEnumerator GetEnumerator();
        public pxr.UsdGeomBoolVector GetRange(int index, int count);
        public virtual int IndexOf(bool value);
        public virtual void Insert(int index, bool x);
        public void InsertRange(int index, pxr.UsdGeomBoolVector values);
        public int LastIndexOf(bool value);
        public virtual bool Remove(bool value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomBoolVector Repeat(bool value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomBoolVector values);
        public sealed class UsdGeomBoolVectorEnumerator : System.Collections.Generic.IEnumerator<bool>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual bool Current { get; }
            public UsdGeomBoolVectorEnumerator(pxr.UsdGeomBoolVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdGeomBoundable : pxr.UsdGeomXformable
    {
        public UsdGeomBoundable() {}
        public UsdGeomBoundable(pxr.UsdPrim prim) {}
        public UsdGeomBoundable(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtentFromPlugins(pxr.UsdGeomBoundable boundable, pxr.UsdTimeCode time, pxr.VtVec3fArray extent);
        public static bool ComputeExtentFromPlugins(pxr.UsdGeomBoundable boundable, pxr.UsdTimeCode time, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateExtentAttr();
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomBoundable Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetExtentAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomCamera : pxr.UsdGeomXformable
    {
        public UsdGeomCamera() {}
        public UsdGeomCamera(pxr.UsdPrim prim) {}
        public UsdGeomCamera(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateClippingPlanesAttr();
        public pxr.UsdAttribute CreateClippingPlanesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateClippingPlanesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateClippingRangeAttr();
        public pxr.UsdAttribute CreateClippingRangeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateClippingRangeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFocalLengthAttr();
        public pxr.UsdAttribute CreateFocalLengthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFocalLengthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFocusDistanceAttr();
        public pxr.UsdAttribute CreateFocusDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFocusDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFStopAttr();
        public pxr.UsdAttribute CreateFStopAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFStopAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHorizontalApertureAttr();
        public pxr.UsdAttribute CreateHorizontalApertureAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHorizontalApertureAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHorizontalApertureOffsetAttr();
        public pxr.UsdAttribute CreateHorizontalApertureOffsetAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHorizontalApertureOffsetAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateProjectionAttr();
        public pxr.UsdAttribute CreateProjectionAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateProjectionAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShutterCloseAttr();
        public pxr.UsdAttribute CreateShutterCloseAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShutterCloseAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShutterOpenAttr();
        public pxr.UsdAttribute CreateShutterOpenAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShutterOpenAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateStereoRoleAttr();
        public pxr.UsdAttribute CreateStereoRoleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateStereoRoleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVerticalApertureAttr();
        public pxr.UsdAttribute CreateVerticalApertureAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVerticalApertureAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVerticalApertureOffsetAttr();
        public pxr.UsdAttribute CreateVerticalApertureOffsetAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVerticalApertureOffsetAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomCamera Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomCamera Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.GfCamera GetCamera(pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetClippingPlanesAttr();
        public pxr.UsdAttribute GetClippingRangeAttr();
        public pxr.UsdAttribute GetFocalLengthAttr();
        public pxr.UsdAttribute GetFocusDistanceAttr();
        public pxr.UsdAttribute GetFStopAttr();
        public pxr.UsdAttribute GetHorizontalApertureAttr();
        public pxr.UsdAttribute GetHorizontalApertureOffsetAttr();
        public pxr.UsdAttribute GetProjectionAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetShutterCloseAttr();
        public pxr.UsdAttribute GetShutterOpenAttr();
        public pxr.UsdAttribute GetStereoRoleAttr();
        public pxr.UsdAttribute GetVerticalApertureAttr();
        public pxr.UsdAttribute GetVerticalApertureOffsetAttr();
        public void SetFromCamera(pxr.GfCamera camera, pxr.UsdTimeCode time);
    }

    public class UsdGeomCapsule : pxr.UsdGeomGprim
    {
        public UsdGeomCapsule() {}
        public UsdGeomCapsule(pxr.UsdPrim prim) {}
        public UsdGeomCapsule(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(double height, double radius, pxr.TfToken axis, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(double height, double radius, pxr.TfToken axis, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateAxisAttr();
        public pxr.UsdAttribute CreateAxisAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAxisAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateExtentAttr();
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomCapsule Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomCapsule Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAxisAttr();
        public pxr.UsdAttribute GetExtentAttr();
        public pxr.UsdAttribute GetHeightAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomCone : pxr.UsdGeomGprim
    {
        public UsdGeomCone() {}
        public UsdGeomCone(pxr.UsdPrim prim) {}
        public UsdGeomCone(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(double height, double radius, pxr.TfToken axis, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(double height, double radius, pxr.TfToken axis, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateAxisAttr();
        public pxr.UsdAttribute CreateAxisAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAxisAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateExtentAttr();
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomCone Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomCone Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAxisAttr();
        public pxr.UsdAttribute GetExtentAttr();
        public pxr.UsdAttribute GetHeightAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomConstraintTarget : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdGeomConstraintTarget() {}
        public UsdGeomConstraintTarget(pxr.UsdAttribute attr) {}
        public pxr.GfMatrix4d ComputeInWorldSpace();
        public pxr.GfMatrix4d ComputeInWorldSpace(pxr.UsdTimeCode time);
        public pxr.GfMatrix4d ComputeInWorldSpace(pxr.UsdTimeCode time, pxr.UsdGeomXformCache xfCache);
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool Get(pxr.GfMatrix4d value);
        public bool Get(pxr.GfMatrix4d value, pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetAttr();
        public static pxr.TfToken GetConstraintAttrName(string constraintName);
        public pxr.TfToken GetIdentifier();
        public bool IsDefined();
        public static bool IsValid(pxr.UsdAttribute attr);
        public bool Set(pxr.GfMatrix4d value);
        public bool Set(pxr.GfMatrix4d value, pxr.UsdTimeCode time);
        public void SetIdentifier(pxr.TfToken identifier);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomConstraintTargetVector : System.Collections.Generic.IEnumerable<pxr.UsdGeomConstraintTarget>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdGeomConstraintTarget this[int index] { get; set; }
        public UsdGeomConstraintTargetVector() {}
        public UsdGeomConstraintTargetVector(pxr.UsdGeomConstraintTargetVector other) {}
        public UsdGeomConstraintTargetVector(System.Collections.ICollection c) {}
        public UsdGeomConstraintTargetVector(int capacity) {}
        public void Add(pxr.UsdGeomConstraintTarget x);
        public void AddRange(pxr.UsdGeomConstraintTargetVector values);
        public void Clear();
        public void CopyTo(pxr.UsdGeomConstraintTarget[] array);
        public void CopyTo(pxr.UsdGeomConstraintTarget[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdGeomConstraintTarget[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomConstraintTargetVector.UsdGeomConstraintTargetVectorEnumerator GetEnumerator();
        public pxr.UsdGeomConstraintTargetVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdGeomConstraintTarget x);
        public void InsertRange(int index, pxr.UsdGeomConstraintTargetVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomConstraintTargetVector Repeat(pxr.UsdGeomConstraintTarget value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomConstraintTargetVector values);
        public sealed class UsdGeomConstraintTargetVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdGeomConstraintTarget>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdGeomConstraintTarget Current { get; }
            public UsdGeomConstraintTargetVectorEnumerator(pxr.UsdGeomConstraintTargetVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdGeomCube : pxr.UsdGeomGprim
    {
        public UsdGeomCube() {}
        public UsdGeomCube(pxr.UsdPrim prim) {}
        public UsdGeomCube(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(double size, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(double size, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateExtentAttr();
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSizeAttr();
        public pxr.UsdAttribute CreateSizeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSizeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomCube Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomCube Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetExtentAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetSizeAttr();
    }

    public class UsdGeomCurves : pxr.UsdGeomPointBased
    {
        public UsdGeomCurves() {}
        public UsdGeomCurves(pxr.UsdPrim prim) {}
        public UsdGeomCurves(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(pxr.VtVec3fArray points, pxr.VtFloatArray widths, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(pxr.VtVec3fArray points, pxr.VtFloatArray widths, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateCurveVertexCountsAttr();
        public pxr.UsdAttribute CreateCurveVertexCountsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCurveVertexCountsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWidthsAttr();
        public pxr.UsdAttribute CreateWidthsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWidthsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomCurves Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetCurveVertexCountsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetWidthsAttr();
        public pxr.TfToken GetWidthsInterpolation();
        public bool SetWidthsInterpolation(pxr.TfToken interpolation);
    }

    public class UsdGeomCylinder : pxr.UsdGeomGprim
    {
        public UsdGeomCylinder() {}
        public UsdGeomCylinder(pxr.UsdPrim prim) {}
        public UsdGeomCylinder(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(double height, double radius, pxr.TfToken axis, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(double height, double radius, pxr.TfToken axis, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateAxisAttr();
        public pxr.UsdAttribute CreateAxisAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAxisAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateExtentAttr();
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomCylinder Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomCylinder Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAxisAttr();
        public pxr.UsdAttribute GetExtentAttr();
        public pxr.UsdAttribute GetHeightAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomGprim : pxr.UsdGeomBoundable
    {
        public UsdGeomGprim() {}
        public UsdGeomGprim(pxr.UsdPrim prim) {}
        public UsdGeomGprim(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateDisplayColorAttr();
        public pxr.UsdAttribute CreateDisplayColorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDisplayColorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdGeomPrimvar CreateDisplayColorPrimvar();
        public pxr.UsdGeomPrimvar CreateDisplayColorPrimvar(pxr.TfToken interpolation);
        public pxr.UsdGeomPrimvar CreateDisplayColorPrimvar(pxr.TfToken interpolation, int elementSize);
        public pxr.UsdAttribute CreateDisplayOpacityAttr();
        public pxr.UsdAttribute CreateDisplayOpacityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDisplayOpacityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdGeomPrimvar CreateDisplayOpacityPrimvar();
        public pxr.UsdGeomPrimvar CreateDisplayOpacityPrimvar(pxr.TfToken interpolation);
        public pxr.UsdGeomPrimvar CreateDisplayOpacityPrimvar(pxr.TfToken interpolation, int elementSize);
        public pxr.UsdAttribute CreateDoubleSidedAttr();
        public pxr.UsdAttribute CreateDoubleSidedAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDoubleSidedAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateOrientationAttr();
        public pxr.UsdAttribute CreateOrientationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateOrientationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomGprim Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetDisplayColorAttr();
        public pxr.UsdGeomPrimvar GetDisplayColorPrimvar();
        public pxr.UsdAttribute GetDisplayOpacityAttr();
        public pxr.UsdGeomPrimvar GetDisplayOpacityPrimvar();
        public pxr.UsdAttribute GetDoubleSidedAttr();
        public pxr.UsdAttribute GetOrientationAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomImageable : pxr.UsdTyped
    {
        public UsdGeomImageable() {}
        public UsdGeomImageable(pxr.UsdPrim prim) {}
        public UsdGeomImageable(pxr.UsdSchemaBase schemaObj) {}
        public pxr.GfBBox3d ComputeLocalBound(pxr.UsdTimeCode time);
        public pxr.GfBBox3d ComputeLocalBound(pxr.UsdTimeCode time, pxr.TfToken purpose1);
        public pxr.GfBBox3d ComputeLocalBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2);
        public pxr.GfBBox3d ComputeLocalBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2, pxr.TfToken purpose3);
        public pxr.GfBBox3d ComputeLocalBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2, pxr.TfToken purpose3, pxr.TfToken purpose4);
        public pxr.GfMatrix4d ComputeLocalToWorldTransform(pxr.UsdTimeCode time);
        public pxr.GfMatrix4d ComputeParentToWorldTransform(pxr.UsdTimeCode time);
        public pxr.UsdPrim ComputeProxyPrim();
        public pxr.UsdPrim ComputeProxyPrim(pxr.UsdPrim renderPrim);
        public pxr.TfToken ComputePurpose();
        public pxr.UsdGeomImageable.PurposeInfo ComputePurposeInfo();
        public pxr.UsdGeomImageable.PurposeInfo ComputePurposeInfo(pxr.UsdGeomImageable.PurposeInfo parentPurposeInfo);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdTimeCode time);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdTimeCode time, pxr.TfToken purpose1);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2, pxr.TfToken purpose3);
        public pxr.GfBBox3d ComputeUntransformedBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2, pxr.TfToken purpose3, pxr.TfToken purpose4);
        public pxr.TfToken ComputeVisibility();
        public pxr.TfToken ComputeVisibility(pxr.TfToken parentVisibility);
        public pxr.TfToken ComputeVisibility(pxr.UsdTimeCode time);
        public pxr.TfToken ComputeVisibility(pxr.TfToken parentVisibility, pxr.UsdTimeCode time);
        public pxr.GfBBox3d ComputeWorldBound(pxr.UsdTimeCode time);
        public pxr.GfBBox3d ComputeWorldBound(pxr.UsdTimeCode time, pxr.TfToken purpose1);
        public pxr.GfBBox3d ComputeWorldBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2);
        public pxr.GfBBox3d ComputeWorldBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2, pxr.TfToken purpose3);
        public pxr.GfBBox3d ComputeWorldBound(pxr.UsdTimeCode time, pxr.TfToken purpose1, pxr.TfToken purpose2, pxr.TfToken purpose3, pxr.TfToken purpose4);
        public pxr.UsdGeomPrimvar CreatePrimvar(pxr.TfToken attrName, pxr.SdfValueTypeName typeName);
        public pxr.UsdGeomPrimvar CreatePrimvar(pxr.TfToken attrName, pxr.SdfValueTypeName typeName, pxr.TfToken interpolation);
        public pxr.UsdGeomPrimvar CreatePrimvar(pxr.TfToken attrName, pxr.SdfValueTypeName typeName, pxr.TfToken interpolation, int elementSize);
        public pxr.UsdRelationship CreateProxyPrimRel();
        public pxr.UsdAttribute CreatePurposeAttr();
        public pxr.UsdAttribute CreatePurposeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePurposeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVisibilityAttr();
        public pxr.UsdAttribute CreateVisibilityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVisibilityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomImageable Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdGeomPrimvarVector GetAuthoredPrimvars();
        public static pxr.TfTokenVector GetOrderedPurposeTokens();
        public pxr.UsdGeomPrimvar GetPrimvar(pxr.TfToken name);
        public pxr.UsdGeomPrimvarVector GetPrimvars();
        public pxr.UsdRelationship GetProxyPrimRel();
        public pxr.UsdAttribute GetPurposeAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetVisibilityAttr();
        public bool HasPrimvar(pxr.TfToken name);
        public void MakeInvisible();
        public void MakeInvisible(pxr.UsdTimeCode time);
        public void MakeVisible();
        public void MakeVisible(pxr.UsdTimeCode time);
        public bool SetProxyPrim(pxr.UsdPrim proxy);
        public bool SetProxyPrim(pxr.UsdSchemaBase proxy);
        public class PurposeInfo : System.IDisposable
        {
            protected bool swigCMemOwn;
            public bool isInheritable { get; set; }
            public pxr.TfToken purpose { get; set; }
            public PurposeInfo() {}
            public PurposeInfo(pxr.TfToken purpose_, bool isInheritable_) {}
            public virtual void Dispose();
            protected virtual void Finalize();
            public pxr.TfToken GetInheritablePurpose();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomLongVector : System.Collections.Generic.ICollection<long>, System.Collections.Generic.IEnumerable<long>, System.Collections.Generic.IList<long>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public virtual int Count { get; }
        public bool IsFixedSize { get; }
        public virtual bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public virtual long this[int index] { get; set; }
        public UsdGeomLongVector() {}
        public UsdGeomLongVector(pxr.UsdGeomLongVector other) {}
        public UsdGeomLongVector(System.Collections.ICollection c) {}
        public UsdGeomLongVector(int capacity) {}
        public virtual void Add(long x);
        public void AddRange(pxr.UsdGeomLongVector values);
        public virtual void Clear();
        public virtual bool Contains(long value);
        public void CopyTo(long[] array);
        public virtual void CopyTo(long[] array, int arrayIndex);
        public void CopyTo(int index, long[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomLongVector.UsdGeomLongVectorEnumerator GetEnumerator();
        public pxr.UsdGeomLongVector GetRange(int index, int count);
        public virtual int IndexOf(long value);
        public virtual void Insert(int index, long x);
        public void InsertRange(int index, pxr.UsdGeomLongVector values);
        public int LastIndexOf(long value);
        public virtual bool Remove(long value);
        public virtual void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomLongVector Repeat(long value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomLongVector values);
        public sealed class UsdGeomLongVectorEnumerator : System.Collections.Generic.IEnumerator<long>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual long Current { get; }
            public UsdGeomLongVectorEnumerator(pxr.UsdGeomLongVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdGeomMesh : pxr.UsdGeomPointBased
    {
        public static float SHARPNESS_INFINITE { get; }
        public UsdGeomMesh() {}
        public UsdGeomMesh(pxr.UsdPrim prim) {}
        public UsdGeomMesh(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateCornerIndicesAttr();
        public pxr.UsdAttribute CreateCornerIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCornerIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateCornerSharpnessesAttr();
        public pxr.UsdAttribute CreateCornerSharpnessesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCornerSharpnessesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateCreaseIndicesAttr();
        public pxr.UsdAttribute CreateCreaseIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCreaseIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateCreaseLengthsAttr();
        public pxr.UsdAttribute CreateCreaseLengthsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCreaseLengthsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateCreaseSharpnessesAttr();
        public pxr.UsdAttribute CreateCreaseSharpnessesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCreaseSharpnessesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFaceVaryingLinearInterpolationAttr();
        public pxr.UsdAttribute CreateFaceVaryingLinearInterpolationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFaceVaryingLinearInterpolationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFaceVertexCountsAttr();
        public pxr.UsdAttribute CreateFaceVertexCountsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFaceVertexCountsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFaceVertexIndicesAttr();
        public pxr.UsdAttribute CreateFaceVertexIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFaceVertexIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHoleIndicesAttr();
        public pxr.UsdAttribute CreateHoleIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHoleIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateInterpolateBoundaryAttr();
        public pxr.UsdAttribute CreateInterpolateBoundaryAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInterpolateBoundaryAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSubdivisionSchemeAttr();
        public pxr.UsdAttribute CreateSubdivisionSchemeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSubdivisionSchemeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTriangleSubdivisionRuleAttr();
        public pxr.UsdAttribute CreateTriangleSubdivisionRuleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTriangleSubdivisionRuleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomMesh Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomMesh Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetCornerIndicesAttr();
        public pxr.UsdAttribute GetCornerSharpnessesAttr();
        public pxr.UsdAttribute GetCreaseIndicesAttr();
        public pxr.UsdAttribute GetCreaseLengthsAttr();
        public pxr.UsdAttribute GetCreaseSharpnessesAttr();
        public pxr.UsdAttribute GetFaceVaryingLinearInterpolationAttr();
        public pxr.UsdAttribute GetFaceVertexCountsAttr();
        public pxr.UsdAttribute GetFaceVertexIndicesAttr();
        public pxr.UsdAttribute GetHoleIndicesAttr();
        public pxr.UsdAttribute GetInterpolateBoundaryAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetSubdivisionSchemeAttr();
        public pxr.UsdAttribute GetTriangleSubdivisionRuleAttr();
        public static bool IsSharpnessInfinite(float sharpness);
        public static void Triangulate(pxr.VtIntArray faceVertexIndices, pxr.VtIntArray faceVertexCounts);
        public static bool ValidateTopology(pxr.VtIntArray faceVertexIndices, pxr.VtIntArray faceVertexCounts, System.UInt32 numPoints);
        public static bool ValidateTopology(pxr.VtIntArray faceVertexIndices, pxr.VtIntArray faceVertexCounts, System.UInt32 numPoints, out string reason);
    }

    public class UsdGeomModelAPI : pxr.UsdAPISchemaBase
    {
        public UsdGeomModelAPI() {}
        public UsdGeomModelAPI(pxr.UsdPrim prim) {}
        public UsdGeomModelAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdGeomModelAPI Apply(pxr.UsdPrim prim);
        public pxr.VtVec3fArray ComputeExtentsHint(pxr.UsdGeomBBoxCache bboxCache);
        public pxr.TfToken ComputeModelDrawMode();
        public pxr.TfToken ComputeModelDrawMode(pxr.TfToken parentDrawMode);
        public pxr.UsdGeomConstraintTarget CreateConstraintTarget(string constraintName);
        public pxr.UsdAttribute CreateModelApplyDrawModeAttr();
        public pxr.UsdAttribute CreateModelApplyDrawModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelApplyDrawModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardGeometryAttr();
        public pxr.UsdAttribute CreateModelCardGeometryAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardGeometryAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardTextureXNegAttr();
        public pxr.UsdAttribute CreateModelCardTextureXNegAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardTextureXNegAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardTextureXPosAttr();
        public pxr.UsdAttribute CreateModelCardTextureXPosAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardTextureXPosAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardTextureYNegAttr();
        public pxr.UsdAttribute CreateModelCardTextureYNegAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardTextureYNegAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardTextureYPosAttr();
        public pxr.UsdAttribute CreateModelCardTextureYPosAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardTextureYPosAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardTextureZNegAttr();
        public pxr.UsdAttribute CreateModelCardTextureZNegAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardTextureZNegAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelCardTextureZPosAttr();
        public pxr.UsdAttribute CreateModelCardTextureZPosAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelCardTextureZPosAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelDrawModeAttr();
        public pxr.UsdAttribute CreateModelDrawModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelDrawModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateModelDrawModeColorAttr();
        public pxr.UsdAttribute CreateModelDrawModeColorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateModelDrawModeColorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomModelAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdGeomConstraintTarget GetConstraintTarget(string constraintName);
        public pxr.UsdGeomConstraintTargetVector GetConstraintTargets();
        public bool GetExtentsHint(pxr.VtVec3fArray extents);
        public bool GetExtentsHint(pxr.VtVec3fArray extents, pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetExtentsHintAttr();
        public pxr.UsdAttribute GetModelApplyDrawModeAttr();
        public pxr.UsdAttribute GetModelCardGeometryAttr();
        public pxr.UsdAttribute GetModelCardTextureXNegAttr();
        public pxr.UsdAttribute GetModelCardTextureXPosAttr();
        public pxr.UsdAttribute GetModelCardTextureYNegAttr();
        public pxr.UsdAttribute GetModelCardTextureYPosAttr();
        public pxr.UsdAttribute GetModelCardTextureZNegAttr();
        public pxr.UsdAttribute GetModelCardTextureZPosAttr();
        public pxr.UsdAttribute GetModelDrawModeAttr();
        public pxr.UsdAttribute GetModelDrawModeColorAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool SetExtentsHint(pxr.VtVec3fArray extents);
        public bool SetExtentsHint(pxr.VtVec3fArray extents, pxr.UsdTimeCode time);
    }

    public class UsdGeomMotionAPI : pxr.UsdAPISchemaBase
    {
        public UsdGeomMotionAPI() {}
        public UsdGeomMotionAPI(pxr.UsdPrim prim) {}
        public UsdGeomMotionAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdGeomMotionAPI Apply(pxr.UsdPrim prim);
        public float ComputeVelocityScale();
        public float ComputeVelocityScale(pxr.UsdTimeCode time);
        public pxr.UsdAttribute CreateVelocityScaleAttr();
        public pxr.UsdAttribute CreateVelocityScaleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVelocityScaleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomMotionAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetVelocityScaleAttr();
    }

    public class UsdGeomNurbsCurves : pxr.UsdGeomCurves
    {
        public UsdGeomNurbsCurves() {}
        public UsdGeomNurbsCurves(pxr.UsdPrim prim) {}
        public UsdGeomNurbsCurves(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateKnotsAttr();
        public pxr.UsdAttribute CreateKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateOrderAttr();
        public pxr.UsdAttribute CreateOrderAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateOrderAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRangesAttr();
        public pxr.UsdAttribute CreateRangesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRangesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomNurbsCurves Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomNurbsCurves Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetKnotsAttr();
        public pxr.UsdAttribute GetOrderAttr();
        public pxr.UsdAttribute GetRangesAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomNurbsPatch : pxr.UsdGeomPointBased
    {
        public UsdGeomNurbsPatch() {}
        public UsdGeomNurbsPatch(pxr.UsdPrim prim) {}
        public UsdGeomNurbsPatch(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreatePointWeightsAttr();
        public pxr.UsdAttribute CreatePointWeightsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePointWeightsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTrimCurveCountsAttr();
        public pxr.UsdAttribute CreateTrimCurveCountsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTrimCurveCountsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTrimCurveKnotsAttr();
        public pxr.UsdAttribute CreateTrimCurveKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTrimCurveKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTrimCurveOrdersAttr();
        public pxr.UsdAttribute CreateTrimCurveOrdersAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTrimCurveOrdersAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTrimCurvePointsAttr();
        public pxr.UsdAttribute CreateTrimCurvePointsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTrimCurvePointsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTrimCurveRangesAttr();
        public pxr.UsdAttribute CreateTrimCurveRangesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTrimCurveRangesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTrimCurveVertexCountsAttr();
        public pxr.UsdAttribute CreateTrimCurveVertexCountsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTrimCurveVertexCountsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateUFormAttr();
        public pxr.UsdAttribute CreateUFormAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateUFormAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateUKnotsAttr();
        public pxr.UsdAttribute CreateUKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateUKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateUOrderAttr();
        public pxr.UsdAttribute CreateUOrderAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateUOrderAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateURangeAttr();
        public pxr.UsdAttribute CreateURangeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateURangeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateUVertexCountAttr();
        public pxr.UsdAttribute CreateUVertexCountAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateUVertexCountAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVFormAttr();
        public pxr.UsdAttribute CreateVFormAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVFormAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVKnotsAttr();
        public pxr.UsdAttribute CreateVKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVOrderAttr();
        public pxr.UsdAttribute CreateVOrderAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVOrderAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVRangeAttr();
        public pxr.UsdAttribute CreateVRangeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVRangeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVVertexCountAttr();
        public pxr.UsdAttribute CreateVVertexCountAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVVertexCountAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomNurbsPatch Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomNurbsPatch Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetPointWeightsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTrimCurveCountsAttr();
        public pxr.UsdAttribute GetTrimCurveKnotsAttr();
        public pxr.UsdAttribute GetTrimCurveOrdersAttr();
        public pxr.UsdAttribute GetTrimCurvePointsAttr();
        public pxr.UsdAttribute GetTrimCurveRangesAttr();
        public pxr.UsdAttribute GetTrimCurveVertexCountsAttr();
        public pxr.UsdAttribute GetUFormAttr();
        public pxr.UsdAttribute GetUKnotsAttr();
        public pxr.UsdAttribute GetUOrderAttr();
        public pxr.UsdAttribute GetURangeAttr();
        public pxr.UsdAttribute GetUVertexCountAttr();
        public pxr.UsdAttribute GetVFormAttr();
        public pxr.UsdAttribute GetVKnotsAttr();
        public pxr.UsdAttribute GetVOrderAttr();
        public pxr.UsdAttribute GetVRangeAttr();
        public pxr.UsdAttribute GetVVertexCountAttr();
    }

    public class UsdGeomPointBased : pxr.UsdGeomGprim
    {
        public UsdGeomPointBased() {}
        public UsdGeomPointBased(pxr.UsdPrim prim) {}
        public UsdGeomPointBased(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(pxr.VtVec3fArray points, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(pxr.VtVec3fArray points, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public bool ComputePointsAtTime(pxr.VtVec3fArray points, pxr.UsdTimeCode time, pxr.UsdTimeCode baseTime);
        public static bool ComputePointsAtTime(pxr.VtVec3fArray points, pxr.UsdStageWeakPtr stage, pxr.UsdTimeCode time, pxr.VtVec3fArray positions, pxr.VtVec3fArray velocities, pxr.UsdTimeCode velocitiesSampleTime, pxr.VtVec3fArray accelerations, float velocityScale);
        public bool ComputePointsAtTimes(pxr.VtVec3fArrayVector pointsArray, pxr.UsdTimeCodeVector times, pxr.UsdTimeCode baseTime);
        public pxr.UsdAttribute CreateAccelerationsAttr();
        public pxr.UsdAttribute CreateAccelerationsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAccelerationsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateNormalsAttr();
        public pxr.UsdAttribute CreateNormalsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateNormalsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreatePointsAttr();
        public pxr.UsdAttribute CreatePointsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePointsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVelocitiesAttr();
        public pxr.UsdAttribute CreateVelocitiesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVelocitiesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomPointBased Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAccelerationsAttr();
        public pxr.UsdAttribute GetNormalsAttr();
        public pxr.TfToken GetNormalsInterpolation();
        public pxr.UsdAttribute GetPointsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetVelocitiesAttr();
        public bool SetNormalsInterpolation(pxr.TfToken interpolation);
    }

    public class UsdGeomPointInstancer : pxr.UsdGeomBoundable
    {
        public UsdGeomPointInstancer() {}
        public UsdGeomPointInstancer(pxr.UsdPrim prim) {}
        public UsdGeomPointInstancer(pxr.UsdSchemaBase schemaObj) {}
        public bool ActivateAllIds();
        public bool ActivateId(long id);
        public bool ActivateIds(pxr.VtInt64Array ids);
        public bool ComputeExtentAtTime(pxr.VtVec3fArray extent, pxr.UsdTimeCode time, pxr.UsdTimeCode baseTime);
        public bool ComputeExtentAtTime(pxr.VtVec3fArray extent, pxr.UsdTimeCode time, pxr.UsdTimeCode baseTime, pxr.GfMatrix4d transform);
        public bool ComputeExtentAtTimes(pxr.VtVec3fArrayVector extents, pxr.UsdTimeCodeVector times, pxr.UsdTimeCode baseTime);
        public bool ComputeExtentAtTimes(pxr.VtVec3fArrayVector extents, pxr.UsdTimeCodeVector times, pxr.UsdTimeCode baseTime, pxr.GfMatrix4d transform);
        public bool ComputeInstanceTransformsAtTime(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time, pxr.UsdTimeCode baseTime);
        public bool ComputeInstanceTransformsAtTime(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time, pxr.UsdTimeCode baseTime, pxr.UsdGeomPointInstancer.ProtoXformInclusion doProtoXforms);
        public bool ComputeInstanceTransformsAtTime(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time, pxr.UsdTimeCode baseTime, pxr.UsdGeomPointInstancer.ProtoXformInclusion doProtoXforms, pxr.UsdGeomPointInstancer.MaskApplication applyMask);
        public static bool ComputeInstanceTransformsAtTime(pxr.VtMatrix4dArray xforms, pxr.UsdStageWeakPtr stage, pxr.UsdTimeCode time, pxr.VtIntArray protoIndices, pxr.VtVec3fArray positions, pxr.VtVec3fArray velocities, pxr.UsdTimeCode velocitiesSampleTime, pxr.VtVec3fArray accelerations, pxr.VtVec3fArray scales, pxr.VtQuathArray orientations, pxr.VtVec3fArray angularVelocities, pxr.UsdTimeCode angularVelocitiesSampleTime, pxr.SdfPathVector protoPaths, pxr.UsdGeomBoolVector mask);
        public static bool ComputeInstanceTransformsAtTime(pxr.VtMatrix4dArray xforms, pxr.UsdStageWeakPtr stage, pxr.UsdTimeCode time, pxr.VtIntArray protoIndices, pxr.VtVec3fArray positions, pxr.VtVec3fArray velocities, pxr.UsdTimeCode velocitiesSampleTime, pxr.VtVec3fArray accelerations, pxr.VtVec3fArray scales, pxr.VtQuathArray orientations, pxr.VtVec3fArray angularVelocities, pxr.UsdTimeCode angularVelocitiesSampleTime, pxr.SdfPathVector protoPaths, pxr.UsdGeomBoolVector mask, float velocityScale);
        public bool ComputeInstanceTransformsAtTimes(pxr.VtMatrix4dArrayVector xformsArray, pxr.UsdTimeCodeVector times, pxr.UsdTimeCode baseTime);
        public bool ComputeInstanceTransformsAtTimes(pxr.VtMatrix4dArrayVector xformsArray, pxr.UsdTimeCodeVector times, pxr.UsdTimeCode baseTime, pxr.UsdGeomPointInstancer.ProtoXformInclusion doProtoXforms);
        public bool ComputeInstanceTransformsAtTimes(pxr.VtMatrix4dArrayVector xformsArray, pxr.UsdTimeCodeVector times, pxr.UsdTimeCode baseTime, pxr.UsdGeomPointInstancer.ProtoXformInclusion doProtoXforms, pxr.UsdGeomPointInstancer.MaskApplication applyMask);
        public pxr.UsdGeomBoolVector ComputeMaskAtTime(pxr.UsdTimeCode time);
        public pxr.UsdGeomBoolVector ComputeMaskAtTime(pxr.UsdTimeCode time, pxr.VtInt64Array ids);
        public pxr.UsdAttribute CreateAccelerationsAttr();
        public pxr.UsdAttribute CreateAccelerationsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAccelerationsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAngularVelocitiesAttr();
        public pxr.UsdAttribute CreateAngularVelocitiesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAngularVelocitiesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateIdsAttr();
        public pxr.UsdAttribute CreateIdsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIdsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateInvisibleIdsAttr();
        public pxr.UsdAttribute CreateInvisibleIdsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInvisibleIdsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateOrientationsAttr();
        public pxr.UsdAttribute CreateOrientationsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateOrientationsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreatePositionsAttr();
        public pxr.UsdAttribute CreatePositionsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePositionsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateProtoIndicesAttr();
        public pxr.UsdAttribute CreateProtoIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateProtoIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdRelationship CreatePrototypesRel();
        public pxr.UsdAttribute CreateScalesAttr();
        public pxr.UsdAttribute CreateScalesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScalesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVelocitiesAttr();
        public pxr.UsdAttribute CreateVelocitiesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVelocitiesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public bool DeactivateId(long id);
        public bool DeactivateIds(pxr.VtInt64Array ids);
        public static pxr.UsdGeomPointInstancer Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomPointInstancer Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAccelerationsAttr();
        public pxr.UsdAttribute GetAngularVelocitiesAttr();
        public pxr.UsdAttribute GetIdsAttr();
        public pxr.UsdAttribute GetInvisibleIdsAttr();
        public pxr.UsdAttribute GetOrientationsAttr();
        public pxr.UsdAttribute GetPositionsAttr();
        public pxr.UsdAttribute GetProtoIndicesAttr();
        public pxr.UsdRelationship GetPrototypesRel();
        public pxr.UsdAttribute GetScalesAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetVelocitiesAttr();
        public bool InvisId(long id, pxr.UsdTimeCode time);
        public bool InvisIds(pxr.VtInt64Array ids, pxr.UsdTimeCode time);
        public bool VisAllIds(pxr.UsdTimeCode time);
        public bool VisId(long id, pxr.UsdTimeCode time);
        public bool VisIds(pxr.VtInt64Array ids, pxr.UsdTimeCode time);
        public enum MaskApplication
        {
            public const pxr.UsdGeomPointInstancer.MaskApplication ApplyMask = 0;
            public const pxr.UsdGeomPointInstancer.MaskApplication IgnoreMask = 1;
            public int value__;
        }
        public enum ProtoXformInclusion
        {
            public const pxr.UsdGeomPointInstancer.ProtoXformInclusion ExcludeProtoXform = 1;
            public const pxr.UsdGeomPointInstancer.ProtoXformInclusion IncludeProtoXform = 0;
            public int value__;
        }
    }

    public class UsdGeomPoints : pxr.UsdGeomPointBased
    {
        public UsdGeomPoints() {}
        public UsdGeomPoints(pxr.UsdPrim prim) {}
        public UsdGeomPoints(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(pxr.VtVec3fArray points, pxr.VtFloatArray widths, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(pxr.VtVec3fArray points, pxr.VtFloatArray widths, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateIdsAttr();
        public pxr.UsdAttribute CreateIdsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIdsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWidthsAttr();
        public pxr.UsdAttribute CreateWidthsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWidthsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomPoints Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomPoints Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetIdsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetWidthsAttr();
        public pxr.TfToken GetWidthsInterpolation();
        public bool SetWidthsInterpolation(pxr.TfToken interpolation);
    }

    public class UsdGeomPrimvar : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdGeomPrimvar() {}
        public UsdGeomPrimvar(pxr.UsdAttribute attr) {}
        public void BlockIndices();
        public bool ComputeFlattened(pxr.VtValue value);
        public bool ComputeFlattened(pxr.VtValue value, pxr.UsdTimeCode time);
        public static bool ComputeFlattened(pxr.VtValue value, pxr.VtValue attrVal, pxr.VtIntArray indices, out string errString);
        public pxr.UsdAttribute CreateIndicesAttr();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttribute GetAttr();
        public pxr.TfToken GetBaseName();
        public void GetDeclarationInfo(pxr.TfToken name, pxr.SdfValueTypeName typeName, pxr.TfToken interpolation, out int elementSize);
        public int GetElementSize();
        public bool GetIndices(pxr.VtIntArray indices);
        public bool GetIndices(pxr.VtIntArray indices, pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetIndicesAttr();
        public pxr.TfToken GetInterpolation();
        public pxr.TfToken GetName();
        public pxr.TfToken GetNamespace();
        public pxr.TfToken GetPrimvarName();
        public bool GetTimeSamples(pxr.StdDoubleVector times);
        public pxr.SdfValueTypeName GetTypeName();
        public int GetUnauthoredValuesIndex();
        public bool HasAuthoredElementSize();
        public bool HasAuthoredInterpolation();
        public bool HasAuthoredValue();
        public bool HasValue();
        public bool IsDefined();
        public bool IsIdTarget();
        public bool IsIndexed();
        public static bool IsPrimvar(pxr.UsdAttribute attr);
        public static bool IsPrimvarRelatedPropertyName(pxr.TfToken name);
        public static bool IsValidInterpolation(pxr.TfToken interpolation);
        public static bool IsValidPrimvarName(pxr.TfToken name);
        public bool NameContainsNamespaces();
        public bool SetElementSize(int eltSize);
        public bool SetIdTarget(pxr.SdfPath path);
        public bool SetIndices(pxr.VtIntArray indices);
        public bool SetIndices(pxr.VtIntArray indices, pxr.UsdTimeCode time);
        public bool SetInterpolation(pxr.TfToken interpolation);
        public bool SetUnauthoredValuesIndex(int unauthoredValuesIndex);
        public pxr.StdStringVector SplitName();
        public static pxr.TfToken StripPrimvarsName(pxr.TfToken name);
        public bool ValueMightBeTimeVarying();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomPrimvarVector : System.Collections.Generic.IEnumerable<pxr.UsdGeomPrimvar>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdGeomPrimvar this[int index] { get; set; }
        public UsdGeomPrimvarVector() {}
        public UsdGeomPrimvarVector(pxr.UsdGeomPrimvarVector other) {}
        public UsdGeomPrimvarVector(System.Collections.ICollection c) {}
        public UsdGeomPrimvarVector(int capacity) {}
        public void Add(pxr.UsdGeomPrimvar x);
        public void AddRange(pxr.UsdGeomPrimvarVector values);
        public void Clear();
        public void CopyTo(pxr.UsdGeomPrimvar[] array);
        public void CopyTo(pxr.UsdGeomPrimvar[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdGeomPrimvar[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomPrimvarVector.UsdGeomPrimvarVectorEnumerator GetEnumerator();
        public pxr.UsdGeomPrimvarVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdGeomPrimvar x);
        public void InsertRange(int index, pxr.UsdGeomPrimvarVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomPrimvarVector Repeat(pxr.UsdGeomPrimvar value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomPrimvarVector values);
        public sealed class UsdGeomPrimvarVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdGeomPrimvar>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdGeomPrimvar Current { get; }
            public UsdGeomPrimvarVectorEnumerator(pxr.UsdGeomPrimvarVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdGeomScope : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdGeomScope() {}
        public UsdGeomScope(pxr.UsdPrim prim) {}
        public UsdGeomScope(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdGeomScope Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomScope Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomSphere : pxr.UsdGeomGprim
    {
        public UsdGeomSphere() {}
        public UsdGeomSphere(pxr.UsdPrim prim) {}
        public UsdGeomSphere(pxr.UsdSchemaBase schemaObj) {}
        public static bool ComputeExtent(double radius, pxr.VtVec3fArray extent);
        public static bool ComputeExtent(double radius, pxr.GfMatrix4d transform, pxr.VtVec3fArray extent);
        public pxr.UsdAttribute CreateExtentAttr();
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExtentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomSphere Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomSphere Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetExtentAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomSubset : pxr.UsdTyped
    {
        public UsdGeomSubset() {}
        public UsdGeomSubset(pxr.UsdPrim prim) {}
        public UsdGeomSubset(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateElementTypeAttr();
        public pxr.UsdAttribute CreateElementTypeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateElementTypeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFamilyNameAttr();
        public pxr.UsdAttribute CreateFamilyNameAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFamilyNameAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomSubset CreateGeomSubset(pxr.UsdGeomImageable geom, pxr.TfToken subsetName, pxr.TfToken elementType, pxr.VtIntArray indices);
        public static pxr.UsdGeomSubset CreateGeomSubset(pxr.UsdGeomImageable geom, pxr.TfToken subsetName, pxr.TfToken elementType, pxr.VtIntArray indices, pxr.TfToken familyName);
        public static pxr.UsdGeomSubset CreateGeomSubset(pxr.UsdGeomImageable geom, pxr.TfToken subsetName, pxr.TfToken elementType, pxr.VtIntArray indices, pxr.TfToken familyName, pxr.TfToken familyType);
        public pxr.UsdAttribute CreateIndicesAttr();
        public pxr.UsdAttribute CreateIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdGeomSubset CreateUniqueGeomSubset(pxr.UsdGeomImageable geom, pxr.TfToken subsetName, pxr.TfToken elementType, pxr.VtIntArray indices);
        public static pxr.UsdGeomSubset CreateUniqueGeomSubset(pxr.UsdGeomImageable geom, pxr.TfToken subsetName, pxr.TfToken elementType, pxr.VtIntArray indices, pxr.TfToken familyName);
        public static pxr.UsdGeomSubset CreateUniqueGeomSubset(pxr.UsdGeomImageable geom, pxr.TfToken subsetName, pxr.TfToken elementType, pxr.VtIntArray indices, pxr.TfToken familyName, pxr.TfToken familyType);
        public static pxr.UsdGeomSubset Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomSubset Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.SWIGTYPE_p_std__setT_TfToken_TfTokenFastArbitraryLessThan_t GetAllGeomSubsetFamilyNames(pxr.UsdGeomImageable geom);
        public static pxr.UsdGeomSubsetVector GetAllGeomSubsets(pxr.UsdGeomImageable geom);
        public pxr.UsdAttribute GetElementTypeAttr();
        public pxr.UsdAttribute GetFamilyNameAttr();
        public static pxr.TfToken GetFamilyType(pxr.UsdGeomImageable geom, pxr.TfToken familyName);
        public static pxr.UsdGeomSubsetVector GetGeomSubsets(pxr.UsdGeomImageable geom);
        public static pxr.UsdGeomSubsetVector GetGeomSubsets(pxr.UsdGeomImageable geom, pxr.TfToken elementType);
        public static pxr.UsdGeomSubsetVector GetGeomSubsets(pxr.UsdGeomImageable geom, pxr.TfToken elementType, pxr.TfToken familyName);
        public pxr.UsdAttribute GetIndicesAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public static pxr.VtIntArray GetUnassignedIndices(pxr.UsdGeomSubsetVector subsets, System.UInt32 elementCount);
        public static pxr.VtIntArray GetUnassignedIndices(pxr.UsdGeomSubsetVector subsets, System.UInt32 elementCount, pxr.UsdTimeCode time);
        public static bool SetFamilyType(pxr.UsdGeomImageable geom, pxr.TfToken familyName, pxr.TfToken familyType);
        public static bool ValidateFamily(pxr.UsdGeomImageable geom, pxr.TfToken elementType, pxr.TfToken familyName, out string reason);
        public static bool ValidateSubsets(pxr.UsdGeomSubsetVector subsets, System.UInt32 elementCount, pxr.TfToken familyType, out string reason);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomSubsetVector : System.Collections.Generic.IEnumerable<pxr.UsdGeomSubset>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdGeomSubset this[int index] { get; set; }
        public UsdGeomSubsetVector() {}
        public UsdGeomSubsetVector(pxr.UsdGeomSubsetVector other) {}
        public UsdGeomSubsetVector(System.Collections.ICollection c) {}
        public UsdGeomSubsetVector(int capacity) {}
        public void Add(pxr.UsdGeomSubset x);
        public void AddRange(pxr.UsdGeomSubsetVector values);
        public void Clear();
        public void CopyTo(pxr.UsdGeomSubset[] array);
        public void CopyTo(pxr.UsdGeomSubset[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdGeomSubset[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomSubsetVector.UsdGeomSubsetVectorEnumerator GetEnumerator();
        public pxr.UsdGeomSubsetVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdGeomSubset x);
        public void InsertRange(int index, pxr.UsdGeomSubsetVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomSubsetVector Repeat(pxr.UsdGeomSubset value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomSubsetVector values);
        public sealed class UsdGeomSubsetVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdGeomSubset>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdGeomSubset Current { get; }
            public UsdGeomSubsetVectorEnumerator(pxr.UsdGeomSubsetVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdGeomTokens : System.IDisposable
    {
        public static pxr.TfToken accelerations;
        public static pxr.TfToken all;
        public static pxr.TfToken angularVelocities;
        public static pxr.TfToken axis;
        public static pxr.TfToken basis;
        public static pxr.TfToken bezier;
        public static pxr.TfToken bilinear;
        public static pxr.TfToken boundaries;
        public static pxr.TfToken bounds;
        public static pxr.TfToken box;
        public static pxr.TfToken bspline;
        public static pxr.TfToken cards;
        public static pxr.TfToken catmullClark;
        public static pxr.TfToken catmullRom;
        public static pxr.TfToken clippingPlanes;
        public static pxr.TfToken clippingRange;
        public static pxr.TfToken closed;
        public static pxr.TfToken constant;
        public static pxr.TfToken cornerIndices;
        public static pxr.TfToken cornerSharpnesses;
        public static pxr.TfToken cornersOnly;
        public static pxr.TfToken cornersPlus1;
        public static pxr.TfToken cornersPlus2;
        public static pxr.TfToken creaseIndices;
        public static pxr.TfToken creaseLengths;
        public static pxr.TfToken creaseSharpnesses;
        public static pxr.TfToken cross;
        public static pxr.TfToken cubic;
        public static pxr.TfToken curveVertexCounts;
        public static pxr.TfToken default_;
        public static pxr.TfToken doubleSided;
        public static pxr.TfToken edgeAndCorner;
        public static pxr.TfToken edgeOnly;
        public static pxr.TfToken elementSize;
        public static pxr.TfToken elementType;
        public static pxr.TfToken extent;
        public static pxr.TfToken extentsHint;
        public static pxr.TfToken face;
        public static pxr.TfToken faceVarying;
        public static pxr.TfToken faceVaryingLinearInterpolation;
        public static pxr.TfToken faceVertexCounts;
        public static pxr.TfToken faceVertexIndices;
        public static pxr.TfToken familyName;
        public static pxr.TfToken focalLength;
        public static pxr.TfToken focusDistance;
        public static pxr.TfToken fromTexture;
        public static pxr.TfToken fStop;
        public static pxr.TfToken guide;
        public static pxr.TfToken height;
        public static pxr.TfToken hermite;
        public static pxr.TfToken holeIndices;
        public static pxr.TfToken horizontalAperture;
        public static pxr.TfToken horizontalApertureOffset;
        public static pxr.TfToken ids;
        public static pxr.TfToken inactiveIds;
        public static pxr.TfToken indices;
        public static pxr.TfToken inherited;
        public static pxr.TfToken interpolateBoundary;
        public static pxr.TfToken interpolation;
        public static pxr.TfToken invisible;
        public static pxr.TfToken invisibleIds;
        public static pxr.TfToken knots;
        public static pxr.TfToken left;
        public static pxr.TfToken leftHanded;
        public static pxr.TfToken linear;
        public static pxr.TfToken loop;
        public static pxr.TfToken metersPerUnit;
        public static pxr.TfToken modelApplyDrawMode;
        public static pxr.TfToken modelCardGeometry;
        public static pxr.TfToken modelCardTextureXNeg;
        public static pxr.TfToken modelCardTextureXPos;
        public static pxr.TfToken modelCardTextureYNeg;
        public static pxr.TfToken modelCardTextureYPos;
        public static pxr.TfToken modelCardTextureZNeg;
        public static pxr.TfToken modelCardTextureZPos;
        public static pxr.TfToken modelDrawMode;
        public static pxr.TfToken modelDrawModeColor;
        public static pxr.TfToken mono;
        public static pxr.TfToken motionVelocityScale;
        public static pxr.TfToken none;
        public static pxr.TfToken nonOverlapping;
        public static pxr.TfToken nonperiodic;
        public static pxr.TfToken normals;
        public static pxr.TfToken open;
        public static pxr.TfToken order;
        public static pxr.TfToken orientation;
        public static pxr.TfToken orientations;
        public static pxr.TfToken origin;
        public static pxr.TfToken orthographic;
        public static pxr.TfToken partition;
        public static pxr.TfToken periodic;
        public static pxr.TfToken perspective;
        public static pxr.TfToken pinned;
        public static pxr.TfToken pivot;
        public static pxr.TfToken points;
        public static pxr.TfToken pointWeights;
        public static pxr.TfToken positions;
        public static pxr.TfToken power;
        public static pxr.TfToken primvarsDisplayColor;
        public static pxr.TfToken primvarsDisplayOpacity;
        public static pxr.TfToken projection;
        public static pxr.TfToken protoIndices;
        public static pxr.TfToken prototypes;
        public static pxr.TfToken proxy;
        public static pxr.TfToken proxyPrim;
        public static pxr.TfToken purpose;
        public static pxr.TfToken radius;
        public static pxr.TfToken ranges;
        public static pxr.TfToken render;
        public static pxr.TfToken right;
        public static pxr.TfToken rightHanded;
        public static pxr.TfToken scales;
        public static pxr.TfToken shutterClose;
        public static pxr.TfToken shutterOpen;
        public static pxr.TfToken size;
        public static pxr.TfToken smooth;
        public static pxr.TfToken stereoRole;
        public static pxr.TfToken subdivisionScheme;
        protected bool swigCMemOwn;
        public static pxr.TfToken tangents;
        public static pxr.TfToken triangleSubdivisionRule;
        public static pxr.TfToken trimCurveCounts;
        public static pxr.TfToken trimCurveKnots;
        public static pxr.TfToken trimCurveOrders;
        public static pxr.TfToken trimCurvePoints;
        public static pxr.TfToken trimCurveRanges;
        public static pxr.TfToken trimCurveVertexCounts;
        public static pxr.TfToken type;
        public static pxr.TfToken uForm;
        public static pxr.TfToken uKnots;
        public static pxr.TfToken unauthoredValuesIndex;
        public static pxr.TfToken uniform;
        public static pxr.TfToken unrestricted;
        public static pxr.TfToken uOrder;
        public static pxr.TfToken upAxis;
        public static pxr.TfToken uRange;
        public static pxr.TfToken uVertexCount;
        public static pxr.TfToken varying;
        public static pxr.TfToken velocities;
        public static pxr.TfToken vertex;
        public static pxr.TfToken verticalAperture;
        public static pxr.TfToken verticalApertureOffset;
        public static pxr.TfToken vForm;
        public static pxr.TfToken visibility;
        public static pxr.TfToken vKnots;
        public static pxr.TfToken vOrder;
        public static pxr.TfToken vRange;
        public static pxr.TfToken vVertexCount;
        public static pxr.TfToken widths;
        public static pxr.TfToken wrap;
        public static pxr.TfToken x;
        public static pxr.TfToken xformOpOrder;
        public static pxr.TfToken y;
        public static pxr.TfToken z;
        public virtual void Dispose();
    }

    public class UsdGeomXform : pxr.UsdGeomXformable
    {
        public UsdGeomXform() {}
        public UsdGeomXform(pxr.UsdPrim prim) {}
        public UsdGeomXform(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdGeomXform Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomXform Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdGeomXformable : pxr.UsdGeomImageable
    {
        public UsdGeomXformable() {}
        public UsdGeomXformable(pxr.UsdPrim prim) {}
        public UsdGeomXformable(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdGeomXformOp AddOrientOp();
        public pxr.UsdGeomXformOp AddOrientOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddOrientOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddOrientOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateXOp();
        public pxr.UsdGeomXformOp AddRotateXOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateXOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateXOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateXYZOp();
        public pxr.UsdGeomXformOp AddRotateXYZOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateXYZOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateXYZOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateXZYOp();
        public pxr.UsdGeomXformOp AddRotateXZYOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateXZYOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateXZYOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateYOp();
        public pxr.UsdGeomXformOp AddRotateYOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateYOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateYOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateYXZOp();
        public pxr.UsdGeomXformOp AddRotateYXZOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateYXZOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateYXZOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateYZXOp();
        public pxr.UsdGeomXformOp AddRotateYZXOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateYZXOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateYZXOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateZOp();
        public pxr.UsdGeomXformOp AddRotateZOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateZOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateZOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateZXYOp();
        public pxr.UsdGeomXformOp AddRotateZXYOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateZXYOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateZXYOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddRotateZYXOp();
        public pxr.UsdGeomXformOp AddRotateZYXOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddRotateZYXOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddRotateZYXOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddScaleOp();
        public pxr.UsdGeomXformOp AddScaleOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddScaleOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddScaleOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddTransformOp();
        public pxr.UsdGeomXformOp AddTransformOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddTransformOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddTransformOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddTranslateOp();
        public pxr.UsdGeomXformOp AddTranslateOp(pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddTranslateOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddTranslateOp(pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public pxr.UsdGeomXformOp AddXformOp(pxr.UsdGeomXformOp.Type opType);
        public pxr.UsdGeomXformOp AddXformOp(pxr.UsdGeomXformOp.Type opType, pxr.UsdGeomXformOp.Precision precision);
        public pxr.UsdGeomXformOp AddXformOp(pxr.UsdGeomXformOp.Type opType, pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix);
        public pxr.UsdGeomXformOp AddXformOp(pxr.UsdGeomXformOp.Type opType, pxr.UsdGeomXformOp.Precision precision, pxr.TfToken opSuffix, bool isInverseOp);
        public bool ClearXformOpOrder();
        public pxr.UsdAttribute CreateXformOpOrderAttr();
        public pxr.UsdAttribute CreateXformOpOrderAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateXformOpOrderAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdGeomXformable Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public bool GetLocalTransformation(pxr.GfMatrix4d transform, out bool resetsXformStack);
        public static bool GetLocalTransformation(pxr.GfMatrix4d transform, pxr.UsdGeomXformOpVector ops, pxr.UsdTimeCode time);
        public bool GetLocalTransformation(pxr.GfMatrix4d transform, out bool resetsXformStack, pxr.UsdGeomXformOpVector ops);
        public bool GetLocalTransformation(pxr.GfMatrix4d transform, out bool resetsXformStack, pxr.UsdTimeCode time);
        public bool GetLocalTransformation(pxr.GfMatrix4d transform, out bool resetsXformStack, pxr.UsdGeomXformOpVector ops, pxr.UsdTimeCode time);
        public pxr.UsdGeomXformOpVector GetOrderedXformOps(out bool resetsXformStack);
        public bool GetResetXformStack();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool GetTimeSamples(pxr.StdDoubleVector times);
        public static bool GetTimeSamples(pxr.UsdGeomXformOpVector orderedXformOps, pxr.StdDoubleVector times);
        public static bool GetTimeSamplesInInterval(pxr.UsdGeomXformOpVector orderedXformOps, pxr.GfInterval interval, pxr.StdDoubleVector times);
        public pxr.UsdAttribute GetXformOpOrderAttr();
        public static bool IsTransformationAffectedByAttrNamed(pxr.TfToken attrName);
        public pxr.UsdGeomXformOp MakeMatrixXform();
        public bool SetResetXformStack(bool resetXform);
        public bool SetXformOpOrder(pxr.UsdGeomXformOpVector orderedXformOps);
        public bool SetXformOpOrder(pxr.UsdGeomXformOpVector orderedXformOps, bool resetXformStack);
        public bool TransformMightBeTimeVarying();
        public bool TransformMightBeTimeVarying(pxr.UsdGeomXformOpVector ops);
        public class XformQuery : System.IDisposable
        {
            protected bool swigCMemOwn;
            public XformQuery() {}
            public XformQuery(pxr.UsdGeomXformable xformable) {}
            public virtual void Dispose();
            protected virtual void Finalize();
            public bool GetLocalTransformation(pxr.GfMatrix4d transform, pxr.UsdTimeCode time);
            public bool GetResetXformStack();
            public bool GetTimeSamples(pxr.StdDoubleVector times);
            public bool IsAttributeIncludedInLocalTransform(pxr.TfToken attrName);
            public bool TransformMightBeTimeVarying();
        }
    }

    public class UsdGeomXformCache : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdGeomXformCache() {}
        public UsdGeomXformCache(pxr.UsdTimeCode time) {}
        public void Clear();
        public pxr.GfMatrix4d ComputeRelativeTransform(pxr.UsdPrim prim, pxr.UsdPrim ancestor, pxr.SWIGTYPE_p_bool resetXformStack);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.GfMatrix4d GetLocalToWorldTransform(pxr.UsdPrim prim);
        public pxr.GfMatrix4d GetLocalTransformation(pxr.UsdPrim prim, out bool resetsXformStack);
        public pxr.GfMatrix4d GetParentToWorldTransform(pxr.UsdPrim prim);
        public bool GetResetXformStack(pxr.UsdPrim prim);
        public pxr.UsdTimeCode GetTime();
        public bool IsAttributeIncludedInLocalTransform(pxr.UsdPrim prim, pxr.TfToken attrName);
        public void SetTime(pxr.UsdTimeCode time);
        public void Swap(pxr.UsdGeomXformCache other);
        public bool TransformMightBeTimeVarying(pxr.UsdPrim prim);
    }

    public class UsdGeomXformOp : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdGeomXformOp() {}
        public UsdGeomXformOp(pxr.UsdAttribute attr) {}
        public UsdGeomXformOp(pxr.UsdAttribute attr, bool isInverseOp) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttribute GetAttr();
        public pxr.TfToken GetBaseName();
        public pxr.TfToken GetName();
        public pxr.TfToken GetNamespace();
        public System.UInt32 GetNumTimeSamples();
        public pxr.TfToken GetOpName();
        public static pxr.TfToken GetOpName(pxr.UsdGeomXformOp.Type opType);
        public static pxr.TfToken GetOpName(pxr.UsdGeomXformOp.Type opType, pxr.TfToken opSuffix);
        public static pxr.TfToken GetOpName(pxr.UsdGeomXformOp.Type opType, pxr.TfToken opSuffix, bool inverse);
        public pxr.GfMatrix4d GetOpTransform(pxr.UsdTimeCode time);
        public static pxr.GfMatrix4d GetOpTransform(pxr.UsdGeomXformOp.Type opType, pxr.VtValue opVal);
        public static pxr.GfMatrix4d GetOpTransform(pxr.UsdGeomXformOp.Type opType, pxr.VtValue opVal, bool isInverseOp);
        public pxr.UsdGeomXformOp.Type GetOpType();
        public static pxr.UsdGeomXformOp.Type GetOpTypeEnum(pxr.TfToken opTypeToken);
        public static pxr.TfToken GetOpTypeToken(pxr.UsdGeomXformOp.Type opType);
        public pxr.UsdGeomXformOp.Precision GetPrecision();
        public static pxr.UsdGeomXformOp.Precision GetPrecisionFromValueTypeName(pxr.SdfValueTypeName typeName);
        public bool GetTimeSamples(pxr.StdDoubleVector times);
        public pxr.SdfValueTypeName GetTypeName();
        public static pxr.SdfValueTypeName GetValueTypeName(pxr.UsdGeomXformOp.Type opType, pxr.UsdGeomXformOp.Precision precision);
        public bool HasSuffix(pxr.TfToken suffix);
        public bool IsDefined();
        public bool IsInverseOp();
        public static bool IsXformOp(pxr.TfToken attrName);
        public static bool IsXformOp(pxr.UsdAttribute attr);
        public bool MightBeTimeVarying();
        public bool Set(pxr.GfMatrix4d value);
        public bool Set(pxr.GfMatrix4d value, pxr.UsdTimeCode time);
        public pxr.StdStringVector SplitName();
        public enum Precision
        {
            public const pxr.UsdGeomXformOp.Precision PrecisionDouble = 0;
            public const pxr.UsdGeomXformOp.Precision PrecisionFloat = 1;
            public const pxr.UsdGeomXformOp.Precision PrecisionHalf = 2;
            public int value__;
        }
        public enum Type
        {
            public const pxr.UsdGeomXformOp.Type TypeInvalid = 0;
            public const pxr.UsdGeomXformOp.Type TypeOrient = 12;
            public const pxr.UsdGeomXformOp.Type TypeRotateX = 3;
            public const pxr.UsdGeomXformOp.Type TypeRotateXYZ = 6;
            public const pxr.UsdGeomXformOp.Type TypeRotateXZY = 7;
            public const pxr.UsdGeomXformOp.Type TypeRotateY = 4;
            public const pxr.UsdGeomXformOp.Type TypeRotateYXZ = 8;
            public const pxr.UsdGeomXformOp.Type TypeRotateYZX = 9;
            public const pxr.UsdGeomXformOp.Type TypeRotateZ = 5;
            public const pxr.UsdGeomXformOp.Type TypeRotateZXY = 10;
            public const pxr.UsdGeomXformOp.Type TypeRotateZYX = 11;
            public const pxr.UsdGeomXformOp.Type TypeScale = 2;
            public const pxr.UsdGeomXformOp.Type TypeTransform = 13;
            public const pxr.UsdGeomXformOp.Type TypeTranslate = 1;
            public int value__;
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdGeomXformOpVector : System.Collections.Generic.IEnumerable<pxr.UsdGeomXformOp>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdGeomXformOp this[int index] { get; set; }
        public UsdGeomXformOpVector() {}
        public UsdGeomXformOpVector(pxr.UsdGeomXformOpVector other) {}
        public UsdGeomXformOpVector(System.Collections.ICollection c) {}
        public UsdGeomXformOpVector(int capacity) {}
        public void Add(pxr.UsdGeomXformOp x);
        public void AddRange(pxr.UsdGeomXformOpVector values);
        public void Clear();
        public void CopyTo(pxr.UsdGeomXformOp[] array);
        public void CopyTo(pxr.UsdGeomXformOp[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdGeomXformOp[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdGeomXformOpVector.UsdGeomXformOpVectorEnumerator GetEnumerator();
        public pxr.UsdGeomXformOpVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdGeomXformOp x);
        public void InsertRange(int index, pxr.UsdGeomXformOpVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdGeomXformOpVector Repeat(pxr.UsdGeomXformOp value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdGeomXformOpVector values);
        public sealed class UsdGeomXformOpVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdGeomXformOp>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdGeomXformOp Current { get; }
            public UsdGeomXformOpVectorEnumerator(pxr.UsdGeomXformOpVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdInherits : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool AddInherit(pxr.SdfPath primPath);
        public bool AddInherit(pxr.SdfPath primPath, pxr.UsdListPosition position);
        public bool ClearInherits();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPathVector GetAllDirectInherits();
        public pxr.UsdPrim GetPrim();
        public bool RemoveInherit(pxr.SdfPath primPath);
        public bool SetInherits(pxr.SdfPathVector items);
    }

    public enum UsdInterpolationType
    {
        public const pxr.UsdInterpolationType UsdInterpolationTypeHeld = 0;
        public const pxr.UsdInterpolationType UsdInterpolationTypeLinear = 1;
        public int value__;
    }

    public enum UsdListPosition
    {
        public const pxr.UsdListPosition UsdListPositionBackOfAppendList = 3;
        public const pxr.UsdListPosition UsdListPositionBackOfPrependList = 1;
        public const pxr.UsdListPosition UsdListPositionFrontOfAppendList = 2;
        public const pxr.UsdListPosition UsdListPositionFrontOfPrependList = 0;
        public int value__;
    }

    public enum UsdLoadPolicy
    {
        public const pxr.UsdLoadPolicy UsdLoadWithDescendants = 0;
        public const pxr.UsdLoadPolicy UsdLoadWithoutDescendants = 1;
        public int value__;
    }

    public class UsdLuxCylinderLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxCylinderLight() {}
        public UsdLuxCylinderLight(pxr.UsdPrim prim) {}
        public UsdLuxCylinderLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateLengthAttr();
        public pxr.UsdAttribute CreateLengthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateLengthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTreatAsLineAttr();
        public pxr.UsdAttribute CreateTreatAsLineAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTreatAsLineAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdLuxCylinderLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxCylinderLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetLengthAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTreatAsLineAttr();
    }

    public class UsdLuxDiskLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxDiskLight() {}
        public UsdLuxDiskLight(pxr.UsdPrim prim) {}
        public UsdLuxDiskLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdLuxDiskLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxDiskLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdLuxDistantLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxDistantLight() {}
        public UsdLuxDistantLight(pxr.UsdPrim prim) {}
        public UsdLuxDistantLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateAngleAttr();
        public pxr.UsdAttribute CreateAngleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAngleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateIntensityAttr();
        public pxr.UsdAttribute CreateIntensityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIntensityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdLuxDistantLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxDistantLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAngleAttr();
        public pxr.UsdAttribute GetIntensityAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdLuxDomeLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxDomeLight() {}
        public UsdLuxDomeLight(pxr.UsdPrim prim) {}
        public UsdLuxDomeLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdRelationship CreatePortalsRel();
        public pxr.UsdAttribute CreateTextureFileAttr();
        public pxr.UsdAttribute CreateTextureFileAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureFileAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureFormatAttr();
        public pxr.UsdAttribute CreateTextureFormatAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureFormatAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdLuxDomeLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxDomeLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdRelationship GetPortalsRel();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTextureFileAttr();
        public pxr.UsdAttribute GetTextureFormatAttr();
        public void OrientToStageUpAxis();
    }

    public class UsdLuxGeometryLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxGeometryLight() {}
        public UsdLuxGeometryLight(pxr.UsdPrim prim) {}
        public UsdLuxGeometryLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdRelationship CreateGeometryRel();
        public static pxr.UsdLuxGeometryLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxGeometryLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdRelationship GetGeometryRel();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdLuxLight : pxr.UsdGeomXformable
    {
        public UsdLuxLight() {}
        public UsdLuxLight(pxr.UsdPrim prim) {}
        public UsdLuxLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.GfVec3f ComputeBaseEmission();
        public pxr.UsdAttribute CreateColorAttr();
        public pxr.UsdAttribute CreateColorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorTemperatureAttr();
        public pxr.UsdAttribute CreateColorTemperatureAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorTemperatureAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateDiffuseAttr();
        public pxr.UsdAttribute CreateDiffuseAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDiffuseAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEnableColorTemperatureAttr();
        public pxr.UsdAttribute CreateEnableColorTemperatureAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEnableColorTemperatureAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateExposureAttr();
        public pxr.UsdAttribute CreateExposureAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateExposureAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdRelationship CreateFiltersRel();
        public pxr.UsdAttribute CreateIntensityAttr();
        public pxr.UsdAttribute CreateIntensityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIntensityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateNormalizeAttr();
        public pxr.UsdAttribute CreateNormalizeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateNormalizeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSpecularAttr();
        public pxr.UsdAttribute CreateSpecularAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSpecularAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetColorAttr();
        public pxr.UsdAttribute GetColorTemperatureAttr();
        public pxr.UsdAttribute GetDiffuseAttr();
        public pxr.UsdAttribute GetEnableColorTemperatureAttr();
        public pxr.UsdAttribute GetExposureAttr();
        public pxr.UsdRelationship GetFiltersRel();
        public pxr.UsdAttribute GetIntensityAttr();
        public pxr.UsdCollectionAPI GetLightLinkCollectionAPI();
        public pxr.UsdAttribute GetNormalizeAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdCollectionAPI GetShadowLinkCollectionAPI();
        public pxr.UsdAttribute GetSpecularAttr();
    }

    public class UsdLuxLightFilter : pxr.UsdGeomXformable
    {
        public UsdLuxLightFilter() {}
        public UsdLuxLightFilter(pxr.UsdPrim prim) {}
        public UsdLuxLightFilter(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdLuxLightFilter Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxLightFilter Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdCollectionAPI GetFilterLinkCollectionAPI();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdLuxLightPortal : pxr.UsdGeomXformable
    {
        public UsdLuxLightPortal() {}
        public UsdLuxLightPortal(pxr.UsdPrim prim) {}
        public UsdLuxLightPortal(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdLuxLightPortal Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxLightPortal Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdLuxListAPI : pxr.UsdAPISchemaBase
    {
        public UsdLuxListAPI() {}
        public UsdLuxListAPI(pxr.UsdPrim prim) {}
        public UsdLuxListAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdLuxListAPI Apply(pxr.UsdPrim prim);
        public pxr.SWIGTYPE_p_std__setT_SdfPath_t ComputeLightList(pxr.UsdLuxListAPI.ComputeMode mode);
        public pxr.UsdAttribute CreateLightListCacheBehaviorAttr();
        public pxr.UsdAttribute CreateLightListCacheBehaviorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateLightListCacheBehaviorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdRelationship CreateLightListRel();
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxListAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetLightListCacheBehaviorAttr();
        public pxr.UsdRelationship GetLightListRel();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public void InvalidateLightList();
        public void StoreLightList(pxr.SWIGTYPE_p_std__setT_SdfPath_t arg0);
        public enum ComputeMode
        {
            public const pxr.UsdLuxListAPI.ComputeMode ComputeModeConsultModelHierarchyCache = 0;
            public const pxr.UsdLuxListAPI.ComputeMode ComputeModeIgnoreCache = 1;
            public int value__;
        }
    }

    public class UsdLuxRectLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxRectLight() {}
        public UsdLuxRectLight(pxr.UsdPrim prim) {}
        public UsdLuxRectLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureFileAttr();
        public pxr.UsdAttribute CreateTextureFileAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureFileAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWidthAttr();
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdLuxRectLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxRectLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetHeightAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTextureFileAttr();
        public pxr.UsdAttribute GetWidthAttr();
    }

    public class UsdLuxShadowAPI : pxr.UsdAPISchemaBase
    {
        public UsdLuxShadowAPI() {}
        public UsdLuxShadowAPI(pxr.UsdPrim prim) {}
        public UsdLuxShadowAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdLuxShadowAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateShadowColorAttr();
        public pxr.UsdAttribute CreateShadowColorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShadowColorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShadowDistanceAttr();
        public pxr.UsdAttribute CreateShadowDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShadowDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShadowEnableAttr();
        public pxr.UsdAttribute CreateShadowEnableAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShadowEnableAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShadowFalloffAttr();
        public pxr.UsdAttribute CreateShadowFalloffAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShadowFalloffAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShadowFalloffGammaAttr();
        public pxr.UsdAttribute CreateShadowFalloffGammaAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShadowFalloffGammaAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxShadowAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetShadowColorAttr();
        public pxr.UsdAttribute GetShadowDistanceAttr();
        public pxr.UsdAttribute GetShadowEnableAttr();
        public pxr.UsdAttribute GetShadowFalloffAttr();
        public pxr.UsdAttribute GetShadowFalloffGammaAttr();
    }

    public class UsdLuxShapingAPI : pxr.UsdAPISchemaBase
    {
        public UsdLuxShapingAPI() {}
        public UsdLuxShapingAPI(pxr.UsdPrim prim) {}
        public UsdLuxShapingAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdLuxShapingAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateShapingConeAngleAttr();
        public pxr.UsdAttribute CreateShapingConeAngleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingConeAngleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShapingConeSoftnessAttr();
        public pxr.UsdAttribute CreateShapingConeSoftnessAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingConeSoftnessAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShapingFocusAttr();
        public pxr.UsdAttribute CreateShapingFocusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingFocusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShapingFocusTintAttr();
        public pxr.UsdAttribute CreateShapingFocusTintAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingFocusTintAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShapingIesAngleScaleAttr();
        public pxr.UsdAttribute CreateShapingIesAngleScaleAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingIesAngleScaleAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShapingIesFileAttr();
        public pxr.UsdAttribute CreateShapingIesFileAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingIesFileAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateShapingIesNormalizeAttr();
        public pxr.UsdAttribute CreateShapingIesNormalizeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateShapingIesNormalizeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxShapingAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetShapingConeAngleAttr();
        public pxr.UsdAttribute GetShapingConeSoftnessAttr();
        public pxr.UsdAttribute GetShapingFocusAttr();
        public pxr.UsdAttribute GetShapingFocusTintAttr();
        public pxr.UsdAttribute GetShapingIesAngleScaleAttr();
        public pxr.UsdAttribute GetShapingIesFileAttr();
        public pxr.UsdAttribute GetShapingIesNormalizeAttr();
    }

    public class UsdLuxSphereLight : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdLuxSphereLight() {}
        public UsdLuxSphereLight(pxr.UsdPrim prim) {}
        public UsdLuxSphereLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTreatAsPointAttr();
        public pxr.UsdAttribute CreateTreatAsPointAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTreatAsPointAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdLuxSphereLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdLuxSphereLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetRadiusAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTreatAsPointAttr();
    }

    public class UsdMetadataValueMap : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdMetadataValueMap() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.TfTokenVector GetKeys();
        public pxr.VtValue GetValue(pxr.TfToken key);
        protected void SetValue(pxr.TfToken key, pxr.VtValue value);
    }

    public class UsdModelAPI : pxr.UsdAPISchemaBase
    {
        public UsdModelAPI() {}
        public UsdModelAPI(pxr.UsdPrim prim) {}
        public UsdModelAPI(pxr.UsdSchemaBase schemaObj) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdModelAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public bool GetAssetIdentifier(pxr.SdfAssetPath identifier);
        public bool GetAssetInfo(pxr.VtDictionary info);
        public bool GetAssetName(pxr.SWIGTYPE_p_std__string assetName);
        public bool GetAssetVersion(pxr.SWIGTYPE_p_std__string version);
        public bool GetKind(pxr.TfToken kind);
        public bool GetPayloadAssetDependencies(pxr.SdfAssetPathArray assetDeps);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool IsGroup();
        public bool IsKind(pxr.TfToken baseKind);
        public bool IsKind(pxr.TfToken baseKind, pxr.UsdModelAPI.KindValidation validation);
        public bool IsModel();
        public void SetAssetIdentifier(pxr.SdfAssetPath identifier);
        public void SetAssetInfo(pxr.VtDictionary info);
        public void SetAssetName(string assetName);
        public void SetAssetVersion(string version);
        public bool SetKind(pxr.TfToken kind);
        public void SetPayloadAssetDependencies(pxr.SdfAssetPathArray assetDeps);
        public enum KindValidation
        {
            public const pxr.UsdModelAPI.KindValidation KindValidationModelHierarchy = 1;
            public const pxr.UsdModelAPI.KindValidation KindValidationNone = 0;
            public int value__;
        }
    }

    public class UsdObject : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdObject() {}
        public bool _IsValid();
        public void ClearAssetInfo();
        public void ClearAssetInfoByKey(pxr.TfToken keyPath);
        public void ClearCustomData();
        public void ClearCustomDataByKey(pxr.TfToken keyPath);
        public bool ClearDocumentation();
        public bool ClearHidden();
        public bool ClearMetadata(pxr.TfToken key);
        public bool ClearMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.UsdObject lhs, pxr.UsdObject rhs);
        protected virtual void Finalize();
        public pxr.UsdMetadataValueMap GetAllAuthoredMetadata();
        public pxr.UsdMetadataValueMap GetAllMetadata();
        public pxr.VtDictionary GetAssetInfo();
        public pxr.VtValue GetAssetInfoByKey(pxr.TfToken keyPath);
        public pxr.VtDictionary GetCustomData();
        public pxr.VtValue GetCustomDataByKey(pxr.TfToken keyPath);
        public string GetDescription();
        public string GetDocumentation();
        public virtual int GetHashCode();
        public pxr.VtValue GetMetadata(pxr.TfToken key);
        public pxr.VtValue GetMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public pxr.TfToken GetName();
        public static char GetNamespaceDelimiter();
        public pxr.SdfPath GetPath();
        public pxr.UsdPrim GetPrim();
        public pxr.SdfPath GetPrimPath();
        public pxr.UsdStageWeakPtr GetStage();
        public bool HasAssetInfo();
        public bool HasAssetInfoKey(pxr.TfToken keyPath);
        public bool HasAuthoredAssetInfo();
        public bool HasAuthoredAssetInfoKey(pxr.TfToken keyPath);
        public bool HasAuthoredCustomData();
        public bool HasAuthoredCustomDataKey(pxr.TfToken keyPath);
        public bool HasAuthoredDocumentation();
        public bool HasAuthoredHidden();
        public bool HasAuthoredMetadata(pxr.TfToken key);
        public bool HasAuthoredMetadataDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public bool HasCustomData();
        public bool HasCustomDataKey(pxr.TfToken keyPath);
        public bool HasMetadata(pxr.TfToken key);
        public bool HasMetadataDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public bool IsHidden();
        public bool IsValid();
        public static bool operator ==(pxr.UsdObject lhs, pxr.UsdObject rhs);
        public static bool op_Implicit(pxr.UsdObject obj);
        public static bool operator !=(pxr.UsdObject lhs, pxr.UsdObject rhs);
        public void SetAssetInfo(pxr.VtDictionary customData);
        public void SetAssetInfoByKey(pxr.TfToken keyPath, pxr.VtValue value);
        public void SetCustomData(pxr.VtDictionary customData);
        public void SetCustomDataByKey(pxr.TfToken keyPath, pxr.VtValue value);
        public bool SetDocumentation(string doc);
        public bool SetHidden(bool hidden);
        public bool SetMetadata(pxr.TfToken key, pxr.VtValue value);
        public bool SetMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath, pxr.VtValue value);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdObjectVector : System.Collections.Generic.IEnumerable<pxr.UsdObject>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdObject this[int index] { get; set; }
        public UsdObjectVector() {}
        public UsdObjectVector(pxr.UsdObjectVector other) {}
        public UsdObjectVector(System.Collections.ICollection c) {}
        public UsdObjectVector(int capacity) {}
        public void Add(pxr.UsdObject x);
        public void AddRange(pxr.UsdObjectVector values);
        public void Clear();
        public void CopyTo(pxr.UsdObject[] array);
        public void CopyTo(pxr.UsdObject[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdObject[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdObjectVector.UsdObjectVectorEnumerator GetEnumerator();
        public pxr.UsdObjectVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdObject x);
        public void InsertRange(int index, pxr.UsdObjectVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdObjectVector Repeat(pxr.UsdObject value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdObjectVector values);
        public sealed class UsdObjectVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdObject>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdObject Current { get; }
            public UsdObjectVectorEnumerator(pxr.UsdObjectVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public enum UsdObjType
    {
        public const pxr.UsdObjType Usd_NumObjTypes = 5;
        public const pxr.UsdObjType UsdTypeAttribute = 3;
        public const pxr.UsdObjType UsdTypeObject = 0;
        public const pxr.UsdObjType UsdTypePrim = 1;
        public const pxr.UsdObjType UsdTypeProperty = 2;
        public const pxr.UsdObjType UsdTypeRelationship = 4;
        public int value__;
    }

    public class UsdPayloads : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool AddInternalPayload(pxr.SdfPath primPath);
        public bool AddInternalPayload(pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset);
        public bool AddInternalPayload(pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset, pxr.UsdListPosition position);
        public bool AddPayload(pxr.SdfPayload payload);
        public bool AddPayload(string identifier);
        public bool AddPayload(pxr.SdfPayload payload, pxr.UsdListPosition position);
        public bool AddPayload(string identifier, pxr.SdfLayerOffset layerOffset);
        public bool AddPayload(string identifier, pxr.SdfPath primPath);
        public bool AddPayload(string identifier, pxr.SdfLayerOffset layerOffset, pxr.UsdListPosition position);
        public bool AddPayload(string identifier, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset);
        public bool AddPayload(string identifier, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset, pxr.UsdListPosition position);
        public bool ClearPayloads();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdPrim GetPrim();
        public bool RemovePayload(pxr.SdfPayload arg0);
        public bool SetPayloads(pxr.SdfPayloadVector items);
    }

    public class UsdPrim : pxr.UsdObject
    {
        public UsdPrim() {}
        public bool AddAppliedSchema(pxr.TfToken appliedSchemaName);
        public bool ApplyAPI(pxr.TfType schemaType);
        public bool ApplyAPI(pxr.TfType schemaType, pxr.TfToken instanceName);
        public bool ClearActive();
        public bool ClearInstanceable();
        public bool ClearPayload();
        public bool ClearTypeName();
        public pxr.PcpPrimIndex ComputeExpandedPrimIndex();
        public pxr.UsdAttribute CreateAttribute(pxr.StdStringVector nameElts, pxr.SdfValueTypeName typeName);
        public pxr.UsdAttribute CreateAttribute(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public pxr.UsdAttribute CreateAttribute(pxr.StdStringVector nameElts, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability);
        public pxr.UsdAttribute CreateAttribute(pxr.StdStringVector nameElts, pxr.SdfValueTypeName typeName, bool custom);
        public pxr.UsdAttribute CreateAttribute(pxr.TfToken name, pxr.SdfValueTypeName typeName, pxr.SdfVariability variability);
        public pxr.UsdAttribute CreateAttribute(pxr.TfToken name, pxr.SdfValueTypeName typeName, bool custom);
        public pxr.UsdAttribute CreateAttribute(pxr.StdStringVector nameElts, pxr.SdfValueTypeName typeName, bool custom, pxr.SdfVariability variability);
        public pxr.UsdAttribute CreateAttribute(pxr.TfToken name, pxr.SdfValueTypeName typeName, bool custom, pxr.SdfVariability variability);
        public pxr.UsdRelationship CreateRelationship(pxr.StdStringVector nameElts);
        public pxr.UsdRelationship CreateRelationship(pxr.TfToken relName);
        public pxr.UsdRelationship CreateRelationship(pxr.StdStringVector nameElts, bool custom);
        public pxr.UsdRelationship CreateRelationship(pxr.TfToken relName, bool custom);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdPrimSiblingRange GetAllChildren();
        public pxr.UsdPrimSubtreeRange GetAllDescendants();
        public pxr.TfTokenVector GetAppliedSchemas();
        public pxr.UsdAttribute GetAttribute(pxr.TfToken attrName);
        public pxr.UsdAttribute GetAttributeAtPath(pxr.SdfPath path);
        public pxr.UsdAttributeVector GetAttributes();
        public bool GetAttributeValue(pxr.TfToken attrName, pxr.VtValue valueOut, pxr.UsdTimeCode time);
        public pxr.UsdAttributeVector GetAuthoredAttributes();
        public pxr.UsdPropertyVector GetAuthoredProperties();
        public pxr.UsdPropertyVector GetAuthoredProperties(pxr.SWIGTYPE_p_std__functionT_bool_fTfToken_const_RF_t predicate);
        public pxr.UsdPropertyVector GetAuthoredPropertiesInNamespace(pxr.StdStringVector namespaces);
        public pxr.UsdPropertyVector GetAuthoredPropertiesInNamespace(string namespaces);
        public pxr.TfTokenVector GetAuthoredPropertyNames();
        public pxr.TfTokenVector GetAuthoredPropertyNames(pxr.SWIGTYPE_p_std__functionT_bool_fTfToken_const_RF_t predicate);
        public pxr.UsdRelationshipVector GetAuthoredRelationships();
        public pxr.UsdPrim GetChild(pxr.TfToken name);
        public pxr.UsdPrimSiblingRange GetChildren();
        public pxr.UsdPrimSubtreeRange GetDescendants();
        public pxr.UsdPrimSiblingRange GetFilteredChildren(pxr.Usd_PrimFlagsPredicate predicate);
        public pxr.UsdPrimSubtreeRange GetFilteredDescendants(pxr.Usd_PrimFlagsPredicate predicate);
        public pxr.UsdPrim GetFilteredNextSibling(pxr.Usd_PrimFlagsPredicate predicate);
        public pxr.UsdInherits GetInherits();
        public pxr.UsdPrimVector GetInstances();
        public pxr.UsdPrim GetMaster();
        public pxr.UsdPrim GetNextSibling();
        public pxr.UsdObject GetObjectAtPath(pxr.SdfPath path);
        public pxr.UsdPrim GetParent();
        public pxr.UsdPayloads GetPayloads();
        public pxr.UsdPrim GetPrimAtPath(pxr.SdfPath path);
        public pxr.SWIGTYPE_p_UsdPrimDefinition GetPrimDefinition();
        public pxr.PcpPrimIndex GetPrimIndex();
        public pxr.UsdPrim GetPrimInMaster();
        public pxr.SdfPrimSpecHandleVector GetPrimStack();
        public pxr.SWIGTYPE_p_UsdPrimTypeInfo GetPrimTypeInfo();
        public pxr.UsdPropertyVector GetProperties();
        public pxr.UsdPropertyVector GetProperties(pxr.SWIGTYPE_p_std__functionT_bool_fTfToken_const_RF_t predicate);
        public pxr.UsdPropertyVector GetPropertiesInNamespace(pxr.StdStringVector namespaces);
        public pxr.UsdPropertyVector GetPropertiesInNamespace(string namespaces);
        public pxr.UsdProperty GetProperty(pxr.TfToken propName);
        public pxr.UsdProperty GetPropertyAtPath(pxr.SdfPath path);
        public pxr.TfTokenVector GetPropertyNames();
        public pxr.TfTokenVector GetPropertyNames(pxr.SWIGTYPE_p_std__functionT_bool_fTfToken_const_RF_t predicate);
        public pxr.TfTokenVector GetPropertyOrder();
        public pxr.UsdReferences GetReferences();
        public pxr.UsdRelationship GetRelationship(pxr.TfToken relName);
        public pxr.UsdRelationship GetRelationshipAtPath(pxr.SdfPath path);
        public pxr.UsdRelationshipVector GetRelationships();
        public pxr.UsdSpecializes GetSpecializes();
        public pxr.SdfSpecifier GetSpecifier();
        public pxr.TfToken GetTypeName();
        public pxr.UsdVariantSet GetVariantSet(string variantSetName);
        public pxr.UsdVariantSets GetVariantSets();
        public bool HasAPI(pxr.TfType schemaType);
        public bool HasAPI(pxr.TfType schemaType, pxr.TfToken instanceName);
        public bool HasAttribute(pxr.TfToken attrName);
        public bool HasAuthoredActive();
        public bool HasAuthoredInherits();
        public bool HasAuthoredInstanceable();
        public bool HasAuthoredPayloads();
        public bool HasAuthoredReferences();
        public bool HasAuthoredSpecializes();
        public bool HasAuthoredTypeName();
        public bool HasDefiningSpecifier();
        public bool HasPayload();
        public bool HasProperty(pxr.TfToken propName);
        public bool HasRelationship(pxr.TfToken relName);
        public bool HasVariantSets();
        public bool IsA(pxr.TfType schemaType);
        public bool IsAbstract();
        public bool IsActive();
        public bool IsDefined();
        public bool IsGroup();
        public bool IsInMaster();
        public bool IsInstance();
        public bool IsInstanceable();
        public bool IsInstanceProxy();
        public bool IsLoaded();
        public bool IsMaster();
        public bool IsModel();
        public bool IsPseudoRoot();
        public void Load();
        public void Load(pxr.UsdLoadPolicy policy);
        public bool RemoveAPI(pxr.TfType schemaType);
        public bool RemoveAPI(pxr.TfType schemaType, pxr.TfToken instanceName);
        public bool RemoveAppliedSchema(pxr.TfToken appliedSchemaName);
        public bool RemoveProperty(pxr.TfToken propName);
        public bool SetActive(bool active);
        public bool SetInstanceable(bool instanceable);
        public bool SetPayload(pxr.SdfPayload payload);
        public bool SetPayload(pxr.SdfLayerHandle layer, pxr.SdfPath primPath);
        public bool SetPayload(string assetPath, pxr.SdfPath primPath);
        public void SetPropertyOrder(pxr.TfTokenVector order);
        public bool SetSpecifier(pxr.SdfSpecifier specifier);
        public bool SetTypeName(pxr.TfToken typeName);
        public void Unload();
    }

    public class UsdPrimRange : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.IEnumerable
    {
        protected bool swigCMemOwn;
        public UsdPrimRange() {}
        public UsdPrimRange(pxr.UsdPrim start) {}
        public UsdPrimRange(pxr.UsdPrim start, pxr.Usd_PrimFlagsPredicate predicate) {}
        public static pxr.UsdPrimRange AllPrims(pxr.UsdPrim start);
        public static pxr.UsdPrimRange AllPrimsPreAndPostVisit(pxr.UsdPrim start);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.UsdPrimRange lhs, pxr.UsdPrimRange rhs);
        protected virtual void Finalize();
        public pxr.UsdPrim GetCurrent();
        public pxr.UsdPrimRange.iterator GetEnd();
        public virtual System.Collections.Generic.IEnumerator<pxr.UsdPrim> GetEnumerator();
        public virtual int GetHashCode();
        public pxr.UsdPrimRange.iterator GetStart();
        public void IncrementBegin();
        public bool IsEmpty();
        public static bool operator ==(pxr.UsdPrimRange lhs, pxr.UsdPrimRange rhs);
        public static bool operator !=(pxr.UsdPrimRange lhs, pxr.UsdPrimRange rhs);
        public static pxr.UsdPrimRange PreAndPostVisit(pxr.UsdPrim start);
        public static pxr.UsdPrimRange PreAndPostVisit(pxr.UsdPrim start, pxr.Usd_PrimFlagsPredicate predicate);
        public void SetBegin(pxr.UsdPrimRange.iterator newBegin);
        public static pxr.UsdPrimRange Stage(pxr.UsdStageWeakPtr stage);
        public static pxr.UsdPrimRange Stage(pxr.UsdStageWeakPtr stage, pxr.Usd_PrimFlagsPredicate predicate);
        public class EndSentinel : System.IDisposable
        {
            protected bool swigCMemOwn;
            public virtual void Dispose();
            protected virtual void Finalize();
        }
        public class iterator : System.IDisposable
        {
            protected bool swigCMemOwn;
            public iterator() {}
            public iterator(pxr.UsdPrimRange.EndSentinel e) {}
            public virtual void Dispose();
            public virtual bool Equals(object rhs);
            public static bool Equals(pxr.UsdPrimRange.iterator lhs, pxr.UsdPrimRange.iterator rhs);
            protected virtual void Finalize();
            public pxr.UsdPrim GetCurrent();
            public virtual int GetHashCode();
            public bool IsPostVisit();
            public void MoveNext();
            public static bool operator ==(pxr.UsdPrimRange.iterator lhs, pxr.UsdPrimRange.iterator rhs);
            public static bool operator !=(pxr.UsdPrimRange.iterator lhs, pxr.UsdPrimRange.iterator rhs);
            public void PruneChildren();
        }
    }

    public class UsdPrimSiblingIterator : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdPrimSiblingIterator() {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.UsdPrimSiblingIterator lhs, pxr.UsdPrimSiblingIterator rhs);
        protected virtual void Finalize();
        public pxr.UsdPrim GetCurrent();
        public virtual int GetHashCode();
        public void MoveNext();
        public static bool operator ==(pxr.UsdPrimSiblingIterator lhs, pxr.UsdPrimSiblingIterator rhs);
        public static bool operator !=(pxr.UsdPrimSiblingIterator lhs, pxr.UsdPrimSiblingIterator rhs);
    }

    public class UsdPrimSiblingRange : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.IEnumerable
    {
        protected bool swigCMemOwn;
        public UsdPrimSiblingRange() {}
        public pxr.UsdPrimSiblingIterator begin();
        public virtual void Dispose();
        public pxr.UsdPrimSiblingIterator end();
        protected virtual void Finalize();
        public pxr.UsdPrimSiblingIterator GetEnd();
        public virtual System.Collections.Generic.IEnumerator<pxr.UsdPrim> GetEnumerator();
        public pxr.UsdPrimSiblingIterator GetStart();
    }

    public class UsdPrimSubtreeIterator : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdPrimSubtreeIterator() {}
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.UsdPrimSubtreeIterator lhs, pxr.UsdPrimSubtreeIterator rhs);
        protected virtual void Finalize();
        public pxr.UsdPrim GetCurrent();
        public virtual int GetHashCode();
        public void MoveNext();
        public static bool operator ==(pxr.UsdPrimSubtreeIterator lhs, pxr.UsdPrimSubtreeIterator rhs);
        public static bool operator !=(pxr.UsdPrimSubtreeIterator lhs, pxr.UsdPrimSubtreeIterator rhs);
    }

    public class UsdPrimSubtreeRange : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.IEnumerable
    {
        protected bool swigCMemOwn;
        public UsdPrimSubtreeRange() {}
        public pxr.UsdPrimSubtreeIterator begin();
        public virtual void Dispose();
        public pxr.UsdPrimSubtreeIterator end();
        protected virtual void Finalize();
        public pxr.UsdPrimSubtreeIterator GetEnd();
        public virtual System.Collections.Generic.IEnumerator<pxr.UsdPrim> GetEnumerator();
        public pxr.UsdPrimSubtreeIterator GetStart();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdPrimVector : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdPrim this[int index] { get; set; }
        public UsdPrimVector() {}
        public UsdPrimVector(pxr.UsdPrimVector other) {}
        public UsdPrimVector(System.Collections.ICollection c) {}
        public UsdPrimVector(int capacity) {}
        public void Add(pxr.UsdPrim x);
        public void AddRange(pxr.UsdPrimVector values);
        public void Clear();
        public void CopyTo(pxr.UsdPrim[] array);
        public void CopyTo(pxr.UsdPrim[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdPrim[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdPrimVector.UsdPrimVectorEnumerator GetEnumerator();
        public pxr.UsdPrimVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdPrim x);
        public void InsertRange(int index, pxr.UsdPrimVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdPrimVector Repeat(pxr.UsdPrim value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdPrimVector values);
        public sealed class UsdPrimVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdPrim>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdPrim Current { get; }
            public UsdPrimVectorEnumerator(pxr.UsdPrimVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdProperty : pxr.UsdObject
    {
        public UsdProperty() {}
        public bool ClearDisplayGroup();
        public bool ClearDisplayName();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdProperty FlattenTo(pxr.UsdPrim parent);
        public pxr.UsdProperty FlattenTo(pxr.UsdProperty property);
        public pxr.UsdProperty FlattenTo(pxr.UsdPrim parent, pxr.TfToken propName);
        public pxr.TfToken GetBaseName();
        public string GetDisplayGroup();
        public string GetDisplayName();
        public pxr.TfToken GetNamespace();
        public pxr.StdStringVector GetNestedDisplayGroups();
        public pxr.SdfPropertySpecHandleVector GetPropertyStack();
        public pxr.SdfPropertySpecHandleVector GetPropertyStack(pxr.UsdTimeCode time);
        public bool HasAuthoredDisplayGroup();
        public bool HasAuthoredDisplayName();
        public bool IsAuthored();
        public bool IsAuthoredAt(pxr.UsdEditTarget editTarget);
        public bool IsCustom();
        public bool IsDefined();
        public bool SetCustom(bool isCustom);
        public bool SetDisplayGroup(string displayGroup);
        public bool SetDisplayName(string name);
        public bool SetNestedDisplayGroups(pxr.StdStringVector nestedGroups);
        public pxr.StdStringVector SplitName();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdPropertyVector : System.Collections.Generic.IEnumerable<pxr.UsdProperty>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdProperty this[int index] { get; set; }
        public UsdPropertyVector() {}
        public UsdPropertyVector(pxr.UsdPropertyVector other) {}
        public UsdPropertyVector(System.Collections.ICollection c) {}
        public UsdPropertyVector(int capacity) {}
        public void Add(pxr.UsdProperty x);
        public void AddRange(pxr.UsdPropertyVector values);
        public void Clear();
        public void CopyTo(pxr.UsdProperty[] array);
        public void CopyTo(pxr.UsdProperty[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdProperty[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdPropertyVector.UsdPropertyVectorEnumerator GetEnumerator();
        public pxr.UsdPropertyVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdProperty x);
        public void InsertRange(int index, pxr.UsdPropertyVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdPropertyVector Repeat(pxr.UsdProperty value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdPropertyVector values);
        public sealed class UsdPropertyVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdProperty>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdProperty Current { get; }
            public UsdPropertyVectorEnumerator(pxr.UsdPropertyVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdReferences : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool AddInternalReference(pxr.SdfPath primPath);
        public bool AddInternalReference(pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset);
        public bool AddInternalReference(pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset, pxr.UsdListPosition position);
        public bool AddReference(pxr.SdfReference arg0);
        public bool AddReference(string identifier);
        public bool AddReference(pxr.SdfReference arg0, pxr.UsdListPosition position);
        public bool AddReference(string identifier, pxr.SdfLayerOffset layerOffset);
        public bool AddReference(string identifier, pxr.SdfPath primPath);
        public bool AddReference(string identifier, pxr.SdfLayerOffset layerOffset, pxr.UsdListPosition position);
        public bool AddReference(string identifier, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset);
        public bool AddReference(string identifier, pxr.SdfPath primPath, pxr.SdfLayerOffset layerOffset, pxr.UsdListPosition position);
        public bool ClearReferences();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdPrim GetPrim();
        public bool RemoveReference(pxr.SdfReference arg0);
        public bool SetReferences(pxr.StdReferenceVector items);
    }

    public class UsdRelationship : pxr.UsdProperty
    {
        public UsdRelationship() {}
        public bool AddTarget(pxr.SdfPath target);
        public bool AddTarget(pxr.SdfPath target, pxr.UsdListPosition position);
        public bool BlockTargets();
        public bool ClearTargets(bool removeSpec);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SdfPathVector GetForwardedTargets();
        public pxr.SdfPathVector GetTargets();
        public bool HasAuthoredTargets();
        public bool RemoveTarget(pxr.SdfPath target);
        public bool SetTargets(pxr.SdfPathVector targets);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdRelationshipVector : System.Collections.Generic.IEnumerable<pxr.UsdRelationship>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdRelationship this[int index] { get; set; }
        public UsdRelationshipVector() {}
        public UsdRelationshipVector(pxr.UsdRelationshipVector other) {}
        public UsdRelationshipVector(System.Collections.ICollection c) {}
        public UsdRelationshipVector(int capacity) {}
        public void Add(pxr.UsdRelationship x);
        public void AddRange(pxr.UsdRelationshipVector values);
        public void Clear();
        public void CopyTo(pxr.UsdRelationship[] array);
        public void CopyTo(pxr.UsdRelationship[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdRelationship[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdRelationshipVector.UsdRelationshipVectorEnumerator GetEnumerator();
        public pxr.UsdRelationshipVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdRelationship x);
        public void InsertRange(int index, pxr.UsdRelationshipVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdRelationshipVector Repeat(pxr.UsdRelationship value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdRelationshipVector values);
        public sealed class UsdRelationshipVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdRelationship>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdRelationship Current { get; }
            public UsdRelationshipVectorEnumerator(pxr.UsdRelationshipVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdResolveInfo : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdResolveInfo() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.PcpNodeRef GetNode();
        public pxr.UsdResolveInfoSource GetSource();
        public bool HasAuthoredValue();
        public bool HasAuthoredValueOpinion();
        public bool ValueIsBlocked();
    }

    public enum UsdResolveInfoSource
    {
        public const pxr.UsdResolveInfoSource UsdResolveInfoSourceDefault = 2;
        public const pxr.UsdResolveInfoSource UsdResolveInfoSourceFallback = 1;
        public const pxr.UsdResolveInfoSource UsdResolveInfoSourceNone = 0;
        public const pxr.UsdResolveInfoSource UsdResolveInfoSourceTimeSamples = 3;
        public const pxr.UsdResolveInfoSource UsdResolveInfoSourceValueClips = 4;
        public int value__;
    }

    public class UsdRiLightAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiLightAPI() {}
        public UsdRiLightAPI(pxr.UsdPrim prim) {}
        public UsdRiLightAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiLightAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateRiIntensityNearDistAttr();
        public pxr.UsdAttribute CreateRiIntensityNearDistAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiIntensityNearDistAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiLightGroupAttr();
        public pxr.UsdAttribute CreateRiLightGroupAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiLightGroupAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiSamplingFixedSampleCountAttr();
        public pxr.UsdAttribute CreateRiSamplingFixedSampleCountAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiSamplingFixedSampleCountAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiSamplingImportanceMultiplierAttr();
        public pxr.UsdAttribute CreateRiSamplingImportanceMultiplierAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiSamplingImportanceMultiplierAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiShadowThinShadowAttr();
        public pxr.UsdAttribute CreateRiShadowThinShadowAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiShadowThinShadowAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiTraceLightPathsAttr();
        public pxr.UsdAttribute CreateRiTraceLightPathsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiTraceLightPathsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiLightAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetRiIntensityNearDistAttr();
        public pxr.UsdAttribute GetRiLightGroupAttr();
        public pxr.UsdAttribute GetRiSamplingFixedSampleCountAttr();
        public pxr.UsdAttribute GetRiSamplingImportanceMultiplierAttr();
        public pxr.UsdAttribute GetRiShadowThinShadowAttr();
        public pxr.UsdAttribute GetRiTraceLightPathsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiLightFilterAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiLightFilterAPI() {}
        public UsdRiLightFilterAPI(pxr.UsdPrim prim) {}
        public UsdRiLightFilterAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiLightFilterAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateRiCombineModeAttr();
        public pxr.UsdAttribute CreateRiCombineModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiCombineModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiDensityAttr();
        public pxr.UsdAttribute CreateRiDensityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiDensityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiDiffuseAttr();
        public pxr.UsdAttribute CreateRiDiffuseAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiDiffuseAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiExposureAttr();
        public pxr.UsdAttribute CreateRiExposureAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiExposureAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiIntensityAttr();
        public pxr.UsdAttribute CreateRiIntensityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiIntensityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiInvertAttr();
        public pxr.UsdAttribute CreateRiInvertAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiInvertAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiSpecularAttr();
        public pxr.UsdAttribute CreateRiSpecularAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiSpecularAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiLightFilterAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetRiCombineModeAttr();
        public pxr.UsdAttribute GetRiDensityAttr();
        public pxr.UsdAttribute GetRiDiffuseAttr();
        public pxr.UsdAttribute GetRiExposureAttr();
        public pxr.UsdAttribute GetRiIntensityAttr();
        public pxr.UsdAttribute GetRiInvertAttr();
        public pxr.UsdAttribute GetRiSpecularAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiLightPortalAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiLightPortalAPI() {}
        public UsdRiLightPortalAPI(pxr.UsdPrim prim) {}
        public UsdRiLightPortalAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiLightPortalAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateRiPortalIntensityAttr();
        public pxr.UsdAttribute CreateRiPortalIntensityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiPortalIntensityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiPortalTintAttr();
        public pxr.UsdAttribute CreateRiPortalTintAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiPortalTintAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiLightPortalAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetRiPortalIntensityAttr();
        public pxr.UsdAttribute GetRiPortalTintAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiMaterialAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiMaterialAPI() {}
        public UsdRiMaterialAPI(pxr.UsdPrim prim) {}
        public UsdRiMaterialAPI(pxr.UsdSchemaBase schemaObj) {}
        public UsdRiMaterialAPI(pxr.UsdShadeMaterial material) {}
        public static pxr.UsdRiMaterialAPI Apply(pxr.UsdPrim prim);
        public pxr.SWIGTYPE_p_std__unordered_mapT_UsdShadeInput_std__vectorT_UsdShadeInput_t_UsdShadeInput__Hash_t ComputeInterfaceInputConsumersMap();
        public pxr.SWIGTYPE_p_std__unordered_mapT_UsdShadeInput_std__vectorT_UsdShadeInput_t_UsdShadeInput__Hash_t ComputeInterfaceInputConsumersMap(bool computeTransitiveConsumers);
        public pxr.UsdAttribute CreateDisplacementAttr();
        public pxr.UsdAttribute CreateDisplacementAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDisplacementAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSurfaceAttr();
        public pxr.UsdAttribute CreateSurfaceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSurfaceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateVolumeAttr();
        public pxr.UsdAttribute CreateVolumeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVolumeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiMaterialAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdShadeShader GetDisplacement();
        public pxr.UsdShadeShader GetDisplacement(bool ignoreBaseMaterial);
        public pxr.UsdAttribute GetDisplacementAttr();
        public pxr.UsdShadeOutput GetDisplacementOutput();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdShadeShader GetSurface();
        public pxr.UsdShadeShader GetSurface(bool ignoreBaseMaterial);
        public pxr.UsdAttribute GetSurfaceAttr();
        public pxr.UsdShadeOutput GetSurfaceOutput();
        public pxr.UsdShadeShader GetVolume();
        public pxr.UsdShadeShader GetVolume(bool ignoreBaseMaterial);
        public pxr.UsdAttribute GetVolumeAttr();
        public pxr.UsdShadeOutput GetVolumeOutput();
        public bool SetDisplacementSource(pxr.SdfPath displacementPath);
        public bool SetSurfaceSource(pxr.SdfPath surfacePath);
        public bool SetVolumeSource(pxr.SdfPath volumePath);
    }

    public class UsdRiPxrAovLight : pxr.UsdLuxLight
    {
        public UsdRiPxrAovLight() {}
        public UsdRiPxrAovLight(pxr.UsdPrim prim) {}
        public UsdRiPxrAovLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateAovNameAttr();
        public pxr.UsdAttribute CreateAovNameAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAovNameAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateInPrimaryHitAttr();
        public pxr.UsdAttribute CreateInPrimaryHitAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInPrimaryHitAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateInReflectionAttr();
        public pxr.UsdAttribute CreateInReflectionAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInReflectionAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateInRefractionAttr();
        public pxr.UsdAttribute CreateInRefractionAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInRefractionAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateInvertAttr();
        public pxr.UsdAttribute CreateInvertAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInvertAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateOnVolumeBoundariesAttr();
        public pxr.UsdAttribute CreateOnVolumeBoundariesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateOnVolumeBoundariesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateUseColorAttr();
        public pxr.UsdAttribute CreateUseColorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateUseColorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateUseThroughputAttr();
        public pxr.UsdAttribute CreateUseThroughputAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateUseThroughputAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrAovLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrAovLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAovNameAttr();
        public pxr.UsdAttribute GetInPrimaryHitAttr();
        public pxr.UsdAttribute GetInReflectionAttr();
        public pxr.UsdAttribute GetInRefractionAttr();
        public pxr.UsdAttribute GetInvertAttr();
        public pxr.UsdAttribute GetOnVolumeBoundariesAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetUseColorAttr();
        public pxr.UsdAttribute GetUseThroughputAttr();
    }

    public class UsdRiPxrBarnLightFilter : pxr.UsdLuxLightFilter
    {
        public UsdRiPxrBarnLightFilter() {}
        public UsdRiPxrBarnLightFilter(pxr.UsdPrim prim) {}
        public UsdRiPxrBarnLightFilter(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateAnalyticApexAttr();
        public pxr.UsdAttribute CreateAnalyticApexAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticApexAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityExponentAttr();
        public pxr.UsdAttribute CreateAnalyticDensityExponentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityExponentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityFarDistanceAttr();
        public pxr.UsdAttribute CreateAnalyticDensityFarDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityFarDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityFarValueAttr();
        public pxr.UsdAttribute CreateAnalyticDensityFarValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityFarValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityNearDistanceAttr();
        public pxr.UsdAttribute CreateAnalyticDensityNearDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityNearDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityNearValueAttr();
        public pxr.UsdAttribute CreateAnalyticDensityNearValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityNearValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDirectionalAttr();
        public pxr.UsdAttribute CreateAnalyticDirectionalAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDirectionalAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticShearXAttr();
        public pxr.UsdAttribute CreateAnalyticShearXAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticShearXAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticShearYAttr();
        public pxr.UsdAttribute CreateAnalyticShearYAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticShearYAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticUseLightDirectionAttr();
        public pxr.UsdAttribute CreateAnalyticUseLightDirectionAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticUseLightDirectionAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateBarnModeAttr();
        public pxr.UsdAttribute CreateBarnModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBarnModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleBottomAttr();
        public pxr.UsdAttribute CreateEdgeScaleBottomAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleBottomAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleLeftAttr();
        public pxr.UsdAttribute CreateEdgeScaleLeftAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleLeftAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleRightAttr();
        public pxr.UsdAttribute CreateEdgeScaleRightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleRightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleTopAttr();
        public pxr.UsdAttribute CreateEdgeScaleTopAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleTopAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeThicknessAttr();
        public pxr.UsdAttribute CreateEdgeThicknessAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeThicknessAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreatePreBarnEffectAttr();
        public pxr.UsdAttribute CreatePreBarnEffectAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePreBarnEffectAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineBottomAttr();
        public pxr.UsdAttribute CreateRefineBottomAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineBottomAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineLeftAttr();
        public pxr.UsdAttribute CreateRefineLeftAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineLeftAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineRightAttr();
        public pxr.UsdAttribute CreateRefineRightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineRightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineTopAttr();
        public pxr.UsdAttribute CreateRefineTopAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineTopAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateScaleHeightAttr();
        public pxr.UsdAttribute CreateScaleHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScaleHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateScaleWidthAttr();
        public pxr.UsdAttribute CreateScaleWidthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScaleWidthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWidthAttr();
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrBarnLightFilter Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrBarnLightFilter Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAnalyticApexAttr();
        public pxr.UsdAttribute GetAnalyticDensityExponentAttr();
        public pxr.UsdAttribute GetAnalyticDensityFarDistanceAttr();
        public pxr.UsdAttribute GetAnalyticDensityFarValueAttr();
        public pxr.UsdAttribute GetAnalyticDensityNearDistanceAttr();
        public pxr.UsdAttribute GetAnalyticDensityNearValueAttr();
        public pxr.UsdAttribute GetAnalyticDirectionalAttr();
        public pxr.UsdAttribute GetAnalyticShearXAttr();
        public pxr.UsdAttribute GetAnalyticShearYAttr();
        public pxr.UsdAttribute GetAnalyticUseLightDirectionAttr();
        public pxr.UsdAttribute GetBarnModeAttr();
        public pxr.UsdAttribute GetEdgeScaleBottomAttr();
        public pxr.UsdAttribute GetEdgeScaleLeftAttr();
        public pxr.UsdAttribute GetEdgeScaleRightAttr();
        public pxr.UsdAttribute GetEdgeScaleTopAttr();
        public pxr.UsdAttribute GetEdgeThicknessAttr();
        public pxr.UsdAttribute GetHeightAttr();
        public pxr.UsdAttribute GetPreBarnEffectAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public pxr.UsdAttribute GetRefineBottomAttr();
        public pxr.UsdAttribute GetRefineLeftAttr();
        public pxr.UsdAttribute GetRefineRightAttr();
        public pxr.UsdAttribute GetRefineTopAttr();
        public pxr.UsdAttribute GetScaleHeightAttr();
        public pxr.UsdAttribute GetScaleWidthAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetWidthAttr();
    }

    public class UsdRiPxrCookieLightFilter : pxr.UsdLuxLightFilter
    {
        public UsdRiPxrCookieLightFilter() {}
        public UsdRiPxrCookieLightFilter(pxr.UsdPrim prim) {}
        public UsdRiPxrCookieLightFilter(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateAnalyticApexAttr();
        public pxr.UsdAttribute CreateAnalyticApexAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticApexAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurAmountAttr();
        public pxr.UsdAttribute CreateAnalyticBlurAmountAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurAmountAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurExponentAttr();
        public pxr.UsdAttribute CreateAnalyticBlurExponentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurExponentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurFarDistanceAttr();
        public pxr.UsdAttribute CreateAnalyticBlurFarDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurFarDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurFarValueAttr();
        public pxr.UsdAttribute CreateAnalyticBlurFarValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurFarValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurMidpointAttr();
        public pxr.UsdAttribute CreateAnalyticBlurMidpointAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurMidpointAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurMidValueAttr();
        public pxr.UsdAttribute CreateAnalyticBlurMidValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurMidValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurNearDistanceAttr();
        public pxr.UsdAttribute CreateAnalyticBlurNearDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurNearDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurNearValueAttr();
        public pxr.UsdAttribute CreateAnalyticBlurNearValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurNearValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurSMultAttr();
        public pxr.UsdAttribute CreateAnalyticBlurSMultAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurSMultAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticBlurTMultAttr();
        public pxr.UsdAttribute CreateAnalyticBlurTMultAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticBlurTMultAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityExponentAttr();
        public pxr.UsdAttribute CreateAnalyticDensityExponentAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityExponentAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityFarDistanceAttr();
        public pxr.UsdAttribute CreateAnalyticDensityFarDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityFarDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityFarValueAttr();
        public pxr.UsdAttribute CreateAnalyticDensityFarValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityFarValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityMidpointAttr();
        public pxr.UsdAttribute CreateAnalyticDensityMidpointAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityMidpointAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityMidValueAttr();
        public pxr.UsdAttribute CreateAnalyticDensityMidValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityMidValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityNearDistanceAttr();
        public pxr.UsdAttribute CreateAnalyticDensityNearDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityNearDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDensityNearValueAttr();
        public pxr.UsdAttribute CreateAnalyticDensityNearValueAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDensityNearValueAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticDirectionalAttr();
        public pxr.UsdAttribute CreateAnalyticDirectionalAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticDirectionalAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticShearXAttr();
        public pxr.UsdAttribute CreateAnalyticShearXAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticShearXAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticShearYAttr();
        public pxr.UsdAttribute CreateAnalyticShearYAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticShearYAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateAnalyticUseLightDirectionAttr();
        public pxr.UsdAttribute CreateAnalyticUseLightDirectionAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateAnalyticUseLightDirectionAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorContrastAttr();
        public pxr.UsdAttribute CreateColorContrastAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorContrastAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorMidpointAttr();
        public pxr.UsdAttribute CreateColorMidpointAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorMidpointAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorSaturationAttr();
        public pxr.UsdAttribute CreateColorSaturationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorSaturationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorTintAttr();
        public pxr.UsdAttribute CreateColorTintAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorTintAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorWhitepointAttr();
        public pxr.UsdAttribute CreateColorWhitepointAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorWhitepointAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateCookieModeAttr();
        public pxr.UsdAttribute CreateCookieModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateCookieModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureFillColorAttr();
        public pxr.UsdAttribute CreateTextureFillColorAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureFillColorAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureInvertUAttr();
        public pxr.UsdAttribute CreateTextureInvertUAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureInvertUAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureInvertVAttr();
        public pxr.UsdAttribute CreateTextureInvertVAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureInvertVAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureMapAttr();
        public pxr.UsdAttribute CreateTextureMapAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureMapAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureOffsetUAttr();
        public pxr.UsdAttribute CreateTextureOffsetUAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureOffsetUAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureOffsetVAttr();
        public pxr.UsdAttribute CreateTextureOffsetVAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureOffsetVAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTexturePremultipliedAlphaAttr();
        public pxr.UsdAttribute CreateTexturePremultipliedAlphaAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTexturePremultipliedAlphaAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureScaleUAttr();
        public pxr.UsdAttribute CreateTextureScaleUAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureScaleUAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureScaleVAttr();
        public pxr.UsdAttribute CreateTextureScaleVAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureScaleVAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTextureWrapModeAttr();
        public pxr.UsdAttribute CreateTextureWrapModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTextureWrapModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWidthAttr();
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrCookieLightFilter Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrCookieLightFilter Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetAnalyticApexAttr();
        public pxr.UsdAttribute GetAnalyticBlurAmountAttr();
        public pxr.UsdAttribute GetAnalyticBlurExponentAttr();
        public pxr.UsdAttribute GetAnalyticBlurFarDistanceAttr();
        public pxr.UsdAttribute GetAnalyticBlurFarValueAttr();
        public pxr.UsdAttribute GetAnalyticBlurMidpointAttr();
        public pxr.UsdAttribute GetAnalyticBlurMidValueAttr();
        public pxr.UsdAttribute GetAnalyticBlurNearDistanceAttr();
        public pxr.UsdAttribute GetAnalyticBlurNearValueAttr();
        public pxr.UsdAttribute GetAnalyticBlurSMultAttr();
        public pxr.UsdAttribute GetAnalyticBlurTMultAttr();
        public pxr.UsdAttribute GetAnalyticDensityExponentAttr();
        public pxr.UsdAttribute GetAnalyticDensityFarDistanceAttr();
        public pxr.UsdAttribute GetAnalyticDensityFarValueAttr();
        public pxr.UsdAttribute GetAnalyticDensityMidpointAttr();
        public pxr.UsdAttribute GetAnalyticDensityMidValueAttr();
        public pxr.UsdAttribute GetAnalyticDensityNearDistanceAttr();
        public pxr.UsdAttribute GetAnalyticDensityNearValueAttr();
        public pxr.UsdAttribute GetAnalyticDirectionalAttr();
        public pxr.UsdAttribute GetAnalyticShearXAttr();
        public pxr.UsdAttribute GetAnalyticShearYAttr();
        public pxr.UsdAttribute GetAnalyticUseLightDirectionAttr();
        public pxr.UsdAttribute GetColorContrastAttr();
        public pxr.UsdAttribute GetColorMidpointAttr();
        public pxr.UsdAttribute GetColorSaturationAttr();
        public pxr.UsdAttribute GetColorTintAttr();
        public pxr.UsdAttribute GetColorWhitepointAttr();
        public pxr.UsdAttribute GetCookieModeAttr();
        public pxr.UsdAttribute GetHeightAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetTextureFillColorAttr();
        public pxr.UsdAttribute GetTextureInvertUAttr();
        public pxr.UsdAttribute GetTextureInvertVAttr();
        public pxr.UsdAttribute GetTextureMapAttr();
        public pxr.UsdAttribute GetTextureOffsetUAttr();
        public pxr.UsdAttribute GetTextureOffsetVAttr();
        public pxr.UsdAttribute GetTexturePremultipliedAlphaAttr();
        public pxr.UsdAttribute GetTextureScaleUAttr();
        public pxr.UsdAttribute GetTextureScaleVAttr();
        public pxr.UsdAttribute GetTextureWrapModeAttr();
        public pxr.UsdAttribute GetWidthAttr();
    }

    public class UsdRiPxrEnvDayLight : pxr.UsdLuxLight
    {
        public UsdRiPxrEnvDayLight() {}
        public UsdRiPxrEnvDayLight(pxr.UsdPrim prim) {}
        public UsdRiPxrEnvDayLight(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateDayAttr();
        public pxr.UsdAttribute CreateDayAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDayAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHazinessAttr();
        public pxr.UsdAttribute CreateHazinessAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHazinessAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHourAttr();
        public pxr.UsdAttribute CreateHourAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHourAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateLatitudeAttr();
        public pxr.UsdAttribute CreateLatitudeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateLatitudeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateLongitudeAttr();
        public pxr.UsdAttribute CreateLongitudeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateLongitudeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateMonthAttr();
        public pxr.UsdAttribute CreateMonthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateMonthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSkyTintAttr();
        public pxr.UsdAttribute CreateSkyTintAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSkyTintAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSunDirectionAttr();
        public pxr.UsdAttribute CreateSunDirectionAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSunDirectionAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSunSizeAttr();
        public pxr.UsdAttribute CreateSunSizeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSunSizeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateSunTintAttr();
        public pxr.UsdAttribute CreateSunTintAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSunTintAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateYearAttr();
        public pxr.UsdAttribute CreateYearAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateYearAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateZoneAttr();
        public pxr.UsdAttribute CreateZoneAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateZoneAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrEnvDayLight Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrEnvDayLight Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetDayAttr();
        public pxr.UsdAttribute GetHazinessAttr();
        public pxr.UsdAttribute GetHourAttr();
        public pxr.UsdAttribute GetLatitudeAttr();
        public pxr.UsdAttribute GetLongitudeAttr();
        public pxr.UsdAttribute GetMonthAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetSkyTintAttr();
        public pxr.UsdAttribute GetSunDirectionAttr();
        public pxr.UsdAttribute GetSunSizeAttr();
        public pxr.UsdAttribute GetSunTintAttr();
        public pxr.UsdAttribute GetYearAttr();
        public pxr.UsdAttribute GetZoneAttr();
    }

    public class UsdRiPxrIntMultLightFilter : pxr.UsdLuxLightFilter
    {
        public UsdRiPxrIntMultLightFilter() {}
        public UsdRiPxrIntMultLightFilter(pxr.UsdPrim prim) {}
        public UsdRiPxrIntMultLightFilter(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateColorSaturationAttr();
        public pxr.UsdAttribute CreateColorSaturationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorSaturationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiIntensityAttr();
        public pxr.UsdAttribute CreateRiIntensityAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiIntensityAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrIntMultLightFilter Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrIntMultLightFilter Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetColorSaturationAttr();
        public pxr.UsdAttribute GetRiIntensityAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiPxrRampLightFilter : pxr.UsdLuxLightFilter
    {
        public UsdRiPxrRampLightFilter() {}
        public UsdRiPxrRampLightFilter(pxr.UsdPrim prim) {}
        public UsdRiPxrRampLightFilter(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateBeginDistanceAttr();
        public pxr.UsdAttribute CreateBeginDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBeginDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampAttr();
        public pxr.UsdAttribute CreateColorRampAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampColorsAttr();
        public pxr.UsdAttribute CreateColorRampColorsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampColorsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampInterpolationAttr();
        public pxr.UsdAttribute CreateColorRampInterpolationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampInterpolationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampKnotsAttr();
        public pxr.UsdAttribute CreateColorRampKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEndDistanceAttr();
        public pxr.UsdAttribute CreateEndDistanceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEndDistanceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffAttr();
        public pxr.UsdAttribute CreateFalloffAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffFloatsAttr();
        public pxr.UsdAttribute CreateFalloffFloatsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffFloatsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffInterpolationAttr();
        public pxr.UsdAttribute CreateFalloffInterpolationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffInterpolationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffKnotsAttr();
        public pxr.UsdAttribute CreateFalloffKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRampModeAttr();
        public pxr.UsdAttribute CreateRampModeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRampModeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrRampLightFilter Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrRampLightFilter Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetBeginDistanceAttr();
        public pxr.UsdAttribute GetColorRampAttr();
        public pxr.UsdAttribute GetColorRampColorsAttr();
        public pxr.UsdAttribute GetColorRampInterpolationAttr();
        public pxr.UsdAttribute GetColorRampKnotsAttr();
        public pxr.UsdAttribute GetEndDistanceAttr();
        public pxr.UsdAttribute GetFalloffAttr();
        public pxr.UsdAttribute GetFalloffFloatsAttr();
        public pxr.UsdAttribute GetFalloffInterpolationAttr();
        public pxr.UsdAttribute GetFalloffKnotsAttr();
        public pxr.UsdAttribute GetRampModeAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiPxrRodLightFilter : pxr.UsdLuxLightFilter
    {
        public UsdRiPxrRodLightFilter() {}
        public UsdRiPxrRodLightFilter(pxr.UsdPrim prim) {}
        public UsdRiPxrRodLightFilter(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateColorRampAttr();
        public pxr.UsdAttribute CreateColorRampAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampColorsAttr();
        public pxr.UsdAttribute CreateColorRampColorsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampColorsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampInterpolationAttr();
        public pxr.UsdAttribute CreateColorRampInterpolationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampInterpolationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorRampKnotsAttr();
        public pxr.UsdAttribute CreateColorRampKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorRampKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateColorSaturationAttr();
        public pxr.UsdAttribute CreateColorSaturationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateColorSaturationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateDepthAttr();
        public pxr.UsdAttribute CreateDepthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDepthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleBackAttr();
        public pxr.UsdAttribute CreateEdgeScaleBackAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleBackAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleBottomAttr();
        public pxr.UsdAttribute CreateEdgeScaleBottomAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleBottomAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleFrontAttr();
        public pxr.UsdAttribute CreateEdgeScaleFrontAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleFrontAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleLeftAttr();
        public pxr.UsdAttribute CreateEdgeScaleLeftAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleLeftAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleRightAttr();
        public pxr.UsdAttribute CreateEdgeScaleRightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleRightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeScaleTopAttr();
        public pxr.UsdAttribute CreateEdgeScaleTopAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeScaleTopAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateEdgeThicknessAttr();
        public pxr.UsdAttribute CreateEdgeThicknessAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateEdgeThicknessAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffAttr();
        public pxr.UsdAttribute CreateFalloffAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffFloatsAttr();
        public pxr.UsdAttribute CreateFalloffFloatsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffFloatsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffInterpolationAttr();
        public pxr.UsdAttribute CreateFalloffInterpolationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffInterpolationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFalloffKnotsAttr();
        public pxr.UsdAttribute CreateFalloffKnotsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFalloffKnotsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateHeightAttr();
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRadiusAttr();
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRadiusAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineBackAttr();
        public pxr.UsdAttribute CreateRefineBackAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineBackAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineBottomAttr();
        public pxr.UsdAttribute CreateRefineBottomAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineBottomAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineFrontAttr();
        public pxr.UsdAttribute CreateRefineFrontAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineFrontAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineLeftAttr();
        public pxr.UsdAttribute CreateRefineLeftAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineLeftAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineRightAttr();
        public pxr.UsdAttribute CreateRefineRightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineRightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRefineTopAttr();
        public pxr.UsdAttribute CreateRefineTopAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRefineTopAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateScaleDepthAttr();
        public pxr.UsdAttribute CreateScaleDepthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScaleDepthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateScaleHeightAttr();
        public pxr.UsdAttribute CreateScaleHeightAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScaleHeightAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateScaleWidthAttr();
        public pxr.UsdAttribute CreateScaleWidthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScaleWidthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateWidthAttr();
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateWidthAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiPxrRodLightFilter Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiPxrRodLightFilter Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetColorRampAttr();
        public pxr.UsdAttribute GetColorRampColorsAttr();
        public pxr.UsdAttribute GetColorRampInterpolationAttr();
        public pxr.UsdAttribute GetColorRampKnotsAttr();
        public pxr.UsdAttribute GetColorSaturationAttr();
        public pxr.UsdAttribute GetDepthAttr();
        public pxr.UsdAttribute GetEdgeScaleBackAttr();
        public pxr.UsdAttribute GetEdgeScaleBottomAttr();
        public pxr.UsdAttribute GetEdgeScaleFrontAttr();
        public pxr.UsdAttribute GetEdgeScaleLeftAttr();
        public pxr.UsdAttribute GetEdgeScaleRightAttr();
        public pxr.UsdAttribute GetEdgeScaleTopAttr();
        public pxr.UsdAttribute GetEdgeThicknessAttr();
        public pxr.UsdAttribute GetFalloffAttr();
        public pxr.UsdAttribute GetFalloffFloatsAttr();
        public pxr.UsdAttribute GetFalloffInterpolationAttr();
        public pxr.UsdAttribute GetFalloffKnotsAttr();
        public pxr.UsdAttribute GetHeightAttr();
        public pxr.UsdAttribute GetRadiusAttr();
        public pxr.UsdAttribute GetRefineBackAttr();
        public pxr.UsdAttribute GetRefineBottomAttr();
        public pxr.UsdAttribute GetRefineFrontAttr();
        public pxr.UsdAttribute GetRefineLeftAttr();
        public pxr.UsdAttribute GetRefineRightAttr();
        public pxr.UsdAttribute GetRefineTopAttr();
        public pxr.UsdAttribute GetScaleDepthAttr();
        public pxr.UsdAttribute GetScaleHeightAttr();
        public pxr.UsdAttribute GetScaleWidthAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetWidthAttr();
    }

    public class UsdRiRisBxdf : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdRiRisBxdf() {}
        public UsdRiRisBxdf(pxr.UsdPrim prim) {}
        public UsdRiRisBxdf(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiRisBxdf Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiRisBxdf Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiRisIntegrator : pxr.UsdTyped
    {
        public UsdRiRisIntegrator() {}
        public UsdRiRisIntegrator(pxr.UsdPrim prim) {}
        public UsdRiRisIntegrator(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateArgsPathAttr();
        public pxr.UsdAttribute CreateArgsPathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateArgsPathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFilePathAttr();
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiRisIntegrator Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiRisIntegrator Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetArgsPathAttr();
        public pxr.UsdAttribute GetFilePathAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiRisObject : pxr.UsdShadeShader
    {
        public UsdRiRisObject() {}
        public UsdRiRisObject(pxr.UsdPrim prim) {}
        public UsdRiRisObject(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateArgsPathAttr();
        public pxr.UsdAttribute CreateArgsPathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateArgsPathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFilePathAttr();
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiRisObject Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiRisObject Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetArgsPathAttr();
        public pxr.UsdAttribute GetFilePathAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiRisOslPattern : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdRiRisOslPattern() {}
        public UsdRiRisOslPattern(pxr.UsdPrim prim) {}
        public UsdRiRisOslPattern(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateFilePathAttr();
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateOslPathAttr();
        public pxr.UsdAttribute CreateOslPathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateOslPathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiRisOslPattern Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiRisOslPattern Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetFilePathAttr();
        public pxr.UsdAttribute GetOslPathAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiRisPattern : pxr.UsdRiRisObject
    {
        public UsdRiRisPattern() {}
        public UsdRiRisPattern(pxr.UsdPrim prim) {}
        public UsdRiRisPattern(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiRisPattern Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiRisPattern Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdRiRslShader : pxr.UsdShadeShader
    {
        public UsdRiRslShader() {}
        public UsdRiRslShader(pxr.UsdPrim prim) {}
        public UsdRiRslShader(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateSloPathAttr();
        public pxr.UsdAttribute CreateSloPathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSloPathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdRiRslShader Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiRslShader Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetSloPathAttr();
    }

    public class UsdRiSplineAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiSplineAPI() {}
        public UsdRiSplineAPI(pxr.UsdPrim prim) {}
        public UsdRiSplineAPI(pxr.UsdSchemaBase schemaObj) {}
        public UsdRiSplineAPI(pxr.UsdPrim prim, pxr.TfToken splineName, pxr.SdfValueTypeName valuesTypeName, bool doesDuplicateBSplineEndpoints) {}
        public UsdRiSplineAPI(pxr.UsdSchemaBase schemaObj, pxr.TfToken splineName, pxr.SdfValueTypeName valuesTypeName, bool doesDuplicateBSplineEndpoints) {}
        public pxr.UsdAttribute CreateInterpolationAttr();
        public pxr.UsdAttribute CreateInterpolationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateInterpolationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreatePositionsAttr();
        public pxr.UsdAttribute CreatePositionsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePositionsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateValuesAttr();
        public pxr.UsdAttribute CreateValuesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateValuesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        public bool DoesDuplicateBSplineEndpoints();
        protected virtual void Finalize();
        public pxr.UsdAttribute GetInterpolationAttr();
        public pxr.UsdAttribute GetPositionsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetValuesAttr();
        public pxr.SdfValueTypeName GetValuesTypeName();
        public bool Validate(out string reason);
    }

    public class UsdRiStatementsAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiStatementsAPI() {}
        public UsdRiStatementsAPI(pxr.UsdPrim prim) {}
        public UsdRiStatementsAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiStatementsAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateRiAttribute(pxr.TfToken name, pxr.TfType tfType);
        public pxr.UsdAttribute CreateRiAttribute(pxr.TfToken name, string riType);
        public pxr.UsdAttribute CreateRiAttribute(pxr.TfToken name, pxr.TfType tfType, string nameSpace);
        public pxr.UsdAttribute CreateRiAttribute(pxr.TfToken name, string riType, string nameSpace);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiStatementsAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public string GetCoordinateSystem();
        public bool GetModelCoordinateSystems(pxr.SdfPathVector targets);
        public bool GetModelScopedCoordinateSystems(pxr.SdfPathVector targets);
        public pxr.UsdAttribute GetRiAttribute(pxr.TfToken name);
        public pxr.UsdAttribute GetRiAttribute(pxr.TfToken name, string nameSpace);
        public static pxr.TfToken GetRiAttributeName(pxr.UsdProperty prop);
        public static pxr.TfToken GetRiAttributeNameSpace(pxr.UsdProperty prop);
        public pxr.UsdPropertyVector GetRiAttributes();
        public pxr.UsdPropertyVector GetRiAttributes(string nameSpace);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public string GetScopedCoordinateSystem();
        public bool HasCoordinateSystem();
        public bool HasScopedCoordinateSystem();
        public static bool IsRiAttribute(pxr.UsdProperty prop);
        public static string MakeRiAttributePropertyName(string attrName);
        public void SetCoordinateSystem(string coordSysName);
        public void SetScopedCoordinateSystem(string coordSysName);
    }

    public class UsdRiTextureAPI : pxr.UsdAPISchemaBase
    {
        public UsdRiTextureAPI() {}
        public UsdRiTextureAPI(pxr.UsdPrim prim) {}
        public UsdRiTextureAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdRiTextureAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdAttribute CreateRiTextureGammaAttr();
        public pxr.UsdAttribute CreateRiTextureGammaAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiTextureGammaAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRiTextureSaturationAttr();
        public pxr.UsdAttribute CreateRiTextureSaturationAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRiTextureSaturationAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdRiTextureAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetRiTextureGammaAttr();
        public pxr.UsdAttribute GetRiTextureSaturationAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdSchemaBase : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSchemaBase() {}
        public UsdSchemaBase(pxr.UsdPrim prim) {}
        public UsdSchemaBase(pxr.UsdSchemaBase otherSchema) {}
        public bool _IsValid();
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.UsdSchemaBase lhs, pxr.UsdSchemaBase rhs);
        protected virtual void Finalize();
        public virtual int GetHashCode();
        public pxr.SdfPath GetPath();
        public pxr.UsdPrim GetPrim();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.SWIGTYPE_p_UsdPrimDefinition GetSchemaClassPrimDefinition();
        public pxr.UsdSchemaType GetSchemaType();
        public bool IsAPISchema();
        public bool IsAppliedAPISchema();
        public bool IsConcrete();
        public bool IsMultipleApplyAPISchema();
        public bool IsTyped();
        public static bool operator ==(pxr.UsdSchemaBase lhs, pxr.UsdSchemaBase rhs);
        public static bool op_Implicit(pxr.UsdSchemaBase b);
        public static bool operator !=(pxr.UsdSchemaBase lhs, pxr.UsdSchemaBase rhs);
    }

    public enum UsdSchemaType
    {
        public const pxr.UsdSchemaType AbstractBase = 0;
        public const pxr.UsdSchemaType AbstractTyped = 1;
        public const pxr.UsdSchemaType ConcreteTyped = 2;
        public const pxr.UsdSchemaType MultipleApplyAPI = 5;
        public const pxr.UsdSchemaType NonAppliedAPI = 3;
        public const pxr.UsdSchemaType SingleApplyAPI = 4;
        public int value__;
    }

    public enum UsdShadeAttributeType
    {
        public const pxr.UsdShadeAttributeType Input = 1;
        public const pxr.UsdShadeAttributeType Invalid = 0;
        public const pxr.UsdShadeAttributeType Output = 2;
        public int value__;
    }

    public class UsdShadeConnectableAPI : pxr.UsdAPISchemaBase
    {
        public UsdShadeConnectableAPI() {}
        public UsdShadeConnectableAPI(pxr.UsdPrim prim) {}
        public UsdShadeConnectableAPI(pxr.UsdSchemaBase schemaObj) {}
        public UsdShadeConnectableAPI(pxr.UsdShadeNodeGraph nodeGraph) {}
        public UsdShadeConnectableAPI(pxr.UsdShadeShader shader) {}
        public static bool CanConnect(pxr.UsdShadeOutput output);
        public static bool CanConnect(pxr.UsdShadeInput input, pxr.UsdAttribute source);
        public static bool CanConnect(pxr.UsdShadeInput input, pxr.UsdShadeInput sourceInput);
        public static bool CanConnect(pxr.UsdShadeInput input, pxr.UsdShadeOutput sourceOutput);
        public static bool CanConnect(pxr.UsdShadeOutput output, pxr.UsdAttribute source);
        public static bool CanConnect(pxr.UsdShadeOutput output, pxr.UsdShadeInput sourceInput);
        public static bool CanConnect(pxr.UsdShadeOutput output, pxr.UsdShadeOutput sourceOutput);
        public static bool ClearSource(pxr.UsdAttribute shadingAttr);
        public static bool ClearSource(pxr.UsdShadeInput input);
        public static bool ClearSource(pxr.UsdShadeOutput output);
        public static bool ConnectToSource(pxr.UsdAttribute shadingAttr, pxr.SdfPath sourcePath);
        public static bool ConnectToSource(pxr.UsdAttribute shadingAttr, pxr.UsdShadeInput sourceInput);
        public static bool ConnectToSource(pxr.UsdAttribute shadingAttr, pxr.UsdShadeOutput sourceOutput);
        public static bool ConnectToSource(pxr.UsdShadeInput input, pxr.SdfPath sourcePath);
        public static bool ConnectToSource(pxr.UsdShadeInput input, pxr.UsdShadeInput sourceInput);
        public static bool ConnectToSource(pxr.UsdShadeInput input, pxr.UsdShadeOutput sourceOutput);
        public static bool ConnectToSource(pxr.UsdShadeOutput output, pxr.SdfPath sourcePath);
        public static bool ConnectToSource(pxr.UsdShadeOutput output, pxr.UsdShadeInput sourceInput);
        public static bool ConnectToSource(pxr.UsdShadeOutput output, pxr.UsdShadeOutput sourceOutput);
        public static bool ConnectToSource(pxr.UsdAttribute shadingAttr, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName);
        public static bool ConnectToSource(pxr.UsdShadeInput input, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName);
        public static bool ConnectToSource(pxr.UsdShadeOutput output, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName);
        public static bool ConnectToSource(pxr.UsdAttribute shadingAttr, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType);
        public static bool ConnectToSource(pxr.UsdShadeInput input, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType);
        public static bool ConnectToSource(pxr.UsdShadeOutput output, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType);
        public static bool ConnectToSource(pxr.UsdAttribute shadingAttr, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType, pxr.SdfValueTypeName typeName);
        public static bool ConnectToSource(pxr.UsdShadeInput input, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType, pxr.SdfValueTypeName typeName);
        public static bool ConnectToSource(pxr.UsdShadeOutput output, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType, pxr.SdfValueTypeName typeName);
        public pxr.UsdShadeInput CreateInput(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public pxr.UsdShadeOutput CreateOutput(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public static bool DisconnectSource(pxr.UsdAttribute shadingAttr);
        public static bool DisconnectSource(pxr.UsdShadeInput input);
        public static bool DisconnectSource(pxr.UsdShadeOutput output);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdShadeConnectableAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static bool GetConnectedSource(pxr.UsdAttribute shadingAttr, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, out pxr.UsdShadeAttributeType sourceType);
        public static bool GetConnectedSource(pxr.UsdShadeInput input, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, out pxr.UsdShadeAttributeType sourceType);
        public static bool GetConnectedSource(pxr.UsdShadeOutput output, pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, out pxr.UsdShadeAttributeType sourceType);
        public pxr.UsdShadeInput GetInput(pxr.TfToken name);
        public pxr.UsdShadeInputVector GetInputs();
        public pxr.UsdShadeOutput GetOutput(pxr.TfToken name);
        public pxr.UsdShadeOutputVector GetOutputs();
        public static bool GetRawConnectedSourcePaths(pxr.UsdAttribute shadingAttr, pxr.SdfPathVector sourcePaths);
        public static bool GetRawConnectedSourcePaths(pxr.UsdShadeInput input, pxr.SdfPathVector sourcePaths);
        public static bool GetRawConnectedSourcePaths(pxr.UsdShadeOutput output, pxr.SdfPathVector sourcePaths);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public static bool HasConnectedSource(pxr.UsdAttribute shadingAttr);
        public static bool HasConnectedSource(pxr.UsdShadeInput input);
        public static bool HasConnectedSource(pxr.UsdShadeOutput output);
        public bool IsNodeGraph();
        public bool IsShader();
        public static bool IsSourceConnectionFromBaseMaterial(pxr.UsdAttribute shadingAttr);
        public static bool IsSourceConnectionFromBaseMaterial(pxr.UsdShadeInput input);
        public static bool IsSourceConnectionFromBaseMaterial(pxr.UsdShadeOutput output);
    }

    public class UsdShadeInput : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdShadeInput() {}
        public UsdShadeInput(pxr.UsdAttribute attr) {}
        public bool CanConnect(pxr.UsdAttribute source);
        public bool CanConnect(pxr.UsdShadeInput sourceInput);
        public bool CanConnect(pxr.UsdShadeOutput sourceOutput);
        public bool ClearConnectability();
        public void ClearSdrMetadata();
        public void ClearSdrMetadataByKey(pxr.TfToken key);
        public bool ClearSource();
        public bool ConnectToSource(pxr.SdfPath sourcePath);
        public bool ConnectToSource(pxr.UsdShadeInput sourceInput);
        public bool ConnectToSource(pxr.UsdShadeOutput sourceOutput);
        public bool ConnectToSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName);
        public bool ConnectToSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType);
        public bool ConnectToSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType, pxr.SdfValueTypeName typeName);
        public bool DisconnectSource();
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool Get(pxr.VtValue value);
        public bool Get(pxr.VtValue value, pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetAttr();
        public pxr.TfToken GetBaseName();
        public pxr.TfToken GetConnectability();
        public bool GetConnectedSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, out pxr.UsdShadeAttributeType sourceType);
        public string GetDisplayGroup();
        public string GetDocumentation();
        public pxr.TfToken GetFullName();
        public pxr.UsdPrim GetPrim();
        public bool GetRawConnectedSourcePaths(pxr.SdfPathVector sourcePaths);
        public pxr.TfToken GetRenderType();
        public pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t GetSdrMetadata();
        public string GetSdrMetadataByKey(pxr.TfToken key);
        public pxr.SdfValueTypeName GetTypeName();
        public pxr.UsdAttribute GetValueProducingAttribute(pxr.SWIGTYPE_p_UsdShadeAttributeType attrType);
        public bool HasConnectedSource();
        public bool HasRenderType();
        public bool HasSdrMetadata();
        public bool HasSdrMetadataByKey(pxr.TfToken key);
        public bool IsDefined();
        public static bool IsInput(pxr.UsdAttribute attr);
        public static bool IsInterfaceInputName(string name);
        public bool IsSourceConnectionFromBaseMaterial();
        public bool Set(pxr.VtValue value);
        public bool Set(pxr.VtValue value, pxr.UsdTimeCode time);
        public bool SetConnectability(pxr.TfToken connectability);
        public bool SetDisplayGroup(string displayGroup);
        public bool SetDocumentation(string docs);
        public bool SetRenderType(pxr.TfToken renderType);
        public void SetSdrMetadata(pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t sdrMetadata);
        public void SetSdrMetadataByKey(pxr.TfToken key, string value);
        public class Hash : System.IDisposable
        {
            protected bool swigCMemOwn;
            public Hash() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdShadeInputVector : System.Collections.Generic.IEnumerable<pxr.UsdShadeInput>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdShadeInput this[int index] { get; set; }
        public UsdShadeInputVector() {}
        public UsdShadeInputVector(pxr.UsdShadeInputVector other) {}
        public UsdShadeInputVector(System.Collections.ICollection c) {}
        public UsdShadeInputVector(int capacity) {}
        public void Add(pxr.UsdShadeInput x);
        public void AddRange(pxr.UsdShadeInputVector values);
        public void Clear();
        public void CopyTo(pxr.UsdShadeInput[] array);
        public void CopyTo(pxr.UsdShadeInput[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdShadeInput[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdShadeInputVector.UsdShadeInputVectorEnumerator GetEnumerator();
        public pxr.UsdShadeInputVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdShadeInput x);
        public void InsertRange(int index, pxr.UsdShadeInputVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdShadeInputVector Repeat(pxr.UsdShadeInput value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdShadeInputVector values);
        public sealed class UsdShadeInputVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdShadeInput>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdShadeInput Current { get; }
            public UsdShadeInputVectorEnumerator(pxr.UsdShadeInputVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdShadeMaterial : pxr.UsdShadeNodeGraph
    {
        public UsdShadeMaterial() {}
        public UsdShadeMaterial(pxr.UsdPrim prim) {}
        public UsdShadeMaterial(pxr.UsdSchemaBase schemaObj) {}
        public void ClearBaseMaterial();
        public pxr.UsdShadeShader ComputeDisplacementSource();
        public pxr.UsdShadeShader ComputeDisplacementSource(pxr.TfToken renderContext);
        public pxr.UsdShadeShader ComputeDisplacementSource(pxr.TfToken renderContext, pxr.TfToken sourceName);
        public pxr.UsdShadeShader ComputeDisplacementSource(pxr.TfToken renderContext, pxr.TfToken sourceName, pxr.SWIGTYPE_p_UsdShadeAttributeType sourceType);
        public pxr.UsdShadeShader ComputeSurfaceSource();
        public pxr.UsdShadeShader ComputeSurfaceSource(pxr.TfToken renderContext);
        public pxr.UsdShadeShader ComputeSurfaceSource(pxr.TfToken renderContext, pxr.TfToken sourceName);
        public pxr.UsdShadeShader ComputeSurfaceSource(pxr.TfToken renderContext, pxr.TfToken sourceName, pxr.SWIGTYPE_p_UsdShadeAttributeType sourceType);
        public pxr.UsdShadeShader ComputeVolumeSource();
        public pxr.UsdShadeShader ComputeVolumeSource(pxr.TfToken renderContext);
        public pxr.UsdShadeShader ComputeVolumeSource(pxr.TfToken renderContext, pxr.TfToken sourceName);
        public pxr.UsdShadeShader ComputeVolumeSource(pxr.TfToken renderContext, pxr.TfToken sourceName, pxr.SWIGTYPE_p_UsdShadeAttributeType sourceType);
        public pxr.UsdAttribute CreateDisplacementAttr();
        public pxr.UsdAttribute CreateDisplacementAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateDisplacementAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdShadeOutput CreateDisplacementOutput();
        public pxr.UsdShadeOutput CreateDisplacementOutput(pxr.TfToken renderContext);
        public static bool CreateMasterMaterialVariant(pxr.UsdPrim masterPrim, pxr.UsdPrimVector MaterialPrims);
        public static bool CreateMasterMaterialVariant(pxr.UsdPrim masterPrim, pxr.UsdPrimVector MaterialPrims, pxr.TfToken masterVariantSetName);
        public pxr.UsdAttribute CreateSurfaceAttr();
        public pxr.UsdAttribute CreateSurfaceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateSurfaceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdShadeOutput CreateSurfaceOutput();
        public pxr.UsdShadeOutput CreateSurfaceOutput(pxr.TfToken renderContext);
        public pxr.UsdAttribute CreateVolumeAttr();
        public pxr.UsdAttribute CreateVolumeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateVolumeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdShadeOutput CreateVolumeOutput();
        public pxr.UsdShadeOutput CreateVolumeOutput(pxr.TfToken renderContext);
        public static pxr.UsdShadeMaterial Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdShadeMaterial Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdShadeMaterial GetBaseMaterial();
        public pxr.SdfPath GetBaseMaterialPath();
        public pxr.UsdAttribute GetDisplacementAttr();
        public pxr.UsdShadeOutput GetDisplacementOutput();
        public pxr.UsdShadeOutput GetDisplacementOutput(pxr.TfToken renderContext);
        public pxr.SWIGTYPE_p_std__pairT_UsdStageWeakPtr_UsdEditTarget_t GetEditContextForVariant(pxr.TfToken MaterialVariantName);
        public pxr.SWIGTYPE_p_std__pairT_UsdStageWeakPtr_UsdEditTarget_t GetEditContextForVariant(pxr.TfToken MaterialVariantName, pxr.SdfLayerHandle layer);
        public pxr.UsdVariantSet GetMaterialVariant();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.UsdAttribute GetSurfaceAttr();
        public pxr.UsdShadeOutput GetSurfaceOutput();
        public pxr.UsdShadeOutput GetSurfaceOutput(pxr.TfToken renderContext);
        public pxr.UsdAttribute GetVolumeAttr();
        public pxr.UsdShadeOutput GetVolumeOutput();
        public pxr.UsdShadeOutput GetVolumeOutput(pxr.TfToken renderContext);
        public bool HasBaseMaterial();
        public void SetBaseMaterial(pxr.UsdShadeMaterial baseMaterial);
        public void SetBaseMaterialPath(pxr.SdfPath baseMaterialPath);
    }

    public class UsdShadeMaterialBindingAPI : pxr.UsdAPISchemaBase
    {
        public UsdShadeMaterialBindingAPI() {}
        public UsdShadeMaterialBindingAPI(pxr.UsdPrim prim) {}
        public UsdShadeMaterialBindingAPI(pxr.UsdSchemaBase schemaObj) {}
        public bool AddPrimToBindingCollection(pxr.UsdPrim prim, pxr.TfToken bindingName, pxr.TfToken materialPurpose);
        public static pxr.UsdShadeMaterialBindingAPI Apply(pxr.UsdPrim prim);
        public bool Bind(pxr.UsdShadeMaterial material);
        public bool Bind(pxr.UsdCollectionAPI collection, pxr.UsdShadeMaterial material);
        public bool Bind(pxr.UsdShadeMaterial material, pxr.TfToken bindingStrength);
        public bool Bind(pxr.UsdCollectionAPI collection, pxr.UsdShadeMaterial material, pxr.TfToken bindingName);
        public bool Bind(pxr.UsdShadeMaterial material, pxr.TfToken bindingStrength, pxr.TfToken materialPurpose);
        public bool Bind(pxr.UsdCollectionAPI collection, pxr.UsdShadeMaterial material, pxr.TfToken bindingName, pxr.TfToken bindingStrength);
        public bool Bind(pxr.UsdCollectionAPI collection, pxr.UsdShadeMaterial material, pxr.TfToken bindingName, pxr.TfToken bindingStrength, pxr.TfToken materialPurpose);
        public pxr.UsdShadeMaterial ComputeBoundMaterial();
        public pxr.UsdShadeMaterial ComputeBoundMaterial(pxr.TfToken materialPurpose);
        public pxr.UsdShadeMaterial ComputeBoundMaterial(pxr.TfToken materialPurpose, pxr.UsdRelationship bindingRel);
        public static pxr.UsdShadeMaterialVector ComputeBoundMaterials(pxr.UsdPrimVector prims);
        public static pxr.UsdShadeMaterialVector ComputeBoundMaterials(pxr.UsdPrimVector prims, pxr.TfToken materialPurpose);
        public static pxr.UsdShadeMaterialVector ComputeBoundMaterials(pxr.UsdPrimVector prims, pxr.TfToken materialPurpose, pxr.UsdRelationshipVector bindingRels);
        public pxr.UsdGeomSubset CreateMaterialBindSubset(pxr.TfToken subsetName, pxr.VtIntArray indices);
        public pxr.UsdGeomSubset CreateMaterialBindSubset(pxr.TfToken subsetName, pxr.VtIntArray indices, pxr.TfToken elementType);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdShadeMaterialBindingAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdRelationship GetCollectionBindingRel(pxr.TfToken bindingName);
        public pxr.UsdRelationship GetCollectionBindingRel(pxr.TfToken bindingName, pxr.TfToken materialPurpose);
        public pxr.UsdRelationshipVector GetCollectionBindingRels();
        public pxr.UsdRelationshipVector GetCollectionBindingRels(pxr.TfToken materialPurpose);
        public pxr.UsdShadeMaterialBindingAPICollectionBindingVector GetCollectionBindings();
        public pxr.UsdShadeMaterialBindingAPICollectionBindingVector GetCollectionBindings(pxr.TfToken materialPurpose);
        public pxr.UsdShadeMaterialBindingAPI.DirectBinding GetDirectBinding();
        public pxr.UsdShadeMaterialBindingAPI.DirectBinding GetDirectBinding(pxr.TfToken materialPurpose);
        public pxr.UsdRelationship GetDirectBindingRel();
        public pxr.UsdRelationship GetDirectBindingRel(pxr.TfToken materialPurpose);
        public static pxr.TfToken GetMaterialBindingStrength(pxr.UsdRelationship bindingRel);
        public pxr.UsdGeomSubsetVector GetMaterialBindSubsets();
        public pxr.TfToken GetMaterialBindSubsetsFamilyType();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool RemovePrimFromBindingCollection(pxr.UsdPrim prim, pxr.TfToken bindingName, pxr.TfToken materialPurpose);
        public static bool SetMaterialBindingStrength(pxr.UsdRelationship bindingRel, pxr.TfToken bindingStrength);
        public bool SetMaterialBindSubsetsFamilyType(pxr.TfToken familyType);
        public bool UnbindAllBindings();
        public bool UnbindCollectionBinding(pxr.TfToken bindingName);
        public bool UnbindCollectionBinding(pxr.TfToken bindingName, pxr.TfToken materialPurpose);
        public bool UnbindDirectBinding();
        public bool UnbindDirectBinding(pxr.TfToken materialPurpose);
        public class CollectionBinding : System.IDisposable
        {
            protected bool swigCMemOwn;
            public CollectionBinding() {}
            public CollectionBinding(pxr.UsdRelationship collBindingRel) {}
            public virtual void Dispose();
            protected virtual void Finalize();
            public pxr.UsdRelationship GetBindingRel();
            public pxr.UsdCollectionAPI GetCollection();
            public pxr.SdfPath GetCollectionPath();
            public pxr.UsdShadeMaterial GetMaterial();
            public pxr.SdfPath GetMaterialPath();
            public bool IsValid();
        }
        public class DirectBinding : System.IDisposable
        {
            protected bool swigCMemOwn;
            public DirectBinding() {}
            public DirectBinding(pxr.UsdRelationship bindingRel) {}
            public virtual void Dispose();
            protected virtual void Finalize();
            public pxr.UsdRelationship GetBindingRel();
            public pxr.UsdShadeMaterial GetMaterial();
            public pxr.SdfPath GetMaterialPath();
            public pxr.TfToken GetMaterialPurpose();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdShadeMaterialBindingAPICollectionBindingVector : System.Collections.Generic.IEnumerable<pxr.UsdShadeMaterialBindingAPI.CollectionBinding>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdShadeMaterialBindingAPI.CollectionBinding this[int index] { get; set; }
        public UsdShadeMaterialBindingAPICollectionBindingVector() {}
        public UsdShadeMaterialBindingAPICollectionBindingVector(pxr.UsdShadeMaterialBindingAPICollectionBindingVector other) {}
        public UsdShadeMaterialBindingAPICollectionBindingVector(System.Collections.ICollection c) {}
        public UsdShadeMaterialBindingAPICollectionBindingVector(int capacity) {}
        public void Add(pxr.UsdShadeMaterialBindingAPI.CollectionBinding x);
        public void AddRange(pxr.UsdShadeMaterialBindingAPICollectionBindingVector values);
        public void Clear();
        public void CopyTo(pxr.UsdShadeMaterialBindingAPI.CollectionBinding[] array);
        public void CopyTo(pxr.UsdShadeMaterialBindingAPI.CollectionBinding[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdShadeMaterialBindingAPI.CollectionBinding[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdShadeMaterialBindingAPICollectionBindingVector.UsdShadeMaterialBindingAPICollectionBindingVectorEnumerator GetEnumerator();
        public pxr.UsdShadeMaterialBindingAPICollectionBindingVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdShadeMaterialBindingAPI.CollectionBinding x);
        public void InsertRange(int index, pxr.UsdShadeMaterialBindingAPICollectionBindingVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdShadeMaterialBindingAPICollectionBindingVector Repeat(pxr.UsdShadeMaterialBindingAPI.CollectionBinding value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdShadeMaterialBindingAPICollectionBindingVector values);
        public sealed class UsdShadeMaterialBindingAPICollectionBindingVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdShadeMaterialBindingAPI.CollectionBinding>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdShadeMaterialBindingAPI.CollectionBinding Current { get; }
            public UsdShadeMaterialBindingAPICollectionBindingVectorEnumerator(pxr.UsdShadeMaterialBindingAPICollectionBindingVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdShadeMaterialVector : System.Collections.Generic.IEnumerable<pxr.UsdShadeMaterial>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdShadeMaterial this[int index] { get; set; }
        public UsdShadeMaterialVector() {}
        public UsdShadeMaterialVector(pxr.UsdShadeMaterialVector other) {}
        public UsdShadeMaterialVector(System.Collections.ICollection c) {}
        public UsdShadeMaterialVector(int capacity) {}
        public void Add(pxr.UsdShadeMaterial x);
        public void AddRange(pxr.UsdShadeMaterialVector values);
        public void Clear();
        public void CopyTo(pxr.UsdShadeMaterial[] array);
        public void CopyTo(pxr.UsdShadeMaterial[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdShadeMaterial[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdShadeMaterialVector.UsdShadeMaterialVectorEnumerator GetEnumerator();
        public pxr.UsdShadeMaterialVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdShadeMaterial x);
        public void InsertRange(int index, pxr.UsdShadeMaterialVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdShadeMaterialVector Repeat(pxr.UsdShadeMaterial value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdShadeMaterialVector values);
        public sealed class UsdShadeMaterialVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdShadeMaterial>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdShadeMaterial Current { get; }
            public UsdShadeMaterialVectorEnumerator(pxr.UsdShadeMaterialVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdShadeNodeGraph : pxr.UsdTyped
    {
        public UsdShadeNodeGraph() {}
        public UsdShadeNodeGraph(pxr.UsdPrim prim) {}
        public UsdShadeNodeGraph(pxr.UsdSchemaBase schemaObj) {}
        public UsdShadeNodeGraph(pxr.UsdShadeConnectableAPI connectable) {}
        public pxr.SWIGTYPE_p_std__unordered_mapT_UsdShadeInput_std__vectorT_UsdShadeInput_t_UsdShadeInput__Hash_t ComputeInterfaceInputConsumersMap();
        public pxr.SWIGTYPE_p_std__unordered_mapT_UsdShadeInput_std__vectorT_UsdShadeInput_t_UsdShadeInput__Hash_t ComputeInterfaceInputConsumersMap(bool computeTransitiveConsumers);
        public pxr.UsdShadeShader ComputeOutputSource(pxr.TfToken outputName, pxr.TfToken sourceName, pxr.SWIGTYPE_p_UsdShadeAttributeType sourceType);
        public pxr.UsdShadeConnectableAPI ConnectableAPI();
        public pxr.UsdShadeInput CreateInput(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public pxr.UsdShadeOutput CreateOutput(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public static pxr.UsdShadeNodeGraph Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdShadeNodeGraph Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdShadeInput GetInput(pxr.TfToken name);
        public pxr.UsdShadeInputVector GetInputs();
        public pxr.UsdShadeInputVector GetInterfaceInputs();
        public pxr.UsdShadeOutput GetOutput(pxr.TfToken name);
        public pxr.UsdShadeOutputVector GetOutputs();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public class NodeGraphEqualFn : System.IDisposable
        {
            protected bool swigCMemOwn;
            public NodeGraphEqualFn() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
        public class NodeGraphHasher : System.IDisposable
        {
            protected bool swigCMemOwn;
            public NodeGraphHasher() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class UsdShadeOutput : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdShadeOutput() {}
        public UsdShadeOutput(pxr.UsdAttribute attr) {}
        public bool CanConnect(pxr.UsdAttribute source);
        public bool CanConnect(pxr.UsdShadeInput sourceInput);
        public bool CanConnect(pxr.UsdShadeOutput sourceOutput);
        public void ClearSdrMetadata();
        public void ClearSdrMetadataByKey(pxr.TfToken key);
        public bool ClearSource();
        public bool ConnectToSource(pxr.SdfPath sourcePath);
        public bool ConnectToSource(pxr.UsdShadeInput sourceInput);
        public bool ConnectToSource(pxr.UsdShadeOutput sourceOutput);
        public bool ConnectToSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName);
        public bool ConnectToSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType);
        public bool ConnectToSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, pxr.UsdShadeAttributeType sourceType, pxr.SdfValueTypeName typeName);
        public bool DisconnectSource();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttribute GetAttr();
        public pxr.TfToken GetBaseName();
        public bool GetConnectedSource(pxr.UsdShadeConnectableAPI source, pxr.TfToken sourceName, out pxr.UsdShadeAttributeType sourceType);
        public pxr.TfToken GetFullName();
        public pxr.UsdPrim GetPrim();
        public bool GetRawConnectedSourcePaths(pxr.SdfPathVector sourcePaths);
        public pxr.TfToken GetRenderType();
        public pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t GetSdrMetadata();
        public string GetSdrMetadataByKey(pxr.TfToken key);
        public pxr.SdfValueTypeName GetTypeName();
        public bool HasConnectedSource();
        public bool HasRenderType();
        public bool HasSdrMetadata();
        public bool HasSdrMetadataByKey(pxr.TfToken key);
        public bool IsDefined();
        public static bool IsOutput(pxr.UsdAttribute attr);
        public bool IsSourceConnectionFromBaseMaterial();
        public bool Set(pxr.VtValue value);
        public bool Set(pxr.VtValue value, pxr.UsdTimeCode time);
        public bool SetRenderType(pxr.TfToken renderType);
        public void SetSdrMetadata(pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t sdrMetadata);
        public void SetSdrMetadataByKey(pxr.TfToken key, string value);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdShadeOutputVector : System.Collections.Generic.IEnumerable<pxr.UsdShadeOutput>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdShadeOutput this[int index] { get; set; }
        public UsdShadeOutputVector() {}
        public UsdShadeOutputVector(pxr.UsdShadeOutputVector other) {}
        public UsdShadeOutputVector(System.Collections.ICollection c) {}
        public UsdShadeOutputVector(int capacity) {}
        public void Add(pxr.UsdShadeOutput x);
        public void AddRange(pxr.UsdShadeOutputVector values);
        public void Clear();
        public void CopyTo(pxr.UsdShadeOutput[] array);
        public void CopyTo(pxr.UsdShadeOutput[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdShadeOutput[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdShadeOutputVector.UsdShadeOutputVectorEnumerator GetEnumerator();
        public pxr.UsdShadeOutputVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdShadeOutput x);
        public void InsertRange(int index, pxr.UsdShadeOutputVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdShadeOutputVector Repeat(pxr.UsdShadeOutput value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdShadeOutputVector values);
        public sealed class UsdShadeOutputVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdShadeOutput>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdShadeOutput Current { get; }
            public UsdShadeOutputVectorEnumerator(pxr.UsdShadeOutputVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdShadeShader : pxr.UsdTyped
    {
        public UsdShadeShader() {}
        public UsdShadeShader(pxr.UsdPrim prim) {}
        public UsdShadeShader(pxr.UsdSchemaBase schemaObj) {}
        public UsdShadeShader(pxr.UsdShadeConnectableAPI connectable) {}
        public void ClearSdrMetadata();
        public void ClearSdrMetadataByKey(pxr.TfToken key);
        public pxr.UsdShadeConnectableAPI ConnectableAPI();
        public pxr.UsdAttribute CreateIdAttr();
        public pxr.UsdAttribute CreateIdAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateIdAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateImplementationSourceAttr();
        public pxr.UsdAttribute CreateImplementationSourceAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateImplementationSourceAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdShadeInput CreateInput(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public pxr.UsdShadeOutput CreateOutput(pxr.TfToken name, pxr.SdfValueTypeName typeName);
        public static pxr.UsdShadeShader Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdShadeShader Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetIdAttr();
        public pxr.TfToken GetImplementationSource();
        public pxr.UsdAttribute GetImplementationSourceAttr();
        public pxr.UsdShadeInput GetInput(pxr.TfToken name);
        public pxr.UsdShadeInputVector GetInputs();
        public pxr.UsdShadeOutput GetOutput(pxr.TfToken name);
        public pxr.UsdShadeOutputVector GetOutputs();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t GetSdrMetadata();
        public string GetSdrMetadataByKey(pxr.TfToken key);
        public bool GetShaderId(pxr.TfToken id);
        public pxr.SdrShaderNode GetShaderNodeForSourceType(pxr.TfToken sourceType);
        public bool GetSourceAsset(pxr.SdfAssetPath sourceAsset);
        public bool GetSourceAsset(pxr.SdfAssetPath sourceAsset, pxr.TfToken sourceType);
        public bool GetSourceAssetSubIdentifier(pxr.TfToken subIdentifier);
        public bool GetSourceAssetSubIdentifier(pxr.TfToken subIdentifier, pxr.TfToken sourceType);
        public bool GetSourceCode(out string sourceCode);
        public bool GetSourceCode(out string sourceCode, pxr.TfToken sourceType);
        public bool HasSdrMetadata();
        public bool HasSdrMetadataByKey(pxr.TfToken key);
        public void SetSdrMetadata(pxr.SWIGTYPE_p_std__unordered_mapT_TfToken_std__string_TfToken__HashFunctor_t sdrMetadata);
        public void SetSdrMetadataByKey(pxr.TfToken key, string value);
        public bool SetShaderId(pxr.TfToken id);
        public bool SetSourceAsset(pxr.SdfAssetPath sourceAsset);
        public bool SetSourceAsset(pxr.SdfAssetPath sourceAsset, pxr.TfToken sourceType);
        public bool SetSourceAssetSubIdentifier(pxr.TfToken subIdentifier);
        public bool SetSourceAssetSubIdentifier(pxr.TfToken subIdentifier, pxr.TfToken sourceType);
        public bool SetSourceCode(string sourceCode);
        public bool SetSourceCode(string sourceCode, pxr.TfToken sourceType);
    }

    public class UsdShadeShaderDefParserPlugin : pxr.NdrParserPlugin
    {
        public UsdShadeShaderDefParserPlugin() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual pxr.TfTokenVector GetDiscoveryTypes();
        public virtual pxr.TfToken GetSourceType();
    }

    public class UsdShadeShaderDefUtils : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdShadeShaderDefUtils() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.NdrNodeDiscoveryResultVector GetNodeDiscoveryResults(pxr.UsdShadeShader shaderDef, string sourceUri);
        public static bool SplitShaderIdentifier(pxr.TfToken identifier, pxr.TfToken familyName, pxr.TfToken implementationName, pxr.NdrVersion version);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdShadeShaderVector : System.Collections.Generic.IEnumerable<pxr.UsdShadeShader>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdShadeShader this[int index] { get; set; }
        public UsdShadeShaderVector() {}
        public UsdShadeShaderVector(pxr.UsdShadeShaderVector other) {}
        public UsdShadeShaderVector(System.Collections.ICollection c) {}
        public UsdShadeShaderVector(int capacity) {}
        public void Add(pxr.UsdShadeShader x);
        public void AddRange(pxr.UsdShadeShaderVector values);
        public void Clear();
        public void CopyTo(pxr.UsdShadeShader[] array);
        public void CopyTo(pxr.UsdShadeShader[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdShadeShader[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdShadeShaderVector.UsdShadeShaderVectorEnumerator GetEnumerator();
        public pxr.UsdShadeShaderVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdShadeShader x);
        public void InsertRange(int index, pxr.UsdShadeShaderVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdShadeShaderVector Repeat(pxr.UsdShadeShader value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdShadeShaderVector values);
        public sealed class UsdShadeShaderVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdShadeShader>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdShadeShader Current { get; }
            public UsdShadeShaderVectorEnumerator(pxr.UsdShadeShaderVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdShadeTokens : System.IDisposable
    {
        public static pxr.TfToken allPurpose;
        public static pxr.TfToken bindMaterialAs;
        public static pxr.TfToken coordSys;
        public static pxr.TfToken displacement;
        public static pxr.TfToken fallbackStrength;
        public static pxr.TfToken full;
        public static pxr.TfToken id;
        public static pxr.TfToken infoId;
        public static pxr.TfToken infoImplementationSource;
        public static pxr.TfToken inputs;
        public static pxr.TfToken interfaceOnly;
        public static pxr.TfToken materialBind;
        public static pxr.TfToken materialBinding;
        public static pxr.TfToken materialBindingCollection;
        public static pxr.TfToken materialVariant;
        public static pxr.TfToken outputs;
        public static pxr.TfToken outputsDisplacement;
        public static pxr.TfToken outputsSurface;
        public static pxr.TfToken outputsVolume;
        public static pxr.TfToken preview;
        public static pxr.TfToken sdrMetadata;
        public static pxr.TfToken sourceAsset;
        public static pxr.TfToken sourceCode;
        public static pxr.TfToken strongerThanDescendants;
        public static pxr.TfToken subIdentifier;
        public static pxr.TfToken surface;
        protected bool swigCMemOwn;
        public static pxr.TfToken universalRenderContext;
        public static pxr.TfToken universalSourceType;
        public static pxr.TfToken volume;
        public static pxr.TfToken weakerThanDescendants;
        public virtual void Dispose();
    }

    public class UsdShadeUtils : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdShadeUtils() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.TfToken GetFullName(pxr.TfToken baseName, pxr.UsdShadeAttributeType type);
        public static string GetPrefixForAttributeType(pxr.UsdShadeAttributeType sourceType);
    }

    public class UsdSkelAnimation : pxr.UsdTyped
    {
        public UsdSkelAnimation() {}
        public UsdSkelAnimation(pxr.UsdPrim prim) {}
        public UsdSkelAnimation(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateBlendShapesAttr();
        public pxr.UsdAttribute CreateBlendShapesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBlendShapesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateBlendShapeWeightsAttr();
        public pxr.UsdAttribute CreateBlendShapeWeightsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBlendShapeWeightsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateJointsAttr();
        public pxr.UsdAttribute CreateJointsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateJointsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRotationsAttr();
        public pxr.UsdAttribute CreateRotationsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRotationsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateScalesAttr();
        public pxr.UsdAttribute CreateScalesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateScalesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateTranslationsAttr();
        public pxr.UsdAttribute CreateTranslationsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateTranslationsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdSkelAnimation Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdSkelAnimation Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetBlendShapesAttr();
        public pxr.UsdAttribute GetBlendShapeWeightsAttr();
        public pxr.UsdAttribute GetJointsAttr();
        public pxr.UsdAttribute GetRotationsAttr();
        public pxr.UsdAttribute GetScalesAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool GetTransforms(pxr.VtMatrix4dArray xforms);
        public bool GetTransforms(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetTranslationsAttr();
        public bool SetTransforms(pxr.VtMatrix4dArray xforms);
        public bool SetTransforms(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time);
    }

    public class UsdSkelAnimMapper : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelAnimMapper() {}
        public UsdSkelAnimMapper(System.UInt32 size) {}
        public UsdSkelAnimMapper(pxr.VtTokenArray sourceOrder, pxr.VtTokenArray targetOrder) {}
        public UsdSkelAnimMapper(pxr.TfToken sourceOrder, System.UInt32 sourceOrderSize, pxr.TfToken targetOrder, System.UInt32 targetOrderSize) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool IsIdentity();
        public bool IsNull();
        public bool IsSparse();
        public bool Remap(pxr.VtValue source, pxr.VtValue target);
        public bool Remap(pxr.VtValue source, pxr.VtValue target, int elementSize);
        public bool Remap(pxr.VtValue source, pxr.VtValue target, int elementSize, pxr.VtValue defaultValue);
        public System.UInt32 size();
    }

    public class UsdSkelAnimQuery : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelAnimQuery() {}
        public bool BlendShapeWeightsMightBeTimeVarying();
        public bool ComputeBlendShapeWeights(pxr.VtFloatArray weights);
        public bool ComputeBlendShapeWeights(pxr.VtFloatArray weights, pxr.UsdTimeCode time);
        public bool ComputeJointLocalTransformComponents(pxr.VtVec3fArray translations, pxr.VtQuatfArray rotations, pxr.VtVec3hArray scales);
        public bool ComputeJointLocalTransformComponents(pxr.VtVec3fArray translations, pxr.VtQuatfArray rotations, pxr.VtVec3hArray scales, pxr.UsdTimeCode time);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtTokenArray GetBlendShapeOrder();
        public bool GetBlendShapeWeightAttributes(pxr.UsdAttributeVector attrs);
        public bool GetBlendShapeWeightTimeSamples(pxr.StdDoubleVector attrs);
        public bool GetBlendShapeWeightTimeSamplesInInterval(pxr.GfInterval interval, pxr.StdDoubleVector times);
        public string GetDescription();
        public pxr.VtTokenArray GetJointOrder();
        public bool GetJointTransformAttributes(pxr.UsdAttributeVector attrs);
        public bool GetJointTransformTimeSamples(pxr.StdDoubleVector times);
        public bool GetJointTransformTimeSamplesInInterval(pxr.GfInterval interval, pxr.StdDoubleVector times);
        public pxr.UsdPrim GetPrim();
        public bool IsValid();
        public bool JointTransformsMightBeTimeVarying();
    }

    public class UsdSkelBinding : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelBinding() {}
        public UsdSkelBinding(pxr.UsdSkelSkeleton skel, pxr.SWIGTYPE_p_VtArrayT_UsdSkelSkinningQuery_t skinningQueries) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdSkelSkeleton GetSkeleton();
        public pxr.SWIGTYPE_p_VtArrayT_UsdSkelSkinningQuery_t GetSkinningTargets();
        public pxr.UsdSkelSkinningQueryVector GetSkinningTargetsAsVector();
    }

    public class UsdSkelBindingAPI : pxr.UsdAPISchemaBase
    {
        public UsdSkelBindingAPI() {}
        public UsdSkelBindingAPI(pxr.UsdPrim prim) {}
        public UsdSkelBindingAPI(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdSkelBindingAPI Apply(pxr.UsdPrim prim);
        public pxr.UsdRelationship CreateAnimationSourceRel();
        public pxr.UsdAttribute CreateBlendShapesAttr();
        public pxr.UsdAttribute CreateBlendShapesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBlendShapesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdRelationship CreateBlendShapeTargetsRel();
        public pxr.UsdAttribute CreateGeomBindTransformAttr();
        public pxr.UsdAttribute CreateGeomBindTransformAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateGeomBindTransformAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateJointIndicesAttr();
        public pxr.UsdAttribute CreateJointIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateJointIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdGeomPrimvar CreateJointIndicesPrimvar(bool constant);
        public pxr.UsdGeomPrimvar CreateJointIndicesPrimvar(bool constant, int elementSize);
        public pxr.UsdAttribute CreateJointsAttr();
        public pxr.UsdAttribute CreateJointsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateJointsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateJointWeightsAttr();
        public pxr.UsdAttribute CreateJointWeightsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateJointWeightsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdGeomPrimvar CreateJointWeightsPrimvar(bool constant);
        public pxr.UsdGeomPrimvar CreateJointWeightsPrimvar(bool constant, int elementSize);
        public pxr.UsdRelationship CreateSkeletonRel();
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdSkelBindingAPI Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public bool GetAnimationSource(pxr.UsdPrim prim);
        public pxr.UsdRelationship GetAnimationSourceRel();
        public pxr.UsdAttribute GetBlendShapesAttr();
        public pxr.UsdRelationship GetBlendShapeTargetsRel();
        public pxr.UsdAttribute GetGeomBindTransformAttr();
        public pxr.UsdPrim GetInheritedAnimationSource();
        public pxr.UsdSkelSkeleton GetInheritedSkeleton();
        public pxr.UsdAttribute GetJointIndicesAttr();
        public pxr.UsdGeomPrimvar GetJointIndicesPrimvar();
        public pxr.UsdAttribute GetJointsAttr();
        public pxr.UsdAttribute GetJointWeightsAttr();
        public pxr.UsdGeomPrimvar GetJointWeightsPrimvar();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool GetSkeleton(pxr.UsdSkelSkeleton skel);
        public pxr.UsdRelationship GetSkeletonRel();
        public bool SetRigidJointInfluence(int jointIndex);
        public bool SetRigidJointInfluence(int jointIndex, float weight);
        public static bool ValidateJointIndices(pxr.SWIGTYPE_p_TfSpanT_int_const_t indices, System.UInt32 numJoints);
        public static bool ValidateJointIndices(pxr.SWIGTYPE_p_TfSpanT_int_const_t indices, System.UInt32 numJoints, out string reason);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdSkelBindingVector : System.Collections.Generic.IEnumerable<pxr.UsdSkelBinding>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdSkelBinding this[int index] { get; set; }
        public UsdSkelBindingVector() {}
        public UsdSkelBindingVector(pxr.UsdSkelBindingVector other) {}
        public UsdSkelBindingVector(System.Collections.ICollection c) {}
        public UsdSkelBindingVector(int capacity) {}
        public void Add(pxr.UsdSkelBinding x);
        public void AddRange(pxr.UsdSkelBindingVector values);
        public void Clear();
        public void CopyTo(pxr.UsdSkelBinding[] array);
        public void CopyTo(pxr.UsdSkelBinding[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdSkelBinding[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdSkelBindingVector.UsdSkelBindingVectorEnumerator GetEnumerator();
        public pxr.UsdSkelBindingVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdSkelBinding x);
        public void InsertRange(int index, pxr.UsdSkelBindingVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdSkelBindingVector Repeat(pxr.UsdSkelBinding value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdSkelBindingVector values);
        public sealed class UsdSkelBindingVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdSkelBinding>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdSkelBinding Current { get; }
            public UsdSkelBindingVectorEnumerator(pxr.UsdSkelBindingVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdSkelBlendShape : pxr.UsdTyped
    {
        public UsdSkelBlendShape() {}
        public UsdSkelBlendShape(pxr.UsdPrim prim) {}
        public UsdSkelBlendShape(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdSkelInbetweenShape CreateInbetween(pxr.TfToken name);
        public pxr.UsdAttribute CreateNormalOffsetsAttr();
        public pxr.UsdAttribute CreateNormalOffsetsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateNormalOffsetsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateOffsetsAttr();
        public pxr.UsdAttribute CreateOffsetsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateOffsetsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreatePointIndicesAttr();
        public pxr.UsdAttribute CreatePointIndicesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreatePointIndicesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdSkelBlendShape Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdSkelBlendShape Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdSkelInbetweenShapeVector GetAuthoredInbetweens();
        public pxr.UsdSkelInbetweenShape GetInbetween(pxr.TfToken name);
        public pxr.UsdSkelInbetweenShapeVector GetInbetweens();
        public pxr.UsdAttribute GetNormalOffsetsAttr();
        public pxr.UsdAttribute GetOffsetsAttr();
        public pxr.UsdAttribute GetPointIndicesAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool HasInbetween(pxr.TfToken name);
        public static bool ValidatePointIndices(pxr.SWIGTYPE_p_TfSpanT_int_const_t indices, System.UInt32 numPoints);
        public static bool ValidatePointIndices(pxr.SWIGTYPE_p_TfSpanT_int_const_t indices, System.UInt32 numPoints, out string reason);
    }

    public class UsdSkelCache : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelCache() {}
        public void Clear();
        public bool ComputeSkelBinding(pxr.UsdSkelRoot skelRoot, pxr.UsdSkelSkeleton skel, pxr.UsdSkelBinding binding);
        public bool ComputeSkelBindings(pxr.UsdSkelRoot skelRoot, pxr.UsdSkelBindingVector bindings);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdSkelAnimQuery GetAnimQuery(pxr.UsdPrim prim);
        public pxr.UsdSkelAnimQuery GetAnimQuery(pxr.UsdSkelAnimation anim);
        public pxr.UsdSkelSkeletonQuery GetSkelQuery(pxr.UsdSkelSkeleton skel);
        public pxr.UsdSkelSkinningQuery GetSkinningQuery(pxr.UsdPrim prim);
        public bool Populate(pxr.UsdSkelRoot root);
    }

    public class UsdSkelInbetweenShape : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelInbetweenShape() {}
        public UsdSkelInbetweenShape(pxr.UsdAttribute attr) {}
        public pxr.UsdAttribute CreateNormalOffsetsAttr();
        public pxr.UsdAttribute CreateNormalOffsetsAttr(pxr.VtValue defaultValue);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttribute GetAttr();
        public bool GetNormalOffsets(pxr.VtVec3fArray offsets);
        public pxr.UsdAttribute GetNormalOffsetsAttr();
        public bool GetOffsets(pxr.VtVec3fArray offsets);
        public bool GetWeight(pxr.SWIGTYPE_p_float weight);
        public bool HasAuthoredWeight();
        public bool IsDefined();
        public static bool IsInbetween(pxr.UsdAttribute attr);
        public bool SetNormalOffsets(pxr.VtVec3fArray offsets);
        public bool SetOffsets(pxr.VtVec3fArray offsets);
        public bool SetWeight(float weight);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdSkelInbetweenShapeVector : System.Collections.Generic.IEnumerable<pxr.UsdSkelInbetweenShape>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdSkelInbetweenShape this[int index] { get; set; }
        public UsdSkelInbetweenShapeVector() {}
        public UsdSkelInbetweenShapeVector(pxr.UsdSkelInbetweenShapeVector other) {}
        public UsdSkelInbetweenShapeVector(System.Collections.ICollection c) {}
        public UsdSkelInbetweenShapeVector(int capacity) {}
        public void Add(pxr.UsdSkelInbetweenShape x);
        public void AddRange(pxr.UsdSkelInbetweenShapeVector values);
        public void Clear();
        public void CopyTo(pxr.UsdSkelInbetweenShape[] array);
        public void CopyTo(pxr.UsdSkelInbetweenShape[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdSkelInbetweenShape[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdSkelInbetweenShapeVector.UsdSkelInbetweenShapeVectorEnumerator GetEnumerator();
        public pxr.UsdSkelInbetweenShapeVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdSkelInbetweenShape x);
        public void InsertRange(int index, pxr.UsdSkelInbetweenShapeVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdSkelInbetweenShapeVector Repeat(pxr.UsdSkelInbetweenShape value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdSkelInbetweenShapeVector values);
        public sealed class UsdSkelInbetweenShapeVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdSkelInbetweenShape>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdSkelInbetweenShape Current { get; }
            public UsdSkelInbetweenShapeVectorEnumerator(pxr.UsdSkelInbetweenShapeVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdSkelPackedJointAnimation : pxr.UsdSkelAnimation
    {
        public UsdSkelPackedJointAnimation() {}
        public UsdSkelPackedJointAnimation(pxr.UsdPrim prim) {}
        public UsdSkelPackedJointAnimation(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdSkelPackedJointAnimation Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdSkelPackedJointAnimation Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdSkelRoot : pxr.UsdGeomBoundable
    {
        public UsdSkelRoot() {}
        public UsdSkelRoot(pxr.UsdPrim prim) {}
        public UsdSkelRoot(pxr.UsdSchemaBase schemaObj) {}
        public static pxr.UsdSkelRoot Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdSkelRoot Find(pxr.UsdPrim prim);
        public static pxr.UsdSkelRoot Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdSkelSkeleton : pxr.UsdGeomBoundable
    {
        public UsdSkelSkeleton() {}
        public UsdSkelSkeleton(pxr.UsdPrim prim) {}
        public UsdSkelSkeleton(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateBindTransformsAttr();
        public pxr.UsdAttribute CreateBindTransformsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateBindTransformsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateJointNamesAttr();
        public pxr.UsdAttribute CreateJointNamesAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateJointNamesAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateJointsAttr();
        public pxr.UsdAttribute CreateJointsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateJointsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateRestTransformsAttr();
        public pxr.UsdAttribute CreateRestTransformsAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateRestTransformsAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdSkelSkeleton Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdSkelSkeleton Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetBindTransformsAttr();
        public pxr.UsdAttribute GetJointNamesAttr();
        public pxr.UsdAttribute GetJointsAttr();
        public pxr.UsdAttribute GetRestTransformsAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdSkelSkeletonQuery : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelSkeletonQuery() {}
        public bool ComputeJointLocalTransforms(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time);
        public bool ComputeJointLocalTransforms(pxr.VtMatrix4dArray xforms, pxr.UsdTimeCode time, bool atRest);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdSkelAnimQuery GetAnimQuery();
        public string GetDescription();
        public pxr.VtTokenArray GetJointOrder();
        public bool GetJointWorldBindTransforms(pxr.VtMatrix4dArray xforms);
        public pxr.UsdSkelAnimMapper GetMapper();
        public pxr.UsdPrim GetPrim();
        public pxr.UsdSkelSkeleton GetSkeleton();
        public pxr.UsdSkelTopology GetTopology();
        public bool HasBindPose();
        public bool HasRestPose();
        public bool IsValid();
    }

    public class UsdSkelSkinningQuery : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelSkinningQuery() {}
        public UsdSkelSkinningQuery(pxr.UsdPrim prim, pxr.VtTokenArray skelJointOrder, pxr.VtTokenArray blendShapeOrder, pxr.UsdAttribute jointIndices, pxr.UsdAttribute jointWeights, pxr.UsdAttribute geomBindTransform, pxr.UsdAttribute joints, pxr.UsdAttribute blendShapes, pxr.UsdRelationship blendShapeTargets) {}
        public bool ComputeJointInfluences(pxr.VtIntArray indices, pxr.VtFloatArray weights);
        public bool ComputeJointInfluences(pxr.VtIntArray indices, pxr.VtFloatArray weights, pxr.UsdTimeCode time);
        public bool ComputeVaryingJointInfluences(System.UInt32 numPoints, pxr.VtIntArray indices, pxr.VtFloatArray weights);
        public bool ComputeVaryingJointInfluences(System.UInt32 numPoints, pxr.VtIntArray indices, pxr.VtFloatArray weights, pxr.UsdTimeCode time);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_std__shared_ptrT_UsdSkelAnimMapper_t GetBlendShapeMapper();
        public bool GetBlendShapeOrder(pxr.VtTokenArray blendShapes);
        public pxr.UsdAttribute GetBlendShapesAttr();
        public pxr.UsdRelationship GetBlendShapeTargetsRel();
        public string GetDescription();
        public pxr.GfMatrix4d GetGeomBindTransform();
        public pxr.GfMatrix4d GetGeomBindTransform(pxr.UsdTimeCode time);
        public pxr.UsdAttribute GetGeomBindTransformAttr();
        public pxr.TfToken GetInterpolation();
        public pxr.UsdGeomPrimvar GetJointIndicesPrimvar();
        public pxr.SWIGTYPE_p_std__shared_ptrT_UsdSkelAnimMapper_t GetJointMapper();
        public bool GetJointOrder(pxr.VtTokenArray jointOrder);
        public pxr.UsdGeomPrimvar GetJointWeightsPrimvar();
        public int GetNumInfluencesPerComponent();
        public pxr.UsdPrim GetPrim();
        public bool GetTimeSamples(pxr.StdDoubleVector times);
        public bool HasBlendShapes();
        public bool HasJointInfluences();
        public bool IsRigidlyDeformed();
        public bool IsValid();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdSkelSkinningQueryVector : System.Collections.Generic.IEnumerable<pxr.UsdSkelSkinningQuery>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdSkelSkinningQuery this[int index] { get; set; }
        public UsdSkelSkinningQueryVector() {}
        public UsdSkelSkinningQueryVector(pxr.UsdSkelSkinningQueryVector other) {}
        public UsdSkelSkinningQueryVector(System.Collections.ICollection c) {}
        public UsdSkelSkinningQueryVector(int capacity) {}
        public void Add(pxr.UsdSkelSkinningQuery x);
        public void AddRange(pxr.UsdSkelSkinningQueryVector values);
        public void Clear();
        public void CopyTo(pxr.UsdSkelSkinningQuery[] array);
        public void CopyTo(pxr.UsdSkelSkinningQuery[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdSkelSkinningQuery[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdSkelSkinningQueryVector.UsdSkelSkinningQueryVectorEnumerator GetEnumerator();
        public pxr.UsdSkelSkinningQueryVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdSkelSkinningQuery x);
        public void InsertRange(int index, pxr.UsdSkelSkinningQueryVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdSkelSkinningQueryVector Repeat(pxr.UsdSkelSkinningQuery value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdSkelSkinningQueryVector values);
        public sealed class UsdSkelSkinningQueryVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdSkelSkinningQuery>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdSkelSkinningQuery Current { get; }
            public UsdSkelSkinningQueryVectorEnumerator(pxr.UsdSkelSkinningQueryVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdSkelTokens : System.IDisposable
    {
        public static pxr.TfToken bindTransforms;
        public static pxr.TfToken blendShapes;
        public static pxr.TfToken blendShapeWeights;
        public static pxr.TfToken jointNames;
        public static pxr.TfToken joints;
        public static pxr.TfToken normalOffsets;
        public static pxr.TfToken offsets;
        public static pxr.TfToken pointIndices;
        public static pxr.TfToken primvarsSkelGeomBindTransform;
        public static pxr.TfToken primvarsSkelJointIndices;
        public static pxr.TfToken primvarsSkelJointWeights;
        public static pxr.TfToken restTransforms;
        public static pxr.TfToken rotations;
        public static pxr.TfToken scales;
        public static pxr.TfToken skelAnimationSource;
        public static pxr.TfToken skelBlendShapes;
        public static pxr.TfToken skelBlendShapeTargets;
        public static pxr.TfToken skelJoints;
        public static pxr.TfToken skelSkeleton;
        protected bool swigCMemOwn;
        public static pxr.TfToken translations;
        public static pxr.TfToken weight;
        public virtual void Dispose();
    }

    public class UsdSkelTopology : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdSkelTopology() {}
        public UsdSkelTopology(pxr.SWIGTYPE_p_TfSpanT_SdfPath_const_t paths) {}
        public UsdSkelTopology(pxr.SWIGTYPE_p_TfSpanT_TfToken_const_t paths) {}
        public UsdSkelTopology(pxr.VtIntArray parentIndices) {}
        public UsdSkelTopology(pxr.VtTokenArray topology) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public System.UInt32 GetNumJoints();
        public int GetParent(System.UInt32 index);
        public pxr.VtIntArray GetParentIndices();
        public bool IsRoot(System.UInt32 index);
        public System.UInt32 size();
        public bool Validate();
        public bool Validate(out string reason);
    }

    public class UsdSpecializes : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool AddSpecialize(pxr.SdfPath primPath);
        public bool AddSpecialize(pxr.SdfPath primPath, pxr.UsdListPosition position);
        public bool ClearSpecializes();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdPrim GetPrim();
        public bool RemoveSpecialize(pxr.SdfPath primPath);
        public bool SetSpecializes(pxr.SdfPathVector items);
    }

    public class UsdStage : System.IDisposable
    {
        public void ClearDefaultPrim();
        public bool ClearMetadata(pxr.TfToken key);
        public bool ClearMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public pxr.UsdPrim CreateClassPrim(pxr.SdfPath rootPrimPath);
        public static pxr.UsdStage CreateInMemory();
        public static pxr.UsdStage CreateInMemory(pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateInMemory(string identifier);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.SdfLayerHandle sessionLayer);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.SdfLayerHandle sessionLayer, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateInMemory(string identifier, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateNew(string identifier);
        public static pxr.UsdStage CreateNew(string identifier, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage CreateNew(string identifier, pxr.SdfLayerHandle sessionLayer);
        public static pxr.UsdStage CreateNew(string identifier, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateNew(string identifier, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateNew(string identifier, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage CreateNew(string identifier, pxr.SdfLayerHandle sessionLayer, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage CreateNew(string identifier, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public pxr.UsdPrim DefinePrim(pxr.SdfPath path);
        public pxr.UsdPrim DefinePrim(pxr.SdfPath path, pxr.TfToken typeName);
        public virtual void Dispose();
        public bool Export(string filename);
        public bool Export(string filename, bool addSourceFileComment);
        public bool Export(string filename, bool addSourceFileComment, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public bool ExportToString(out string result);
        public bool ExportToString(out string result, bool addSourceFileComment);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_std__setT_SdfPath_t FindLoadable();
        public pxr.SWIGTYPE_p_std__setT_SdfPath_t FindLoadable(pxr.SdfPath rootPath);
        public pxr.SdfLayer Flatten();
        public pxr.SdfLayer Flatten(bool addSourceFileComment);
        public pxr.SdfPathVector GetAllPaths();
        public pxr.SdfPathVector GetAllPathsByType(string typeName, pxr.SdfPath rootPath);
        public pxr.UsdPrimVector GetAllPrims();
        public pxr.UsdPrimVector GetAllPrimsByType(string typeName);
        public pxr.UsdAttribute GetAttributeAtPath(pxr.SdfPath path);
        public static void GetColorConfigFallbacks(pxr.SdfAssetPath colorConfiguration, pxr.TfToken colorManagementSystem);
        public pxr.SdfAssetPath GetColorConfiguration();
        public pxr.TfToken GetColorManagementSystem();
        public pxr.UsdPrim GetDefaultPrim();
        public pxr.UsdEditTarget GetEditTarget();
        public pxr.UsdEditTarget GetEditTargetForLocalLayer(pxr.SdfLayerHandle layer);
        public pxr.UsdEditTarget GetEditTargetForLocalLayer(System.UInt32 i);
        public double GetEndTimeCode();
        public double GetFramesPerSecond();
        public static pxr.SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t GetGlobalVariantFallbacks();
        public pxr.UsdInterpolationType GetInterpolationType();
        public pxr.SdfLayerHandleVector GetLayerStack();
        public pxr.SdfLayerHandleVector GetLayerStack(bool includeSessionLayers);
        public pxr.UsdStageLoadRules GetLoadRules();
        public pxr.SWIGTYPE_p_std__setT_SdfPath_t GetLoadSet();
        public pxr.UsdPrimVector GetMasters();
        public bool GetMetadata(pxr.TfToken key, pxr.VtValue value);
        public bool GetMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath, pxr.VtValue value);
        public pxr.StdStringVector GetMutedLayers();
        public pxr.UsdObject GetObjectAtPath(pxr.SdfPath path);
        public pxr.ArResolverContext GetPathResolverContext();
        public pxr.UsdStagePopulationMask GetPopulationMask();
        public pxr.UsdPrim GetPrimAtPath(pxr.SdfPath path);
        public pxr.UsdProperty GetPropertyAtPath(pxr.SdfPath path);
        public pxr.UsdPrim GetPseudoRoot();
        public pxr.UsdRelationship GetRelationshipAtPath(pxr.SdfPath path);
        public pxr.SdfLayerHandle GetRootLayer();
        public pxr.SdfLayerHandle GetSessionLayer();
        public double GetStartTimeCode();
        public double GetTimeCodesPerSecond();
        public pxr.SdfLayerHandleVector GetUsedLayers();
        public pxr.SdfLayerHandleVector GetUsedLayers(bool includeClipLayers);
        public bool HasAuthoredMetadata(pxr.TfToken key);
        public bool HasAuthoredMetadataDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public bool HasAuthoredTimeCodeRange();
        public bool HasDefaultPrim();
        public bool HasLocalLayer(pxr.SdfLayerHandle layer);
        public bool HasMetadata(pxr.TfToken key);
        public bool HasMetadataDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public bool IsLayerMuted(string layerIdentifier);
        public static bool IsSupportedFile(string filePath);
        public pxr.UsdPrim Load();
        public pxr.UsdPrim Load(pxr.SdfPath path);
        public pxr.UsdPrim Load(pxr.SdfPath path, pxr.UsdLoadPolicy policy);
        public void LoadAndUnload(pxr.SWIGTYPE_p_std__setT_SdfPath_t loadSet, pxr.SWIGTYPE_p_std__setT_SdfPath_t unloadSet);
        public void LoadAndUnload(pxr.SWIGTYPE_p_std__setT_SdfPath_t loadSet, pxr.SWIGTYPE_p_std__setT_SdfPath_t unloadSet, pxr.UsdLoadPolicy policy);
        public void MuteAndUnmuteLayers(pxr.StdStringVector muteLayers, pxr.StdStringVector unmuteLayers);
        public void MuteLayer(string layerIdentifier);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer);
        public static pxr.UsdStage Open(string filePath);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage Open(string filePath, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage Open(string filePath, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage Open(string filePath, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage Open(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.UsdStagePopulationMask mask);
        public static pxr.UsdStage OpenMasked(string filePath, pxr.UsdStagePopulationMask mask);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStagePopulationMask mask);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.UsdStagePopulationMask mask);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.UsdStagePopulationMask mask, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage OpenMasked(string filePath, pxr.ArResolverContext pathResolverContext, pxr.UsdStagePopulationMask mask);
        public static pxr.UsdStage OpenMasked(string filePath, pxr.UsdStagePopulationMask mask, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStagePopulationMask mask, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStagePopulationMask mask);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.UsdStagePopulationMask mask, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage OpenMasked(string filePath, pxr.ArResolverContext pathResolverContext, pxr.UsdStagePopulationMask mask, pxr.UsdStage.InitialLoadSet load);
        public static pxr.UsdStage OpenMasked(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext, pxr.UsdStagePopulationMask mask, pxr.UsdStage.InitialLoadSet load);
        public pxr.UsdPrim OverridePrim(pxr.SdfPath path);
        public void Reload();
        public bool RemovePrim(pxr.SdfPath path);
        public string ResolveIdentifierToEditTarget(string identifier);
        public void Save();
        public void SaveSessionLayers();
        public static void SetColorConfigFallbacks(pxr.SdfAssetPath colorConfiguration, pxr.TfToken colorManagementSystem);
        public void SetColorConfiguration(pxr.SdfAssetPath colorConfig);
        public void SetColorManagementSystem(pxr.TfToken cms);
        public void SetDefaultPrim(pxr.UsdPrim prim);
        public void SetEditTarget(pxr.UsdEditTarget editTarget);
        public void SetEndTimeCode(double arg0);
        public void SetFramesPerSecond(double framesPerSecond);
        public static void SetGlobalVariantFallbacks(pxr.SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t fallbacks);
        public void SetInterpolationType(pxr.UsdInterpolationType interpolationType);
        public void SetLoadRules(pxr.UsdStageLoadRules rules);
        public bool SetMetadata(pxr.TfToken key, pxr.VtValue value);
        public bool SetMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath, pxr.VtValue value);
        public void SetPopulationMask(pxr.UsdStagePopulationMask mask);
        public void SetStartTimeCode(double arg0);
        public void SetTimeCodesPerSecond(double timeCodesPerSecond);
        public pxr.UsdPrimRange Traverse();
        public pxr.UsdPrimRange Traverse(pxr.Usd_PrimFlagsPredicate predicate);
        public pxr.UsdPrimRange TraverseAll();
        public void Unload();
        public void Unload(pxr.SdfPath path);
        public void UnmuteLayer(string layerIdentifier);
        public void WriteFallbackPrimTypes();
        public enum InitialLoadSet
        {
            public const pxr.UsdStage.InitialLoadSet LoadAll = 0;
            public const pxr.UsdStage.InitialLoadSet LoadNone = 1;
            public int value__;
        }
    }

    public class UsdStageCache : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdStageCache() {}
        public UsdStageCache(pxr.UsdStageCache other) {}
        public void Clear();
        public bool Contains(pxr.SWIGTYPE_p_UsdStageCache__Id id);
        public bool Contains(pxr.UsdStage stage);
        public virtual void Dispose();
        public bool Erase(pxr.SWIGTYPE_p_UsdStageCache__Id id);
        public bool Erase(pxr.UsdStage stage);
        public System.UInt32 EraseAll(pxr.SdfLayerHandle rootLayer);
        public System.UInt32 EraseAll(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer);
        public System.UInt32 EraseAll(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext);
        protected virtual void Finalize();
        public pxr.UsdStage Find(pxr.SWIGTYPE_p_UsdStageCache__Id id);
        public pxr.UsdStageRefPtrVector FindAllMatching(pxr.SdfLayerHandle rootLayer);
        public pxr.UsdStageRefPtrVector FindAllMatching(pxr.SdfLayerHandle rootLayer, pxr.ArResolverContext pathResolverContext);
        public pxr.UsdStageRefPtrVector FindAllMatching(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer);
        public pxr.UsdStageRefPtrVector FindAllMatching(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext);
        public pxr.UsdStage FindOneMatching(pxr.SdfLayerHandle rootLayer);
        public pxr.UsdStage FindOneMatching(pxr.SdfLayerHandle rootLayer, pxr.ArResolverContext pathResolverContext);
        public pxr.UsdStage FindOneMatching(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer);
        public pxr.UsdStage FindOneMatching(pxr.SdfLayerHandle rootLayer, pxr.SdfLayerHandle sessionLayer, pxr.ArResolverContext pathResolverContext);
        public pxr.UsdStageRefPtrVector GetAllStages();
        public string GetDebugName();
        public pxr.SWIGTYPE_p_UsdStageCache__Id GetId(pxr.UsdStage stage);
        public pxr.SWIGTYPE_p_UsdStageCache__Id Insert(pxr.UsdStage stage);
        public bool IsEmpty();
        public pxr.UsdStageCacheResultPair RequestStage(pxr.UsdStageCacheRequest request);
        public void SetDebugName(string debugName);
        public System.UInt32 Size();
        public void swap(pxr.UsdStageCache other);
    }

    public class UsdStageCacheRequest : System.IDisposable
    {
        protected bool swigCMemOwn;
        public virtual void Dispose();
        protected virtual void Finalize();
        public virtual bool IsSatisfiedBy(pxr.UsdStage stage);
        public virtual bool IsSatisfiedBy(pxr.UsdStageCacheRequest pending);
        public virtual pxr.UsdStage Manufacture();
    }

    public class UsdStageCacheResultPair : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.UsdStage first { get; set; }
        public bool second { get; set; }
        public UsdStageCacheResultPair() {}
        public UsdStageCacheResultPair(pxr.UsdStageCacheResultPair p) {}
        public UsdStageCacheResultPair(pxr.UsdStage t, bool u) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class UsdStageLoadRules : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdStageLoadRules() {}
        public UsdStageLoadRules(pxr.UsdStageLoadRules arg0) {}
        public void AddRule(pxr.SdfPath path, pxr.UsdStageLoadRules.Rule rule);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdStageLoadRules.Rule GetEffectiveRuleForPath(pxr.SdfPath path);
        public pxr.UsdStageLoadRulesVectorPair GetRules();
        public bool IsLoaded(pxr.SdfPath path);
        public bool IsLoadedWithAllDescendants(pxr.SdfPath path);
        public bool IsLoadedWithNoDescendants(pxr.SdfPath path);
        public static pxr.UsdStageLoadRules LoadAll();
        public void LoadAndUnload(pxr.SWIGTYPE_p_std__setT_SdfPath_t loadSet, pxr.SWIGTYPE_p_std__setT_SdfPath_t unloadSet, pxr.UsdLoadPolicy policy);
        public static pxr.UsdStageLoadRules LoadNone();
        public void LoadWithDescendants(pxr.SdfPath path);
        public void LoadWithoutDescendants(pxr.SdfPath path);
        public void Minimize();
        public void SetRules(pxr.UsdStageLoadRulesVectorPair rules);
        public void swap(pxr.UsdStageLoadRules other);
        public void Unload(pxr.SdfPath path);
        public enum Rule
        {
            public const pxr.UsdStageLoadRules.Rule AllRule = 0;
            public const pxr.UsdStageLoadRules.Rule NoneRule = 2;
            public const pxr.UsdStageLoadRules.Rule OnlyRule = 1;
            public int value__;
        }
    }

    public class UsdStageLoadRulesPair : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.SdfPath first { get; set; }
        public pxr.UsdStageLoadRules.Rule second { get; set; }
        public UsdStageLoadRulesPair() {}
        public UsdStageLoadRulesPair(pxr.UsdStageLoadRulesPair p) {}
        public UsdStageLoadRulesPair(pxr.SdfPath t, pxr.UsdStageLoadRules.Rule u) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdStageLoadRulesVectorPair : System.Collections.Generic.IEnumerable<pxr.UsdStageLoadRulesPair>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdStageLoadRulesPair this[int index] { get; set; }
        public UsdStageLoadRulesVectorPair() {}
        public UsdStageLoadRulesVectorPair(pxr.UsdStageLoadRulesVectorPair other) {}
        public UsdStageLoadRulesVectorPair(System.Collections.ICollection c) {}
        public UsdStageLoadRulesVectorPair(int capacity) {}
        public void Add(pxr.UsdStageLoadRulesPair x);
        public void AddRange(pxr.UsdStageLoadRulesVectorPair values);
        public void Clear();
        public void CopyTo(pxr.UsdStageLoadRulesPair[] array);
        public void CopyTo(pxr.UsdStageLoadRulesPair[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdStageLoadRulesPair[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdStageLoadRulesVectorPair.UsdStageLoadRulesVectorPairEnumerator GetEnumerator();
        public pxr.UsdStageLoadRulesVectorPair GetRange(int index, int count);
        public void Insert(int index, pxr.UsdStageLoadRulesPair x);
        public void InsertRange(int index, pxr.UsdStageLoadRulesVectorPair values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdStageLoadRulesVectorPair Repeat(pxr.UsdStageLoadRulesPair value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdStageLoadRulesVectorPair values);
        public sealed class UsdStageLoadRulesVectorPairEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdStageLoadRulesPair>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdStageLoadRulesPair Current { get; }
            public UsdStageLoadRulesVectorPairEnumerator(pxr.UsdStageLoadRulesVectorPair collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdStagePopulationMask : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdStagePopulationMask() {}
        public UsdStagePopulationMask(pxr.SdfPathVector paths) {}
        public UsdStagePopulationMask(pxr.UsdStagePopulationMask arg0) {}
        public pxr.UsdStagePopulationMask Add(pxr.SdfPath path);
        public pxr.UsdStagePopulationMask Add(pxr.UsdStagePopulationMask other);
        public static pxr.UsdStagePopulationMask All();
        public virtual void Dispose();
        protected virtual void Finalize();
        public bool GetIncludedChildNames(pxr.SdfPath path, pxr.TfTokenVector childNames);
        public pxr.UsdStagePopulationMask GetIntersection(pxr.UsdStagePopulationMask other);
        public pxr.SdfPathVector GetPaths();
        public pxr.UsdStagePopulationMask GetUnion(pxr.SdfPath path);
        public pxr.UsdStagePopulationMask GetUnion(pxr.UsdStagePopulationMask other);
        public bool Includes(pxr.SdfPath path);
        public bool Includes(pxr.UsdStagePopulationMask other);
        public bool IncludesSubtree(pxr.SdfPath path);
        public static pxr.UsdStagePopulationMask Intersection(pxr.UsdStagePopulationMask l, pxr.UsdStagePopulationMask r);
        public bool IsEmpty();
        public void swap(pxr.UsdStagePopulationMask other);
        public static pxr.UsdStagePopulationMask Union(pxr.UsdStagePopulationMask l, pxr.UsdStagePopulationMask r);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdStageRefPtrVector : System.Collections.Generic.IEnumerable<pxr.UsdStage>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdStage this[int index] { get; set; }
        public UsdStageRefPtrVector() {}
        public UsdStageRefPtrVector(pxr.UsdStageRefPtrVector other) {}
        public UsdStageRefPtrVector(System.Collections.ICollection c) {}
        public UsdStageRefPtrVector(int capacity) {}
        public void Add(pxr.UsdStage x);
        public void AddRange(pxr.UsdStageRefPtrVector values);
        public void Clear();
        public void CopyTo(pxr.UsdStage[] array);
        public void CopyTo(pxr.UsdStage[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdStage[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdStageRefPtrVector.UsdStageRefPtrVectorEnumerator GetEnumerator();
        public pxr.UsdStageRefPtrVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdStage x);
        public void InsertRange(int index, pxr.UsdStageRefPtrVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdStageRefPtrVector Repeat(pxr.UsdStage value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdStageRefPtrVector values);
        public sealed class UsdStageRefPtrVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdStage>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdStage Current { get; }
            public UsdStageRefPtrVectorEnumerator(pxr.UsdStageRefPtrVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdStageWeakPtr : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdStageWeakPtr(pxr.UsdStage stage) {}
        public pxr.UsdStage __deref__();
        public bool ClearMetadata(pxr.TfToken key);
        public bool ClearMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public virtual void Dispose();
        public bool Export(string filename);
        public bool Export(string filename, bool addSourceFileComment);
        public bool Export(string filename, bool addSourceFileComment, pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t args);
        public bool ExportToString(pxr.SWIGTYPE_p_std__string result);
        public bool ExportToString(pxr.SWIGTYPE_p_std__string result, bool addSourceFileComment);
        protected virtual void Finalize();
        public pxr.SdfLayer Flatten();
        public pxr.SdfLayer Flatten(bool addSourceFileComment);
        public pxr.UsdAttribute GetAttributeAtPath(pxr.SdfPath path);
        public pxr.SdfAssetPath GetColorConfiguration();
        public pxr.TfToken GetColorManagementSystem();
        public pxr.UsdPrim GetDefaultPrim();
        public pxr.UsdEditTarget GetEditTarget();
        public double GetEndTimeCode();
        public double GetFramesPerSecond();
        public pxr.UsdInterpolationType GetInterpolationType();
        public pxr.SdfLayerHandleVector GetLayerStack();
        public pxr.SdfLayerHandleVector GetLayerStack(bool includeSessionLayers);
        public pxr.UsdStageLoadRules GetLoadRules();
        public pxr.UsdPrimVector GetMasters();
        public bool GetMetadata(pxr.TfToken key, pxr.VtValue value);
        public bool GetMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath, pxr.VtValue value);
        public pxr.StdStringVector GetMutedLayers();
        public pxr.UsdObject GetObjectAtPath(pxr.SdfPath path);
        public pxr.ArResolverContext GetPathResolverContext();
        public pxr.UsdStagePopulationMask GetPopulationMask();
        public pxr.UsdPrim GetPrimAtPath(pxr.SdfPath path);
        public pxr.UsdProperty GetPropertyAtPath(pxr.SdfPath path);
        public pxr.UsdPrim GetPseudoRoot();
        public pxr.UsdRelationship GetRelationshipAtPath(pxr.SdfPath path);
        public pxr.SdfLayerHandle GetRootLayer();
        public pxr.SdfLayerHandle GetSessionLayer();
        public double GetStartTimeCode();
        public double GetTimeCodesPerSecond();
        public pxr.SdfLayerHandleVector GetUsedLayers();
        public pxr.SdfLayerHandleVector GetUsedLayers(bool includeClipLayers);
        public bool HasAuthoredMetadata(pxr.TfToken key);
        public bool HasAuthoredMetadataDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public bool HasAuthoredTimeCodeRange();
        public bool HasDefaultPrim();
        public bool HasLocalLayer(pxr.SdfLayerHandle layer);
        public bool HasMetadata(pxr.TfToken key);
        public bool HasMetadataDictKey(pxr.TfToken key, pxr.TfToken keyPath);
        public bool IsLayerMuted(string layerIdentifier);
        public string ResolveIdentifierToEditTarget(string identifier);
        public void SetColorConfiguration(pxr.SdfAssetPath colorConfig);
        public void SetColorManagementSystem(pxr.TfToken cms);
        public void SetFramesPerSecond(double framesPerSecond);
        public bool SetMetadata(pxr.TfToken key, pxr.VtValue value);
        public bool SetMetadataByDictKey(pxr.TfToken key, pxr.TfToken keyPath, pxr.VtValue value);
        public void SetTimeCodesPerSecond(double timeCodesPerSecond);
    }

    public class UsdTimeCode : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdTimeCode() {}
        public UsdTimeCode(pxr.SdfTimeCode timeCode) {}
        public UsdTimeCode(double t) {}
        public static pxr.UsdTimeCode Default();
        public virtual void Dispose();
        public static pxr.UsdTimeCode EarliestTime();
        public virtual bool Equals(object rhs);
        protected virtual void Finalize();
        public virtual int GetHashCode();
        public double GetValue();
        public bool IsDefault();
        public bool IsEarliestTime();
        public bool IsNumeric();
        public static bool operator ==(pxr.UsdTimeCode lhs, pxr.UsdTimeCode rhs);
        public static pxr.UsdTimeCode op_Implicit(double value);
        public static bool operator !=(pxr.UsdTimeCode lhs, pxr.UsdTimeCode rhs);
        public static double SafeStep();
        public static double SafeStep(double maxValue);
        public static double SafeStep(double maxValue, double maxCompression);
    }

    [System.Reflection.DefaultMember(@"Item")] public class UsdTimeCodeVector : System.Collections.Generic.IEnumerable<pxr.UsdTimeCode>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.UsdTimeCode this[int index] { get; set; }
        public UsdTimeCodeVector() {}
        public UsdTimeCodeVector(pxr.UsdTimeCodeVector other) {}
        public UsdTimeCodeVector(System.Collections.ICollection c) {}
        public UsdTimeCodeVector(int capacity) {}
        public void Add(pxr.UsdTimeCode x);
        public void AddRange(pxr.UsdTimeCodeVector values);
        public void Clear();
        public void CopyTo(pxr.UsdTimeCode[] array);
        public void CopyTo(pxr.UsdTimeCode[] array, int arrayIndex);
        public void CopyTo(int index, pxr.UsdTimeCode[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdTimeCodeVector.UsdTimeCodeVectorEnumerator GetEnumerator();
        public pxr.UsdTimeCodeVector GetRange(int index, int count);
        public void Insert(int index, pxr.UsdTimeCode x);
        public void InsertRange(int index, pxr.UsdTimeCodeVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.UsdTimeCodeVector Repeat(pxr.UsdTimeCode value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.UsdTimeCodeVector values);
        public sealed class UsdTimeCodeVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.UsdTimeCode>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.UsdTimeCode Current { get; }
            public UsdTimeCodeVectorEnumerator(pxr.UsdTimeCodeVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    public class UsdTyped : pxr.UsdSchemaBase
    {
        public UsdTyped() {}
        public UsdTyped(pxr.UsdPrim prim) {}
        public UsdTyped(pxr.UsdSchemaBase schemaObj) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdTyped Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdUtilsRegisteredVariantSet : System.IDisposable
    {
        protected bool swigCMemOwn;
        public string name { get; }
        public pxr.UsdUtilsRegisteredVariantSet.SelectionExportPolicy selectionExportPolicy { get; }
        public UsdUtilsRegisteredVariantSet(string name, pxr.UsdUtilsRegisteredVariantSet.SelectionExportPolicy selectionExportPolicy) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public enum SelectionExportPolicy
        {
            public const pxr.UsdUtilsRegisteredVariantSet.SelectionExportPolicy Always = 2;
            public const pxr.UsdUtilsRegisteredVariantSet.SelectionExportPolicy IfAuthored = 1;
            public const pxr.UsdUtilsRegisteredVariantSet.SelectionExportPolicy Never = 0;
            public int value__;
        }
    }

    public class UsdUtilsSparseAttrValueWriter : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdUtilsSparseAttrValueWriter(pxr.UsdAttribute attr) {}
        public UsdUtilsSparseAttrValueWriter(pxr.UsdAttribute attr, pxr.VtValue defaultValue) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.UsdAttribute GetAttr();
        public bool SetTimeSample(pxr.VtValue value, pxr.UsdTimeCode time);
    }

    public class UsdUtilsSparseValueWriter : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdUtilsSparseValueWriter() {}
        public void Clear();
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_std__vectorT_UsdUtilsSparseAttrValueWriter_t GetSparseAttrValueWriters();
        public bool SetAttribute(pxr.UsdAttribute attr, pxr.VtValue value);
        public bool SetAttribute(pxr.UsdAttribute attr, pxr.VtValue value, pxr.UsdTimeCode time);
    }

    public class UsdUtilsStageCache : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdUtilsStageCache() {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdStageCache Get();
        public static pxr.SdfLayer GetSessionLayerForVariantSelections(pxr.TfToken modelName, pxr.SWIGTYPE_p_std__vectorT_std__pairT_std__string_std__string_t_t variantSelections);
    }

    public enum UsdUtilsStitchValueStatus
    {
        public const pxr.UsdUtilsStitchValueStatus NoStitchedValue = 0;
        public const pxr.UsdUtilsStitchValueStatus UseDefaultValue = 1;
        public const pxr.UsdUtilsStitchValueStatus UseSuppliedValue = 2;
        public int value__;
    }

    public class UsdVariantSet : System.IDisposable
    {
        protected bool swigCMemOwn;
        public bool AddVariant(string variantName);
        public bool AddVariant(string variantName, pxr.UsdListPosition position);
        public bool ClearVariantSelection();
        public virtual void Dispose();
        protected virtual void Finalize();
        public string GetName();
        public pxr.UsdPrim GetPrim();
        public pxr.SWIGTYPE_p_std__pairT_UsdStageWeakPtr_UsdEditTarget_t GetVariantEditContext();
        public pxr.SWIGTYPE_p_std__pairT_UsdStageWeakPtr_UsdEditTarget_t GetVariantEditContext(pxr.SdfLayerHandle layer);
        public pxr.UsdEditTarget GetVariantEditTarget();
        public pxr.UsdEditTarget GetVariantEditTarget(pxr.SdfLayerHandle layer);
        public pxr.StdStringVector GetVariantNames();
        public string GetVariantSelection();
        public bool HasAuthoredVariant(string variantName);
        public bool HasAuthoredVariantSelection();
        public bool HasAuthoredVariantSelection(out string value);
        public bool IsValid();
        public bool SetVariantSelection(string variantName);
    }

    public class UsdVariantSets : System.IDisposable
    {
        protected bool swigCMemOwn;
        public pxr.UsdVariantSet AddVariantSet(string variantSetName);
        public pxr.UsdVariantSet AddVariantSet(string variantSetName, pxr.UsdListPosition position);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_t GetAllVariantSelections();
        public pxr.StdStringVector GetNames();
        public bool GetNames(pxr.StdStringVector names);
        public string GetVariantSelection(string variantSetName);
        public pxr.UsdVariantSet GetVariantSet(string variantSetName);
        public bool HasVariantSet(string variantSetName);
        public bool SetSelection(string variantSetName, string variantName);
    }

    public class UsdVolField3DAsset : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdVolField3DAsset() {}
        public UsdVolField3DAsset(pxr.UsdPrim prim) {}
        public UsdVolField3DAsset(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateFieldIndexAttr();
        public pxr.UsdAttribute CreateFieldIndexAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFieldIndexAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFieldNameAttr();
        public pxr.UsdAttribute CreateFieldNameAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFieldNameAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public pxr.UsdAttribute CreateFieldPurposeAttr();
        public pxr.UsdAttribute CreateFieldPurposeAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFieldPurposeAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdVolField3DAsset Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdVolField3DAsset Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetFieldIndexAttr();
        public pxr.UsdAttribute GetFieldNameAttr();
        public pxr.UsdAttribute GetFieldPurposeAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdVolFieldAsset : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdVolFieldAsset() {}
        public UsdVolFieldAsset(pxr.UsdPrim prim) {}
        public UsdVolFieldAsset(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateFilePathAttr();
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFilePathAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdVolFieldAsset Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetFilePathAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdVolFieldBase : pxr.UsdGeomBoundable
    {
        public UsdVolFieldBase() {}
        public UsdVolFieldBase(pxr.UsdPrim prim) {}
        public UsdVolFieldBase(pxr.UsdSchemaBase schemaObj) {}
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdVolFieldBase Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdVolOpenVDBAsset : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdVolOpenVDBAsset() {}
        public UsdVolOpenVDBAsset(pxr.UsdPrim prim) {}
        public UsdVolOpenVDBAsset(pxr.UsdSchemaBase schemaObj) {}
        public pxr.UsdAttribute CreateFieldNameAttr();
        public pxr.UsdAttribute CreateFieldNameAttr(pxr.VtValue defaultValue);
        public pxr.UsdAttribute CreateFieldNameAttr(pxr.VtValue defaultValue, bool writeSparsely);
        public static pxr.UsdVolOpenVDBAsset Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdVolOpenVDBAsset Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.UsdAttribute GetFieldNameAttr();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
    }

    public class UsdVolVolume : pxr.UsdGeomGprim
    {
        public UsdVolVolume() {}
        public UsdVolVolume(pxr.UsdPrim prim) {}
        public UsdVolVolume(pxr.UsdSchemaBase schemaObj) {}
        public bool BlockFieldRelationship(pxr.TfToken name);
        public bool CreateFieldRelationship(pxr.TfToken name, pxr.SdfPath fieldPath);
        public static pxr.UsdVolVolume Define(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public virtual void Dispose();
        protected virtual void Finalize();
        public static pxr.UsdVolVolume Get(pxr.UsdStageWeakPtr stage, pxr.SdfPath path);
        public pxr.SdfPath GetFieldPath(pxr.TfToken name);
        public pxr.SWIGTYPE_p_std__mapT_TfToken_SdfPath_std__lessT_TfToken_t_t GetFieldPaths();
        public static pxr.TfTokenVector GetSchemaAttributeNames();
        public static pxr.TfTokenVector GetSchemaAttributeNames(bool includeInherited);
        public bool HasFieldRelationship(pxr.TfToken name);
    }

    public class UsdZipFile : System.IDisposable
    {
        protected bool swigCMemOwn;
        public UsdZipFile() {}
        public pxr.SWIGTYPE_p_UsdZipFile__Iterator begin();
        public pxr.SWIGTYPE_p_UsdZipFile__Iterator cbegin();
        public pxr.SWIGTYPE_p_UsdZipFile__Iterator cend();
        public virtual void Dispose();
        public void DumpContents();
        public pxr.SWIGTYPE_p_UsdZipFile__Iterator end();
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_UsdZipFile__Iterator Find(string path);
        public static pxr.UsdZipFile Open(pxr.SWIGTYPE_p_std__shared_ptrT_ArAsset_t asset);
        public static pxr.UsdZipFile Open(string filePath);
        public class FileInfo : System.IDisposable
        {
            protected bool swigCMemOwn;
            public System.UInt16 compressionMethod { get; set; }
            public System.UInt32 dataOffset { get; set; }
            public bool encrypted { get; set; }
            public System.UInt32 size { get; set; }
            public System.UInt32 uncompressedSize { get; set; }
            public FileInfo() {}
            public virtual void Dispose();
            protected virtual void Finalize();
        }
    }

    public class Vt_ArrayBase : System.IDisposable
    {
        protected bool swigCMemOwn;
        public Vt_ArrayBase() {}
        public Vt_ArrayBase(pxr.Vt_ArrayBase other) {}
        public Vt_ArrayBase(pxr.Vt_ArrayForeignDataSource foreignSrc) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    public class Vt_ArrayForeignDataSource : System.IDisposable
    {
        protected bool swigCMemOwn;
        public Vt_ArrayForeignDataSource() {}
        public Vt_ArrayForeignDataSource(pxr.SWIGTYPE_p_f_p_Vt_ArrayForeignDataSource__void detachedFn) {}
        public Vt_ArrayForeignDataSource(pxr.SWIGTYPE_p_f_p_Vt_ArrayForeignDataSource__void detachedFn, System.UInt32 initRefCount) {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtBoolArray : pxr.Vt_ArrayBase
    {
        public bool this[int index] { get; set; }
        public VtBoolArray() {}
        public VtBoolArray(pxr.VtBoolArray other) {}
        public VtBoolArray(System.UInt32 n) {}
        public VtBoolArray(System.UInt32 n, bool value) {}
        public void assign(System.UInt32 n, bool fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(bool[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(bool[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtBoolArray lhs, pxr.VtBoolArray rhs);
        protected virtual void Finalize();
        protected bool GetValue(int index);
        public bool IsIdentical(pxr.VtBoolArray other);
        public void pop_back();
        public void push_back(bool elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, bool value);
        public System.UInt32 size();
        public void swap(pxr.VtBoolArray other);
        public virtual string ToString();
    }

    public class VtDictionary : System.IDisposable
    {
        protected bool swigCMemOwn;
        public VtDictionary() {}
        public VtDictionary(pxr.VtDictionary other) {}
        public VtDictionary(int size) {}
        public pxr.SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t begin();
        public void clear();
        public pxr.SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__size_type count(string key);
        public virtual void Dispose();
        public bool empty();
        public pxr.SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t end();
        public pxr.SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__size_type erase(string key);
        public void erase(pxr.SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t it);
        public void erase(pxr.SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t f, pxr.SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t l);
        public void EraseValueAtPath(pxr.StdStringVector keyPath);
        public void EraseValueAtPath(string keyPath);
        public void EraseValueAtPath(string keyPath, string delimiters);
        protected virtual void Finalize();
        public pxr.SWIGTYPE_p_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t find(string key);
        public pxr.VtValue GetValueAtPath(pxr.StdStringVector keyPath);
        public pxr.VtValue GetValueAtPath(string keyPath);
        public pxr.VtValue GetValueAtPath(string keyPath, string delimiters);
        public pxr.SWIGTYPE_p_std__pairT_VtDictionary__IteratorT_std__mapT_std__string_VtValue_std__lessT_t_t_p_std__mapT_std__string_VtValue_std__lessT_t_t__iterator_t_bool_t insert(pxr.SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__value_type obj);
        public void SetValueAtPath(pxr.StdStringVector keyPath, pxr.VtValue value);
        public void SetValueAtPath(string keyPath, pxr.VtValue value);
        public void SetValueAtPath(string keyPath, pxr.VtValue value, string delimiters);
        public pxr.SWIGTYPE_p_std__mapT_std__string_VtValue_std__lessT_t_t__size_type size();
        public void swap(pxr.VtDictionary dict);
    }

    public class VtDictionaryHash : System.IDisposable
    {
        protected bool swigCMemOwn;
        public VtDictionaryHash() {}
        public virtual void Dispose();
        protected virtual void Finalize();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtDoubleArray : pxr.Vt_ArrayBase
    {
        public double this[int index] { get; set; }
        public VtDoubleArray() {}
        public VtDoubleArray(pxr.VtDoubleArray other) {}
        public VtDoubleArray(System.UInt32 n) {}
        public VtDoubleArray(System.UInt32 n, double value) {}
        public void assign(System.UInt32 n, double fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(double[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(double[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtDoubleArray lhs, pxr.VtDoubleArray rhs);
        protected virtual void Finalize();
        protected double GetValue(int index);
        public bool IsIdentical(pxr.VtDoubleArray other);
        public void pop_back();
        public void push_back(double elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, double value);
        public System.UInt32 size();
        public void swap(pxr.VtDoubleArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtFloatArray : pxr.Vt_ArrayBase
    {
        public float this[int index] { get; set; }
        public VtFloatArray() {}
        public VtFloatArray(pxr.VtFloatArray other) {}
        public VtFloatArray(System.UInt32 n) {}
        public VtFloatArray(System.UInt32 n, float value) {}
        public void assign(System.UInt32 n, float fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(System.IntPtr src);
        public void CopyFromArray(float[] src);
        public void CopyToArray(System.IntPtr dest);
        public void CopyToArray(float[] dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtFloatArray lhs, pxr.VtFloatArray rhs);
        protected virtual void Finalize();
        protected float GetValue(int index);
        public bool IsIdentical(pxr.VtFloatArray other);
        public void pop_back();
        public void push_back(float elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, float value);
        public System.UInt32 size();
        public void swap(pxr.VtFloatArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtHalfArray : pxr.Vt_ArrayBase
    {
        public pxr.GfHalf this[int index] { get; set; }
        public VtHalfArray() {}
        public VtHalfArray(pxr.VtHalfArray other) {}
        public VtHalfArray(System.UInt32 n) {}
        public VtHalfArray(System.UInt32 n, pxr.GfHalf value) {}
        public void assign(System.UInt32 n, pxr.GfHalf fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfHalf[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfHalf[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtHalfArray lhs, pxr.VtHalfArray rhs);
        protected virtual void Finalize();
        protected pxr.GfHalf GetValue(int index);
        public bool IsIdentical(pxr.VtHalfArray other);
        public void pop_back();
        public void push_back(pxr.GfHalf elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfHalf value);
        public System.UInt32 size();
        public void swap(pxr.VtHalfArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtInt64Array : pxr.Vt_ArrayBase
    {
        public long this[int index] { get; set; }
        public VtInt64Array() {}
        public VtInt64Array(pxr.VtInt64Array other) {}
        public VtInt64Array(System.UInt32 n) {}
        public VtInt64Array(System.UInt32 n, long value) {}
        public void assign(System.UInt32 n, long fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(long[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(long[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtInt64Array lhs, pxr.VtInt64Array rhs);
        protected virtual void Finalize();
        protected long GetValue(int index);
        public bool IsIdentical(pxr.VtInt64Array other);
        public void pop_back();
        public void push_back(long elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, long value);
        public System.UInt32 size();
        public void swap(pxr.VtInt64Array other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtIntArray : pxr.Vt_ArrayBase
    {
        public int this[int index] { get; set; }
        public VtIntArray() {}
        public VtIntArray(pxr.VtIntArray other) {}
        public VtIntArray(System.UInt32 n) {}
        public VtIntArray(System.UInt32 n, int value) {}
        public void assign(System.UInt32 n, int fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(int[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(int[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtIntArray lhs, pxr.VtIntArray rhs);
        protected virtual void Finalize();
        protected int GetValue(int index);
        public bool IsIdentical(pxr.VtIntArray other);
        public void pop_back();
        public void push_back(int elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, int value);
        public System.UInt32 size();
        public void swap(pxr.VtIntArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtMatrix2dArray : pxr.Vt_ArrayBase
    {
        public pxr.GfMatrix2d this[int index] { get; set; }
        public VtMatrix2dArray() {}
        public VtMatrix2dArray(pxr.VtMatrix2dArray other) {}
        public VtMatrix2dArray(System.UInt32 n) {}
        public VtMatrix2dArray(System.UInt32 n, pxr.GfMatrix2d value) {}
        public void assign(System.UInt32 n, pxr.GfMatrix2d fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfMatrix2d[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfMatrix2d[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtMatrix2dArray lhs, pxr.VtMatrix2dArray rhs);
        protected virtual void Finalize();
        protected pxr.GfMatrix2d GetValue(int index);
        public bool IsIdentical(pxr.VtMatrix2dArray other);
        public void pop_back();
        public void push_back(pxr.GfMatrix2d elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfMatrix2d value);
        public System.UInt32 size();
        public void swap(pxr.VtMatrix2dArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtMatrix3dArray : pxr.Vt_ArrayBase
    {
        public pxr.GfMatrix3d this[int index] { get; set; }
        public VtMatrix3dArray() {}
        public VtMatrix3dArray(pxr.VtMatrix3dArray other) {}
        public VtMatrix3dArray(System.UInt32 n) {}
        public VtMatrix3dArray(System.UInt32 n, pxr.GfMatrix3d value) {}
        public void assign(System.UInt32 n, pxr.GfMatrix3d fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfMatrix3d[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfMatrix3d[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtMatrix3dArray lhs, pxr.VtMatrix3dArray rhs);
        protected virtual void Finalize();
        protected pxr.GfMatrix3d GetValue(int index);
        public bool IsIdentical(pxr.VtMatrix3dArray other);
        public void pop_back();
        public void push_back(pxr.GfMatrix3d elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfMatrix3d value);
        public System.UInt32 size();
        public void swap(pxr.VtMatrix3dArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtMatrix4dArray : pxr.Vt_ArrayBase
    {
        public pxr.GfMatrix4d this[int index] { get; set; }
        public VtMatrix4dArray() {}
        public VtMatrix4dArray(pxr.VtMatrix4dArray other) {}
        public VtMatrix4dArray(System.UInt32 n) {}
        public VtMatrix4dArray(System.UInt32 n, pxr.GfMatrix4d value) {}
        public void assign(System.UInt32 n, pxr.GfMatrix4d fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfMatrix4d[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfMatrix4d[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtMatrix4dArray lhs, pxr.VtMatrix4dArray rhs);
        protected virtual void Finalize();
        protected pxr.GfMatrix4d GetValue(int index);
        public bool IsIdentical(pxr.VtMatrix4dArray other);
        public void pop_back();
        public void push_back(pxr.GfMatrix4d elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfMatrix4d value);
        public System.UInt32 size();
        public void swap(pxr.VtMatrix4dArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtMatrix4dArrayVector : System.Collections.Generic.IEnumerable<pxr.VtMatrix4dArray>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.VtMatrix4dArray this[int index] { get; set; }
        public VtMatrix4dArrayVector() {}
        public VtMatrix4dArrayVector(pxr.VtMatrix4dArrayVector other) {}
        public VtMatrix4dArrayVector(System.Collections.ICollection c) {}
        public VtMatrix4dArrayVector(int capacity) {}
        public void Add(pxr.VtMatrix4dArray x);
        public void AddRange(pxr.VtMatrix4dArrayVector values);
        public void Clear();
        public void CopyTo(pxr.VtMatrix4dArray[] array);
        public void CopyTo(pxr.VtMatrix4dArray[] array, int arrayIndex);
        public void CopyTo(int index, pxr.VtMatrix4dArray[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtMatrix4dArrayVector.VtMatrix4dArrayVectorEnumerator GetEnumerator();
        public pxr.VtMatrix4dArrayVector GetRange(int index, int count);
        public void Insert(int index, pxr.VtMatrix4dArray x);
        public void InsertRange(int index, pxr.VtMatrix4dArrayVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.VtMatrix4dArrayVector Repeat(pxr.VtMatrix4dArray value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.VtMatrix4dArrayVector values);
        public sealed class VtMatrix4dArrayVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.VtMatrix4dArray>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.VtMatrix4dArray Current { get; }
            public VtMatrix4dArrayVectorEnumerator(pxr.VtMatrix4dArrayVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtQuatdArray : pxr.Vt_ArrayBase
    {
        public pxr.GfQuatd this[int index] { get; set; }
        public VtQuatdArray() {}
        public VtQuatdArray(pxr.VtQuatdArray other) {}
        public VtQuatdArray(System.UInt32 n) {}
        public VtQuatdArray(System.UInt32 n, pxr.GfQuatd value) {}
        public void assign(System.UInt32 n, pxr.GfQuatd fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfQuatd[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfQuatd[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtQuatdArray lhs, pxr.VtQuatdArray rhs);
        protected virtual void Finalize();
        protected pxr.GfQuatd GetValue(int index);
        public bool IsIdentical(pxr.VtQuatdArray other);
        public void pop_back();
        public void push_back(pxr.GfQuatd elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfQuatd value);
        public System.UInt32 size();
        public void swap(pxr.VtQuatdArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtQuatfArray : pxr.Vt_ArrayBase
    {
        public pxr.GfQuatf this[int index] { get; set; }
        public VtQuatfArray() {}
        public VtQuatfArray(pxr.VtQuatfArray other) {}
        public VtQuatfArray(System.UInt32 n) {}
        public VtQuatfArray(System.UInt32 n, pxr.GfQuatf value) {}
        public void assign(System.UInt32 n, pxr.GfQuatf fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfQuatf[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfQuatf[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtQuatfArray lhs, pxr.VtQuatfArray rhs);
        protected virtual void Finalize();
        protected pxr.GfQuatf GetValue(int index);
        public bool IsIdentical(pxr.VtQuatfArray other);
        public void pop_back();
        public void push_back(pxr.GfQuatf elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfQuatf value);
        public System.UInt32 size();
        public void swap(pxr.VtQuatfArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtQuathArray : pxr.Vt_ArrayBase
    {
        public pxr.GfQuath this[int index] { get; set; }
        public VtQuathArray() {}
        public VtQuathArray(pxr.VtQuathArray other) {}
        public VtQuathArray(System.UInt32 n) {}
        public VtQuathArray(System.UInt32 n, pxr.GfQuath value) {}
        public void assign(System.UInt32 n, pxr.GfQuath fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfQuath[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfQuath[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtQuathArray lhs, pxr.VtQuathArray rhs);
        protected virtual void Finalize();
        protected pxr.GfQuath GetValue(int index);
        public bool IsIdentical(pxr.VtQuathArray other);
        public void pop_back();
        public void push_back(pxr.GfQuath elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfQuath value);
        public System.UInt32 size();
        public void swap(pxr.VtQuathArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtStringArray : pxr.Vt_ArrayBase
    {
        public string this[int index] { get; set; }
        public VtStringArray() {}
        public VtStringArray(pxr.VtStringArray other) {}
        public VtStringArray(System.UInt32 n) {}
        public VtStringArray(System.UInt32 n, string value) {}
        public void assign(System.UInt32 n, string fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(System.IntPtr src);
        public void CopyFromArray(string[] src);
        public void CopyToArray(System.IntPtr dest);
        public void CopyToArray(string[] dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtStringArray lhs, pxr.VtStringArray rhs);
        protected virtual void Finalize();
        protected string GetValue(int index);
        public bool IsIdentical(pxr.VtStringArray other);
        public void pop_back();
        public void push_back(string elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, string value);
        public System.UInt32 size();
        public void swap(pxr.VtStringArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtTokenArray : pxr.Vt_ArrayBase
    {
        public pxr.TfToken this[int index] { get; set; }
        public VtTokenArray() {}
        public VtTokenArray(pxr.VtTokenArray other) {}
        public VtTokenArray(System.UInt32 n) {}
        public VtTokenArray(System.UInt32 n, pxr.TfToken value) {}
        public void assign(System.UInt32 n, pxr.TfToken fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.TfToken[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.TfToken[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtTokenArray lhs, pxr.VtTokenArray rhs);
        protected virtual void Finalize();
        protected pxr.TfToken GetValue(int index);
        public bool IsIdentical(pxr.VtTokenArray other);
        public void pop_back();
        public void push_back(pxr.TfToken elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.TfToken value);
        public System.UInt32 size();
        public void swap(pxr.VtTokenArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtUCharArray : pxr.Vt_ArrayBase
    {
        public byte this[int index] { get; set; }
        public VtUCharArray() {}
        public VtUCharArray(pxr.VtUCharArray other) {}
        public VtUCharArray(System.UInt32 n) {}
        public VtUCharArray(System.UInt32 n, byte value) {}
        public void assign(System.UInt32 n, byte fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(byte[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(byte[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtUCharArray lhs, pxr.VtUCharArray rhs);
        protected virtual void Finalize();
        protected byte GetValue(int index);
        public bool IsIdentical(pxr.VtUCharArray other);
        public void pop_back();
        public void push_back(byte elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, byte value);
        public System.UInt32 size();
        public void swap(pxr.VtUCharArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtUInt64Array : pxr.Vt_ArrayBase
    {
        public System.UInt64 this[int index] { get; set; }
        public VtUInt64Array() {}
        public VtUInt64Array(pxr.VtUInt64Array other) {}
        public VtUInt64Array(System.UInt32 n) {}
        public VtUInt64Array(System.UInt32 n, System.UInt64 value) {}
        public void assign(System.UInt32 n, System.UInt64 fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(System.IntPtr src);
        public void CopyFromArray(System.UInt64[] src);
        public void CopyToArray(System.IntPtr dest);
        public void CopyToArray(System.UInt64[] dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtUInt64Array lhs, pxr.VtUInt64Array rhs);
        protected virtual void Finalize();
        protected System.UInt64 GetValue(int index);
        public bool IsIdentical(pxr.VtUInt64Array other);
        public void pop_back();
        public void push_back(System.UInt64 elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, System.UInt64 value);
        public System.UInt32 size();
        public void swap(pxr.VtUInt64Array other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtUIntArray : pxr.Vt_ArrayBase
    {
        public System.UInt32 this[int index] { get; set; }
        public VtUIntArray() {}
        public VtUIntArray(pxr.VtUIntArray other) {}
        public VtUIntArray(System.UInt32 n) {}
        public VtUIntArray(System.UInt32 n, System.UInt32 value) {}
        public void assign(System.UInt32 n, System.UInt32 fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(System.IntPtr src);
        public void CopyFromArray(System.UInt32[] src);
        public void CopyToArray(System.IntPtr dest);
        public void CopyToArray(System.UInt32[] dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtUIntArray lhs, pxr.VtUIntArray rhs);
        protected virtual void Finalize();
        protected System.UInt32 GetValue(int index);
        public bool IsIdentical(pxr.VtUIntArray other);
        public void pop_back();
        public void push_back(System.UInt32 elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, System.UInt32 value);
        public System.UInt32 size();
        public void swap(pxr.VtUIntArray other);
        public virtual string ToString();
    }

    public class VtValue : System.IDisposable
    {
        protected bool swigCMemOwn;
        public VtValue() {}
        public VtValue(pxr.GfHalf obj) {}
        public VtValue(pxr.GfMatrix2d obj) {}
        public VtValue(pxr.GfMatrix3d obj) {}
        public VtValue(pxr.GfMatrix4d obj) {}
        public VtValue(pxr.GfQuatd obj) {}
        public VtValue(pxr.GfQuatf obj) {}
        public VtValue(pxr.GfQuath obj) {}
        public VtValue(pxr.GfVec2d obj) {}
        public VtValue(pxr.GfVec2f obj) {}
        public VtValue(pxr.GfVec2h obj) {}
        public VtValue(pxr.GfVec2i obj) {}
        public VtValue(pxr.GfVec3d obj) {}
        public VtValue(pxr.GfVec3f obj) {}
        public VtValue(pxr.GfVec3h obj) {}
        public VtValue(pxr.GfVec3i obj) {}
        public VtValue(pxr.GfVec4d obj) {}
        public VtValue(pxr.GfVec4f obj) {}
        public VtValue(pxr.GfVec4h obj) {}
        public VtValue(pxr.GfVec4i obj) {}
        public VtValue(pxr.SdfAssetPath obj) {}
        public VtValue(pxr.SdfAssetPathArray obj) {}
        public VtValue(pxr.SdfTimeCode obj) {}
        public VtValue(pxr.SdfTimeCodeArray obj) {}
        public VtValue(pxr.TfToken obj) {}
        public VtValue(pxr.VtBoolArray obj) {}
        public VtValue(pxr.VtDoubleArray obj) {}
        public VtValue(pxr.VtFloatArray obj) {}
        public VtValue(pxr.VtHalfArray obj) {}
        public VtValue(pxr.VtInt64Array obj) {}
        public VtValue(pxr.VtIntArray obj) {}
        public VtValue(pxr.VtMatrix2dArray obj) {}
        public VtValue(pxr.VtMatrix3dArray obj) {}
        public VtValue(pxr.VtMatrix4dArray obj) {}
        public VtValue(pxr.VtQuatdArray obj) {}
        public VtValue(pxr.VtQuatfArray obj) {}
        public VtValue(pxr.VtQuathArray obj) {}
        public VtValue(pxr.VtStringArray obj) {}
        public VtValue(pxr.VtTokenArray obj) {}
        public VtValue(pxr.VtUCharArray obj) {}
        public VtValue(pxr.VtUInt64Array obj) {}
        public VtValue(pxr.VtUIntArray obj) {}
        public VtValue(pxr.VtValue other) {}
        public VtValue(pxr.VtVec2dArray obj) {}
        public VtValue(pxr.VtVec2fArray obj) {}
        public VtValue(pxr.VtVec2hArray obj) {}
        public VtValue(pxr.VtVec2iArray obj) {}
        public VtValue(pxr.VtVec3dArray obj) {}
        public VtValue(pxr.VtVec3fArray obj) {}
        public VtValue(pxr.VtVec3hArray obj) {}
        public VtValue(pxr.VtVec3iArray obj) {}
        public VtValue(pxr.VtVec4dArray obj) {}
        public VtValue(pxr.VtVec4fArray obj) {}
        public VtValue(pxr.VtVec4hArray obj) {}
        public VtValue(pxr.VtVec4iArray obj) {}
        public VtValue(bool obj) {}
        public VtValue(byte obj) {}
        public VtValue(double obj) {}
        public VtValue(int obj) {}
        public VtValue(long obj) {}
        public VtValue(float obj) {}
        public VtValue(string obj) {}
        public VtValue(System.UInt32 obj) {}
        public VtValue(System.UInt64 obj) {}
        public static bool CanCastFromTypeidToTypeid(pxr.SWIGTYPE_p_std__type_info from, pxr.SWIGTYPE_p_std__type_info to);
        public bool CanCastToTypeid(pxr.SWIGTYPE_p_std__type_info type);
        public bool CanCastToTypeOf(pxr.VtValue other);
        public bool CanHash();
        public static pxr.VtValue CastToTypeid(pxr.VtValue val, pxr.SWIGTYPE_p_std__type_info type);
        public static pxr.VtValue CastToTypeOf(pxr.VtValue val, pxr.VtValue other);
        public virtual void Dispose();
        public virtual bool Equals(object rhs);
        public static bool Equals(pxr.VtValue lhs, pxr.VtValue rhs);
        protected virtual void Finalize();
        public System.UInt32 GetArraySize();
        public pxr.SWIGTYPE_p_std__type_info GetElementTypeid();
        public System.UInt32 GetHash();
        public virtual int GetHashCode();
        public pxr.TfType GetTfType();
        public pxr.SWIGTYPE_p_std__type_info GetTypeid();
        public string GetTypeName();
        public bool IsArrayValued();
        public bool IsEmpty();
        public static bool operator ==(pxr.VtValue lhs, pxr.VtValue rhs);
        public static pxr.GfHalf op_Implicit(pxr.VtValue value);
        public static pxr.GfMatrix2d op_Implicit(pxr.VtValue value);
        public static pxr.GfMatrix3d op_Implicit(pxr.VtValue value);
        public static pxr.GfMatrix4d op_Implicit(pxr.VtValue value);
        public static pxr.GfQuatd op_Implicit(pxr.VtValue value);
        public static pxr.GfQuatf op_Implicit(pxr.VtValue value);
        public static pxr.GfQuath op_Implicit(pxr.VtValue value);
        public static pxr.GfVec2d op_Implicit(pxr.VtValue value);
        public static pxr.GfVec2f op_Implicit(pxr.VtValue value);
        public static pxr.GfVec2h op_Implicit(pxr.VtValue value);
        public static pxr.GfVec2i op_Implicit(pxr.VtValue value);
        public static pxr.GfVec3d op_Implicit(pxr.VtValue value);
        public static pxr.GfVec3f op_Implicit(pxr.VtValue value);
        public static pxr.GfVec3h op_Implicit(pxr.VtValue value);
        public static pxr.GfVec3i op_Implicit(pxr.VtValue value);
        public static pxr.GfVec4d op_Implicit(pxr.VtValue value);
        public static pxr.GfVec4f op_Implicit(pxr.VtValue value);
        public static pxr.GfVec4h op_Implicit(pxr.VtValue value);
        public static pxr.GfVec4i op_Implicit(pxr.VtValue value);
        public static pxr.SdfAssetPath op_Implicit(pxr.VtValue value);
        public static pxr.SdfAssetPathArray op_Implicit(pxr.VtValue value);
        public static pxr.SdfTimeCode op_Implicit(pxr.VtValue value);
        public static pxr.SdfTimeCodeArray op_Implicit(pxr.VtValue value);
        public static pxr.TfToken op_Implicit(pxr.VtValue value);
        public static pxr.VtBoolArray op_Implicit(pxr.VtValue value);
        public static pxr.VtDoubleArray op_Implicit(pxr.VtValue value);
        public static pxr.VtFloatArray op_Implicit(pxr.VtValue value);
        public static pxr.VtHalfArray op_Implicit(pxr.VtValue value);
        public static pxr.VtInt64Array op_Implicit(pxr.VtValue value);
        public static pxr.VtIntArray op_Implicit(pxr.VtValue value);
        public static pxr.VtMatrix2dArray op_Implicit(pxr.VtValue value);
        public static pxr.VtMatrix3dArray op_Implicit(pxr.VtValue value);
        public static pxr.VtMatrix4dArray op_Implicit(pxr.VtValue value);
        public static pxr.VtQuatdArray op_Implicit(pxr.VtValue value);
        public static pxr.VtQuatfArray op_Implicit(pxr.VtValue value);
        public static pxr.VtQuathArray op_Implicit(pxr.VtValue value);
        public static pxr.VtStringArray op_Implicit(pxr.VtValue value);
        public static pxr.VtTokenArray op_Implicit(pxr.VtValue value);
        public static pxr.VtUCharArray op_Implicit(pxr.VtValue value);
        public static pxr.VtUInt64Array op_Implicit(pxr.VtValue value);
        public static pxr.VtUIntArray op_Implicit(pxr.VtValue value);
        public static pxr.VtValue op_Implicit(pxr.GfHalf value);
        public static pxr.VtValue op_Implicit(pxr.GfMatrix2d value);
        public static pxr.VtValue op_Implicit(pxr.GfMatrix3d value);
        public static pxr.VtValue op_Implicit(pxr.GfMatrix4d value);
        public static pxr.VtValue op_Implicit(pxr.GfQuatd value);
        public static pxr.VtValue op_Implicit(pxr.GfQuatf value);
        public static pxr.VtValue op_Implicit(pxr.GfQuath value);
        public static pxr.VtValue op_Implicit(pxr.GfVec2d value);
        public static pxr.VtValue op_Implicit(pxr.GfVec2f value);
        public static pxr.VtValue op_Implicit(pxr.GfVec2h value);
        public static pxr.VtValue op_Implicit(pxr.GfVec2i value);
        public static pxr.VtValue op_Implicit(pxr.GfVec3d value);
        public static pxr.VtValue op_Implicit(pxr.GfVec3f value);
        public static pxr.VtValue op_Implicit(pxr.GfVec3h value);
        public static pxr.VtValue op_Implicit(pxr.GfVec3i value);
        public static pxr.VtValue op_Implicit(pxr.GfVec4d value);
        public static pxr.VtValue op_Implicit(pxr.GfVec4f value);
        public static pxr.VtValue op_Implicit(pxr.GfVec4h value);
        public static pxr.VtValue op_Implicit(pxr.GfVec4i value);
        public static pxr.VtValue op_Implicit(pxr.SdfAssetPath value);
        public static pxr.VtValue op_Implicit(pxr.SdfAssetPathArray value);
        public static pxr.VtValue op_Implicit(pxr.SdfTimeCode value);
        public static pxr.VtValue op_Implicit(pxr.SdfTimeCodeArray value);
        public static pxr.VtValue op_Implicit(pxr.TfToken value);
        public static pxr.VtValue op_Implicit(pxr.VtBoolArray value);
        public static pxr.VtValue op_Implicit(pxr.VtDoubleArray value);
        public static pxr.VtValue op_Implicit(pxr.VtFloatArray value);
        public static pxr.VtValue op_Implicit(pxr.VtHalfArray value);
        public static pxr.VtValue op_Implicit(pxr.VtInt64Array value);
        public static pxr.VtValue op_Implicit(pxr.VtIntArray value);
        public static pxr.VtValue op_Implicit(pxr.VtMatrix2dArray value);
        public static pxr.VtValue op_Implicit(pxr.VtMatrix3dArray value);
        public static pxr.VtValue op_Implicit(pxr.VtMatrix4dArray value);
        public static pxr.VtValue op_Implicit(pxr.VtQuatdArray value);
        public static pxr.VtValue op_Implicit(pxr.VtQuatfArray value);
        public static pxr.VtValue op_Implicit(pxr.VtQuathArray value);
        public static pxr.VtValue op_Implicit(pxr.VtStringArray value);
        public static pxr.VtValue op_Implicit(pxr.VtTokenArray value);
        public static pxr.VtValue op_Implicit(pxr.VtUCharArray value);
        public static pxr.VtValue op_Implicit(pxr.VtUInt64Array value);
        public static pxr.VtValue op_Implicit(pxr.VtUIntArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec2dArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec2fArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec2hArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec2iArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec3dArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec3fArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec3hArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec3iArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec4dArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec4fArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec4hArray value);
        public static pxr.VtValue op_Implicit(pxr.VtVec4iArray value);
        public static pxr.VtValue op_Implicit(bool value);
        public static pxr.VtValue op_Implicit(byte value);
        public static pxr.VtValue op_Implicit(double value);
        public static pxr.VtValue op_Implicit(int value);
        public static pxr.VtValue op_Implicit(long value);
        public static pxr.VtValue op_Implicit(float value);
        public static pxr.VtValue op_Implicit(string value);
        public static pxr.VtValue op_Implicit(System.UInt32 value);
        public static pxr.VtValue op_Implicit(System.UInt64 value);
        public static pxr.VtVec2dArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec2fArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec2hArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec2iArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec3dArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec3fArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec3hArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec3iArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec4dArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec4fArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec4hArray op_Implicit(pxr.VtValue value);
        public static pxr.VtVec4iArray op_Implicit(pxr.VtValue value);
        public static bool op_Implicit(pxr.VtValue value);
        public static byte op_Implicit(pxr.VtValue value);
        public static double op_Implicit(pxr.VtValue value);
        public static int op_Implicit(pxr.VtValue value);
        public static long op_Implicit(pxr.VtValue value);
        public static float op_Implicit(pxr.VtValue value);
        public static string op_Implicit(pxr.VtValue value);
        public static System.UInt32 op_Implicit(pxr.VtValue value);
        public static System.UInt64 op_Implicit(pxr.VtValue value);
        public static bool operator !=(pxr.VtValue lhs, pxr.VtValue rhs);
        public pxr.VtValue Swap(pxr.VtValue rhs);
        public void UncheckedSwap(pxr.VtValue rhs);
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec2dArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec2d this[int index] { get; set; }
        public VtVec2dArray() {}
        public VtVec2dArray(pxr.VtVec2dArray other) {}
        public VtVec2dArray(System.UInt32 n) {}
        public VtVec2dArray(System.UInt32 n, pxr.GfVec2d value) {}
        public void assign(System.UInt32 n, pxr.GfVec2d fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec2d[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec2d[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec2dArray lhs, pxr.VtVec2dArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec2d GetValue(int index);
        public bool IsIdentical(pxr.VtVec2dArray other);
        public void pop_back();
        public void push_back(pxr.GfVec2d elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec2d value);
        public System.UInt32 size();
        public void swap(pxr.VtVec2dArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec2fArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec2f this[int index] { get; set; }
        public VtVec2fArray() {}
        public VtVec2fArray(pxr.VtVec2fArray other) {}
        public VtVec2fArray(System.UInt32 n) {}
        public VtVec2fArray(System.UInt32 n, pxr.GfVec2f value) {}
        public void assign(System.UInt32 n, pxr.GfVec2f fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec2f[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec2f[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec2fArray lhs, pxr.VtVec2fArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec2f GetValue(int index);
        public bool IsIdentical(pxr.VtVec2fArray other);
        public void pop_back();
        public void push_back(pxr.GfVec2f elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec2f value);
        public System.UInt32 size();
        public void swap(pxr.VtVec2fArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec2hArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec2h this[int index] { get; set; }
        public VtVec2hArray() {}
        public VtVec2hArray(pxr.VtVec2hArray other) {}
        public VtVec2hArray(System.UInt32 n) {}
        public VtVec2hArray(System.UInt32 n, pxr.GfVec2h value) {}
        public void assign(System.UInt32 n, pxr.GfVec2h fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec2h[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec2h[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec2hArray lhs, pxr.VtVec2hArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec2h GetValue(int index);
        public bool IsIdentical(pxr.VtVec2hArray other);
        public void pop_back();
        public void push_back(pxr.GfVec2h elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec2h value);
        public System.UInt32 size();
        public void swap(pxr.VtVec2hArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec2iArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec2i this[int index] { get; set; }
        public VtVec2iArray() {}
        public VtVec2iArray(pxr.VtVec2iArray other) {}
        public VtVec2iArray(System.UInt32 n) {}
        public VtVec2iArray(System.UInt32 n, pxr.GfVec2i value) {}
        public void assign(System.UInt32 n, pxr.GfVec2i fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec2i[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec2i[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec2iArray lhs, pxr.VtVec2iArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec2i GetValue(int index);
        public bool IsIdentical(pxr.VtVec2iArray other);
        public void pop_back();
        public void push_back(pxr.GfVec2i elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec2i value);
        public System.UInt32 size();
        public void swap(pxr.VtVec2iArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec3dArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec3d this[int index] { get; set; }
        public VtVec3dArray() {}
        public VtVec3dArray(pxr.VtVec3dArray other) {}
        public VtVec3dArray(System.UInt32 n) {}
        public VtVec3dArray(System.UInt32 n, pxr.GfVec3d value) {}
        public void assign(System.UInt32 n, pxr.GfVec3d fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec3d[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec3d[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec3dArray lhs, pxr.VtVec3dArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec3d GetValue(int index);
        public bool IsIdentical(pxr.VtVec3dArray other);
        public void pop_back();
        public void push_back(pxr.GfVec3d elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec3d value);
        public System.UInt32 size();
        public void swap(pxr.VtVec3dArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec3fArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec3f this[int index] { get; set; }
        public VtVec3fArray() {}
        public VtVec3fArray(pxr.VtVec3fArray other) {}
        public VtVec3fArray(System.UInt32 n) {}
        public VtVec3fArray(System.UInt32 n, pxr.GfVec3f value) {}
        public void assign(System.UInt32 n, pxr.GfVec3f fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec3f[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec3f[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec3fArray lhs, pxr.VtVec3fArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec3f GetValue(int index);
        public bool IsIdentical(pxr.VtVec3fArray other);
        public void pop_back();
        public void push_back(pxr.GfVec3f elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec3f value);
        public System.UInt32 size();
        public void swap(pxr.VtVec3fArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec3fArrayVector : System.Collections.Generic.IEnumerable<pxr.VtVec3fArray>, System.Collections.IEnumerable, System.IDisposable
    {
        protected bool swigCMemOwn;
        public int Capacity { get; set; }
        public int Count { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public pxr.VtVec3fArray this[int index] { get; set; }
        public VtVec3fArrayVector() {}
        public VtVec3fArrayVector(pxr.VtVec3fArrayVector other) {}
        public VtVec3fArrayVector(System.Collections.ICollection c) {}
        public VtVec3fArrayVector(int capacity) {}
        public void Add(pxr.VtVec3fArray x);
        public void AddRange(pxr.VtVec3fArrayVector values);
        public void Clear();
        public void CopyTo(pxr.VtVec3fArray[] array);
        public void CopyTo(pxr.VtVec3fArray[] array, int arrayIndex);
        public void CopyTo(int index, pxr.VtVec3fArray[] array, int arrayIndex, int count);
        public virtual void Dispose();
        protected virtual void Finalize();
        public pxr.VtVec3fArrayVector.VtVec3fArrayVectorEnumerator GetEnumerator();
        public pxr.VtVec3fArrayVector GetRange(int index, int count);
        public void Insert(int index, pxr.VtVec3fArray x);
        public void InsertRange(int index, pxr.VtVec3fArrayVector values);
        public void RemoveAt(int index);
        public void RemoveRange(int index, int count);
        public static pxr.VtVec3fArrayVector Repeat(pxr.VtVec3fArray value, int count);
        public void Reverse();
        public void Reverse(int index, int count);
        public void SetRange(int index, pxr.VtVec3fArrayVector values);
        public sealed class VtVec3fArrayVectorEnumerator : System.Collections.Generic.IEnumerator<pxr.VtVec3fArray>, System.Collections.IEnumerator, System.IDisposable
        {
            public virtual pxr.VtVec3fArray Current { get; }
            public VtVec3fArrayVectorEnumerator(pxr.VtVec3fArrayVector collection) {}
            public virtual void Dispose();
            public virtual bool MoveNext();
            public virtual void Reset();
        }
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec3hArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec3h this[int index] { get; set; }
        public VtVec3hArray() {}
        public VtVec3hArray(pxr.VtVec3hArray other) {}
        public VtVec3hArray(System.UInt32 n) {}
        public VtVec3hArray(System.UInt32 n, pxr.GfVec3h value) {}
        public void assign(System.UInt32 n, pxr.GfVec3h fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec3h[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec3h[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec3hArray lhs, pxr.VtVec3hArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec3h GetValue(int index);
        public bool IsIdentical(pxr.VtVec3hArray other);
        public void pop_back();
        public void push_back(pxr.GfVec3h elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec3h value);
        public System.UInt32 size();
        public void swap(pxr.VtVec3hArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec3iArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec3i this[int index] { get; set; }
        public VtVec3iArray() {}
        public VtVec3iArray(pxr.VtVec3iArray other) {}
        public VtVec3iArray(System.UInt32 n) {}
        public VtVec3iArray(System.UInt32 n, pxr.GfVec3i value) {}
        public void assign(System.UInt32 n, pxr.GfVec3i fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec3i[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec3i[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec3iArray lhs, pxr.VtVec3iArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec3i GetValue(int index);
        public bool IsIdentical(pxr.VtVec3iArray other);
        public void pop_back();
        public void push_back(pxr.GfVec3i elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec3i value);
        public System.UInt32 size();
        public void swap(pxr.VtVec3iArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec4dArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec4d this[int index] { get; set; }
        public VtVec4dArray() {}
        public VtVec4dArray(pxr.VtVec4dArray other) {}
        public VtVec4dArray(System.UInt32 n) {}
        public VtVec4dArray(System.UInt32 n, pxr.GfVec4d value) {}
        public void assign(System.UInt32 n, pxr.GfVec4d fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec4d[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec4d[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec4dArray lhs, pxr.VtVec4dArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec4d GetValue(int index);
        public bool IsIdentical(pxr.VtVec4dArray other);
        public void pop_back();
        public void push_back(pxr.GfVec4d elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec4d value);
        public System.UInt32 size();
        public void swap(pxr.VtVec4dArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec4fArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec4f this[int index] { get; set; }
        public VtVec4fArray() {}
        public VtVec4fArray(pxr.VtVec4fArray other) {}
        public VtVec4fArray(System.UInt32 n) {}
        public VtVec4fArray(System.UInt32 n, pxr.GfVec4f value) {}
        public void assign(System.UInt32 n, pxr.GfVec4f fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec4f[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec4f[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec4fArray lhs, pxr.VtVec4fArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec4f GetValue(int index);
        public bool IsIdentical(pxr.VtVec4fArray other);
        public void pop_back();
        public void push_back(pxr.GfVec4f elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec4f value);
        public System.UInt32 size();
        public void swap(pxr.VtVec4fArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec4hArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec4h this[int index] { get; set; }
        public VtVec4hArray() {}
        public VtVec4hArray(pxr.VtVec4hArray other) {}
        public VtVec4hArray(System.UInt32 n) {}
        public VtVec4hArray(System.UInt32 n, pxr.GfVec4h value) {}
        public void assign(System.UInt32 n, pxr.GfVec4h fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec4h[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec4h[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec4hArray lhs, pxr.VtVec4hArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec4h GetValue(int index);
        public bool IsIdentical(pxr.VtVec4hArray other);
        public void pop_back();
        public void push_back(pxr.GfVec4h elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec4h value);
        public System.UInt32 size();
        public void swap(pxr.VtVec4hArray other);
        public virtual string ToString();
    }

    [System.Reflection.DefaultMember(@"Item")] public class VtVec4iArray : pxr.Vt_ArrayBase
    {
        public pxr.GfVec4i this[int index] { get; set; }
        public VtVec4iArray() {}
        public VtVec4iArray(pxr.VtVec4iArray other) {}
        public VtVec4iArray(System.UInt32 n) {}
        public VtVec4iArray(System.UInt32 n, pxr.GfVec4i value) {}
        public void assign(System.UInt32 n, pxr.GfVec4i fill);
        public System.UInt32 capacity();
        public void clear();
        public void CopyFromArray(pxr.GfVec4i[] src);
        public void CopyFromArray(System.IntPtr src);
        public void CopyToArray(pxr.GfVec4i[] dest);
        public void CopyToArray(System.IntPtr dest);
        public virtual void Dispose();
        public bool empty();
        public static bool Equals(pxr.VtVec4iArray lhs, pxr.VtVec4iArray rhs);
        protected virtual void Finalize();
        protected pxr.GfVec4i GetValue(int index);
        public bool IsIdentical(pxr.VtVec4iArray other);
        public void pop_back();
        public void push_back(pxr.GfVec4i elem);
        public void reserve(System.UInt32 num);
        public void resize(System.UInt32 newSize);
        protected void SetValue(int index, pxr.GfVec4i value);
        public System.UInt32 size();
        public void swap(pxr.VtVec4iArray other);
        public virtual string ToString();
    }
}

namespace USD.NET
{
    public class AccessMask
    {
        public System.Collections.Generic.Dictionary<pxr.SdfPath, USD.NET.DeserializationContext> Included;
        public AccessMask() {}
    }

    public class ArrayPool
    {
        protected static readonly System.Type[] sm_defaultCtor;
        protected static readonly object[] sm_noParameters;
        public ArrayPool() {}
        public virtual void Free(System.Type arrayType, System.UInt32 size, System.Array array);
        public virtual void FreeHandle<T>(T handle);
        public virtual void FreeHandle(System.Type type, object handle);
        public virtual T[] Malloc<T>(System.UInt32 size);
        public virtual object MallocHandle(System.Type type);
    }

    public class ArrayUnpool : USD.NET.ArrayPool
    {
        public ArrayUnpool() {}
        public virtual void Free(System.Type type, System.UInt32 size, System.Array array);
        public virtual void FreeHandle<T>(T handle);
        public virtual void FreeHandle(System.Type type, object handle);
        public virtual T[] Malloc<T>(System.UInt32 size);
        public virtual object MallocHandle(System.Type type);
    }

    public interface Connectable
    {
        public abstract string GetConnectedPath();
        public abstract object GetValue();
        public abstract System.Type GetValueType();
        public abstract void SetConnectedPath(string path);
        public abstract void SetValue(object value);
    }

    public class Connectable<T> : USD.NET.Connectable
    {
        public T defaultValue;
        public string connectedPath { get; }
        public Connectable() {}
        public Connectable(T defaultValue) {}
        public virtual string GetConnectedPath();
        public virtual object GetValue();
        public virtual System.Type GetValueType();
        public bool IsConnected();
        public virtual void SetConnectedPath(string path);
        public void SetConnectedPath(string path, string attribute);
        public virtual void SetValue(object value);
    }

    public class CustomDataAttribute : System.Attribute
    {
        public CustomDataAttribute() {}
    }

    public class DefaultConversions
    {
        public DefaultConversions() {}
        public static pxr.VtValue CastToVtValue<T>(T t, System.Type trueType) where T : class;
        public static pxr.VtValue ToVtValue(object value);
    }

    public class ForceNoNamespaceAttribute : System.Attribute
    {
        public ForceNoNamespaceAttribute() {}
    }

    public class DeserializationContext
    {
        public System.Collections.Generic.HashSet<System.Reflection.MemberInfo> dynamicMembers;
        public USD.NET.IRestorableData cachedData;
        public DeserializationContext() {}
    }

    public class FusedDisplayColorAttribute : System.Attribute
    {
        public FusedDisplayColorAttribute() {}
    }

    public class FusedTransformAttribute : System.Attribute
    {
        public FusedTransformAttribute() {}
    }

    public interface IArbitraryPrimvars
    {
        public abstract void AddPrimvars(System.Collections.Generic.List<string> primvars);
        public abstract System.Collections.Generic.Dictionary<string, USD.NET.Primvar<object>> GetArbitraryPrimvars();
    }

    public interface IRestorableData
    {
    }

    public class IntrinsicTypeConverter
    {
        public IntrinsicTypeConverter() {}
        public static pxr.SdfAssetPath[] FromVtArray(pxr.SdfAssetPathArray input);
        public static bool[] FromVtArray(pxr.VtBoolArray input);
        public static byte[] FromVtArray(pxr.VtUCharArray input);
        public static double[] FromVtArray(pxr.VtDoubleArray input);
        public static int[] FromVtArray(pxr.VtIntArray input);
        public static long[] FromVtArray(pxr.VtInt64Array input);
        public static float[] FromVtArray(pxr.VtFloatArray input);
        public static string[] FromVtArray(pxr.VtTokenArray input);
        public static System.UInt32[] FromVtArray(pxr.VtUIntArray input);
        public static System.UInt64[] FromVtArray(pxr.VtUInt64Array input);
        public static void FromVtArray(pxr.SdfAssetPathArray input, ref pxr.SdfAssetPath[] output);
        public static void FromVtArray(pxr.VtBoolArray input, ref bool[] output);
        public static void FromVtArray(pxr.VtInt64Array input, ref long[] output);
        public static void FromVtArray(pxr.VtIntArray input, ref int[] output);
        public static void FromVtArray(pxr.VtTokenArray input, ref string[] output);
        public static void FromVtArray(pxr.VtUCharArray input, ref byte[] output);
        public static void FromVtArray(pxr.VtUInt64Array input, ref System.UInt64[] output);
        public static void FromVtArray(pxr.VtUIntArray input, ref System.UInt32[] output);
        public static string JoinNamespace(string first, string second);
        public static System.Collections.Generic.List<pxr.SdfAssetPath> ListFromVtArray(pxr.SdfAssetPathArray input);
        public static System.Collections.Generic.List<bool> ListFromVtArray(pxr.VtBoolArray input);
        public static System.Collections.Generic.List<byte> ListFromVtArray(pxr.VtUCharArray input);
        public static System.Collections.Generic.List<double> ListFromVtArray(pxr.VtDoubleArray input);
        public static System.Collections.Generic.List<int> ListFromVtArray(pxr.VtIntArray input);
        public static System.Collections.Generic.List<long> ListFromVtArray(pxr.VtInt64Array input);
        public static System.Collections.Generic.List<float> ListFromVtArray(pxr.VtFloatArray input);
        public static System.Collections.Generic.List<string> ListFromVtArray(pxr.VtTokenArray input);
        public static System.Collections.Generic.List<System.UInt32> ListFromVtArray(pxr.VtUIntArray input);
        public static System.Collections.Generic.List<System.UInt64> ListFromVtArray(pxr.VtUInt64Array input);
        public static pxr.SdfAssetPathArray ListToVtArray(System.Collections.Generic.List<pxr.SdfAssetPath> input);
        public static pxr.VtBoolArray ListToVtArray(System.Collections.Generic.List<bool> input);
        public static pxr.VtDoubleArray ListToVtArray(System.Collections.Generic.List<double> input);
        public static pxr.VtFloatArray ListToVtArray(System.Collections.Generic.List<float> input);
        public static pxr.VtInt64Array ListToVtArray(System.Collections.Generic.List<long> input);
        public static pxr.VtIntArray ListToVtArray(System.Collections.Generic.List<int> input);
        public static pxr.VtTokenArray ListToVtArray(System.Collections.Generic.List<string> input);
        public static pxr.VtUCharArray ListToVtArray(System.Collections.Generic.List<byte> input);
        public static pxr.VtUInt64Array ListToVtArray(System.Collections.Generic.List<System.UInt64> input);
        public static pxr.VtUIntArray ListToVtArray(System.Collections.Generic.List<System.UInt32> input);
        public static string MakeValidIdentifier(string unityIdentifier);
        public static pxr.SdfAssetPathArray ToVtArray(pxr.SdfAssetPath[] input);
        public static pxr.VtBoolArray ToVtArray(bool[] input);
        public static pxr.VtDoubleArray ToVtArray(double[] input);
        public static pxr.VtFloatArray ToVtArray(float[] input);
        public static pxr.VtInt64Array ToVtArray(long[] input);
        public static pxr.VtIntArray ToVtArray(int[] input);
        public static pxr.VtTokenArray ToVtArray(string[] input);
        public static pxr.VtUCharArray ToVtArray(byte[] input);
        public static pxr.VtUInt64Array ToVtArray(System.UInt64[] input);
        public static pxr.VtUIntArray ToVtArray(System.UInt32[] input);
    }

    public enum Orientation
    {
        public const USD.NET.Orientation LeftHanded = 1;
        public const USD.NET.Orientation RightHanded = 0;
        public int value__;
    }

    public class Primvar<T> : USD.NET.PrimvarBase, USD.NET.ValueAccessor
    {
        public T value;
        public bool IsArray { get; }
        public int Length { get; }
        public Primvar() {}
        public virtual object GetValue();
        public virtual System.Type GetValueType();
        public virtual void SetValue(object o);
    }

    public class PrimvarBase
    {
        [USD.NET.UsdMetadata] public int elementSize;
        [USD.NET.UsdMetadata] public int[] indices;
        [USD.NET.UsdMetadata] public USD.NET.PrimvarInterpolation interpolation;
        public PrimvarBase() {}
        public pxr.TfToken GetInterpolationToken();
        public void SetInterpolationToken(pxr.TfToken token);
    }

    public enum PrimvarInterpolation
    {
        public const USD.NET.PrimvarInterpolation Constant = 0;
        public const USD.NET.PrimvarInterpolation FaceVarying = 4;
        public const USD.NET.PrimvarInterpolation Uniform = 1;
        public int value__;
        public const USD.NET.PrimvarInterpolation Varying = 2;
        public const USD.NET.PrimvarInterpolation Vertex = 3;
    }

    public enum Purpose
    {
        public const USD.NET.Purpose Default = 0;
        public const USD.NET.Purpose Guide = 3;
        public const USD.NET.Purpose Proxy = 2;
        public const USD.NET.Purpose Render = 1;
        public int value__;
    }

    public class RangeIterator : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.Generic.IEnumerator<pxr.UsdPrim>, System.Collections.IEnumerable, System.Collections.IEnumerator, System.IDisposable
    {
        public virtual pxr.UsdPrim Current { get; }
        public RangeIterator(pxr.UsdPrimRange range) {}
        public virtual void Dispose();
        public virtual System.Collections.Generic.IEnumerator<pxr.UsdPrim> GetEnumerator();
        public bool IsPostVisit();
        public virtual bool MoveNext();
        public void PruneChildren();
        public virtual void Reset();
    }

    public class Relationship
    {
        public string[] targetPaths;
        public Relationship() {}
        public Relationship(string targetPath) {}
        public Relationship(string[] targetPaths) {}
        public string GetOnlyTarget();
        public string GetTarget(int index);
        public static USD.NET.Relationship op_Implicit(string path);
        public static USD.NET.Relationship op_Implicit(string[] paths);
    }

    public class SampleBase
    {
        public SampleBase() {}
        public void Free();
    }

    public class SampleCollection<T> : System.Collections.Generic.IEnumerable<USD.NET.SampleEnumerator<T>>, System.Collections.IEnumerable where T : USD.NET.SampleBase, new()
    {
        public SampleCollection(USD.NET.Scene scene, pxr.SdfPathVector paths) {}
        public virtual System.Collections.Generic.IEnumerator<USD.NET.SampleEnumerator<T>> GetEnumerator();
    }

    public class SampleEnumerator<T> : System.Collections.Generic.IEnumerator<USD.NET.SampleEnumerator<T>>, System.Collections.IEnumerator, System.IDisposable where T : USD.NET.SampleBase, new()
    {
        public virtual USD.NET.SampleEnumerator<T> Current { get; }
        public SampleEnumerator(USD.NET.Scene scene, pxr.SdfPath[] paths) {}
        public virtual void Dispose();
        public virtual bool MoveNext();
        public virtual void Reset();
        public class SampleHolder<T> where T : USD.NET.SampleBase, new()
        {
            public pxr.SdfPath path;
            public T sample;
            public SampleHolder() {}
        }
    }

    public class Scene
    {
        public USD.NET.AccessMask AccessMask { get; set; }
        [System.Obsolete(@"Use Find<MeshSample>() instead. This API will be removed in a future release.")] public pxr.SdfPath[] AllMeshes { get; }
        public pxr.SdfPath[] AllPaths { get; }
        [System.Obsolete(@"Use Find<XformableSample>() instead. This API will be removed in a future release.")] public pxr.SdfPath[] AllXforms { get; }
        public double EndTime { get; set; }
        public string FilePath { get; }
        public double FrameRate { get; set; }
        public bool IsPopulatingAccessMask { get; set; }
        public pxr.UsdStage Stage { get; }
        public double StartTime { get; set; }
        public System.Nullable<double> Time { get; set; }
        public USD.NET.Scene.UpAxes UpAxis { get; set; }
        public USD.NET.Scene.WriteModes WriteMode { get; set; }
        public void AddSubLayer(USD.NET.Scene over);
        public void Close();
        public System.Collections.Generic.Dictionary<string, double[]> ComputeKeyFrames(string rootPath, string attribute);
        public static USD.NET.Scene Create();
        public static USD.NET.Scene Create(string filePath);
        public pxr.SdfPath[] Find<T>() where T : USD.NET.SampleBase, new();
        public pxr.SdfPath[] Find<T>(pxr.SdfPath rootPath) where T : USD.NET.SampleBase, new();
        public pxr.SdfPath[] Find<T>(string rootPath) where T : USD.NET.SampleBase, new();
        public pxr.SdfPath[] Find(string rootPath, string usdSchemaTypeName);
        public void FlattenAs(string filePath);
        public pxr.UsdAttribute GetAttributeAtPath(string attrPath);
        public pxr.UsdPrim GetPrimAtPath(string primPath);
        public pxr.UsdRelationship GetRelationshipAtPath(string relPath);
        public pxr.SdfPath GetSdfPath(string path);
        public static USD.NET.Scene Open(pxr.UsdStage stage);
        public static USD.NET.Scene Open(string filePath);
        public void Read<T>(pxr.SdfPath path, T sample) where T : USD.NET.SampleBase;
        public void Read<T>(string path, T sample) where T : USD.NET.SampleBase;
        public void Read<T>(pxr.SdfPath path, System.Reflection.FieldInfo fieldInfo, ref T memberValue);
        public void Read<T>(pxr.SdfPath path, System.Reflection.PropertyInfo propInfo, ref T memberValue);
        public void Read<T>(string path, System.Reflection.FieldInfo fieldInfo, ref T memberValue);
        public void Read<T>(string path, System.Reflection.PropertyInfo fieldInfo, ref T memberValue);
        public USD.NET.SampleCollection<T> ReadAll<T>() where T : USD.NET.SampleBase, new();
        public USD.NET.SampleCollection<T> ReadAll<T>(pxr.SdfPath rootPath) where T : USD.NET.SampleBase, new();
        public USD.NET.SampleCollection<T> ReadAll<T>(pxr.SdfPath[] paths) where T : USD.NET.SampleBase, new();
        public USD.NET.SampleCollection<T> ReadAll<T>(string rootPath) where T : USD.NET.SampleBase, new();
        public void Save();
        public void SaveAs(string filePath);
        public void SetEditTarget(USD.NET.Scene other);
        public void SetInterpolation(USD.NET.Scene.InterpolationMode mode);
        public virtual string ToString();
        public void Write<T>(pxr.SdfPath path, T sample) where T : USD.NET.SampleBase;
        public void Write<T>(string path, T sample) where T : USD.NET.SampleBase;
        public enum InterpolationMode
        {
            public const USD.NET.Scene.InterpolationMode Held = 0;
            public const USD.NET.Scene.InterpolationMode Linear = 1;
            public int value__;
        }
        public enum UpAxes
        {
            public int value__;
            public const USD.NET.Scene.UpAxes Y = 0;
            public const USD.NET.Scene.UpAxes Z = 1;
        }
        public enum WriteModes
        {
            public const USD.NET.Scene.WriteModes Define = 0;
            public const USD.NET.Scene.WriteModes Over = 1;
            public int value__;
        }
    }

    public class SiblingIterator : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.Generic.IEnumerator<pxr.UsdPrim>, System.Collections.IEnumerable, System.Collections.IEnumerator, System.IDisposable
    {
        public virtual pxr.UsdPrim Current { get; }
        public SiblingIterator(pxr.UsdPrimSiblingRange range) {}
        public virtual void Dispose();
        public virtual System.Collections.Generic.IEnumerator<pxr.UsdPrim> GetEnumerator();
        public virtual bool MoveNext();
        public virtual void Reset();
    }

    public enum SubdivScheme
    {
        public const USD.NET.SubdivScheme Bilinear = 3;
        public const USD.NET.SubdivScheme CatmullClark = 1;
        public const USD.NET.SubdivScheme Loop = 2;
        public const USD.NET.SubdivScheme None = 0;
        public int value__;
    }

    public class SubtreeIterator : System.Collections.Generic.IEnumerable<pxr.UsdPrim>, System.Collections.Generic.IEnumerator<pxr.UsdPrim>, System.Collections.IEnumerable, System.Collections.IEnumerator, System.IDisposable
    {
        public virtual pxr.UsdPrim Current { get; }
        public SubtreeIterator(pxr.UsdPrimSubtreeRange range) {}
        public virtual void Dispose();
        public virtual System.Collections.Generic.IEnumerator<pxr.UsdPrim> GetEnumerator();
        public virtual bool MoveNext();
        public virtual void Reset();
    }

    public delegate object ToCsConverter(pxr.VtValue value);

    public delegate pxr.VtValue ToVtConverter(object value);

    public class TypeBinder
    {
        public static bool EnableCodeGeneration;
        public TypeBinder() {}
        public void AddTypeAlias(pxr.SdfValueTypeName alias, pxr.SdfValueTypeName target);
        public void BindArrayType<ConverterT>(System.Type csType, System.Type vtArrayType, pxr.SdfValueTypeName sdfName, string methodNamePrefix = );
        public void BindNativeType(System.Type csType, pxr.SdfValueTypeName sdfName);
        public void BindType(System.Type csType, USD.NET.UsdTypeBinding binding);
        public bool GetBinding(System.Type key, out USD.NET.UsdTypeBinding binding);
        public bool GetReverseBinding(pxr.SdfValueTypeName key, out USD.NET.UsdTypeBinding binding);
        public bool GetReverseBinding(System.Type key, out USD.NET.UsdTypeBinding binding);
        public bool RemoveTypeAlias(pxr.SdfValueTypeName alias);
    }

    public class UsdAssetPathAttribute : System.Attribute
    {
        public UsdAssetPathAttribute() {}
    }

    public class UsdIo
    {
        public static USD.NET.ArrayPool ArrayAllocator;
        public static USD.NET.TypeBinder Bindings { get; }
        public UsdIo(object stageLock) {}
        public void Deserialize<T>(T t, pxr.UsdPrim prim, pxr.UsdTimeCode usdTime, System.Collections.Generic.HashSet<System.Reflection.MemberInfo> accessMap, ref System.Nullable<bool> mayVary, string usdNamespace = default(string)) where T : USD.NET.SampleBase;
        public void Deserialize(ref object fieldValue, pxr.UsdPrim prim, pxr.UsdTimeCode usdTime, System.Reflection.FieldInfo field, System.Collections.Generic.HashSet<System.Reflection.MemberInfo> accessMap, ref System.Nullable<bool> mayVary, string usdNamespace = default(string));
        public void Deserialize(ref object propValue, pxr.UsdPrim prim, pxr.UsdTimeCode usdTime, System.Reflection.PropertyInfo field, System.Collections.Generic.HashSet<System.Reflection.MemberInfo> accessMap, ref System.Nullable<bool> mayVary, string usdNamespace = default(string));
        public void Serialize<T>(T t, pxr.UsdPrim prim, pxr.UsdTimeCode usdTime, string usdNamespace = default(string));
    }

    public class UsdMetadataAttribute : System.Attribute
    {
        public UsdMetadataAttribute() {}
    }

    public class UsdNamespaceAttribute : System.Attribute
    {
        public string Name { get; }
        public UsdNamespaceAttribute(string name) {}
    }

    public class UsdRelationshipAttribute : System.Attribute
    {
        public UsdRelationshipAttribute() {}
    }

    public class UsdSchemaAttribute : System.Attribute
    {
        public string Name { get; }
        public UsdSchemaAttribute(string name) {}
    }

    public struct UsdTypeBinding
    {
        public pxr.SdfValueTypeName sdfTypeName;
        public USD.NET.ToCsConverter toCsObject;
        public USD.NET.ToVtConverter toVtValue;
        public UsdTypeBinding(USD.NET.ToVtConverter toVtConverter, USD.NET.ToCsConverter toCsConverter, pxr.SdfValueTypeName sdfName) {}
    }

    public class UsdVariabilityAttribute : System.Attribute
    {
        public pxr.SdfVariability SdfVariability { get; }
        public UsdVariabilityAttribute(USD.NET.Variability variability) {}
    }

    public interface ValueAccessor
    {
        public abstract object GetValue();
        public abstract System.Type GetValueType();
        public abstract void SetValue(object value);
    }

    public enum Variability
    {
        public const USD.NET.Variability Uniform = 1;
        public int value__;
        public const USD.NET.Variability Varying = 0;
    }

    public class VertexDataAttribute : System.Attribute
    {
        public static pxr.TfToken Interpolation;
        public int ElementSize { get; set; }
        public VertexDataAttribute() {}
        public VertexDataAttribute(int elementSize) {}
    }

    public enum Visibility
    {
        public const USD.NET.Visibility Inherited = 0;
        public const USD.NET.Visibility Invisible = 1;
        public int value__;
    }
}
