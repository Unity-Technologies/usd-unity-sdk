//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.12
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace pxr
{
    public class UsdPrimRange :
        global::System.Collections.IEnumerable,
        global::System.Collections.Generic.IEnumerable<UsdPrim>
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal UsdPrimRange(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(UsdPrimRange obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~UsdPrimRange()
        {
            Dispose();
        }

        public virtual void Dispose()
        {
            lock (this) {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        UsdCsPINVOKE.delete_UsdPrimRange(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
                global::System.GC.SuppressFinalize(this);
            }
        }

        // Returning an externally defined class is ugly, but dramatically simplifies the bindings while
        // allowing the use of C#'s foreach mechanism.
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new USD.NET.RangeIterator(this);
        }

        public System.Collections.Generic.IEnumerator<UsdPrim> GetEnumerator()
        {
            return new USD.NET.RangeIterator(this);
        }

        public class EndSentinel : global::System.IDisposable
        {
            private global::System.Runtime.InteropServices.HandleRef swigCPtr;
            protected bool swigCMemOwn;

            internal EndSentinel(global::System.IntPtr cPtr, bool cMemoryOwn)
            {
                swigCMemOwn = cMemoryOwn;
                swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
            }

            internal static global::System.Runtime.InteropServices.HandleRef getCPtr(EndSentinel obj)
            {
                return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
            }

            ~EndSentinel()
            {
                Dispose();
            }

            public virtual void Dispose()
            {
                lock (this) {
                    if (swigCPtr.Handle != global::System.IntPtr.Zero)
                    {
                        if (swigCMemOwn)
                        {
                            swigCMemOwn = false;
                            UsdCsPINVOKE.delete_UsdPrimRange_EndSentinel(swigCPtr);
                        }
                        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                    }
                    global::System.GC.SuppressFinalize(this);
                }
            }
        }

        public class iterator : global::System.IDisposable
        {
            private global::System.Runtime.InteropServices.HandleRef swigCPtr;
            protected bool swigCMemOwn;

            internal iterator(global::System.IntPtr cPtr, bool cMemoryOwn)
            {
                swigCMemOwn = cMemoryOwn;
                swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
            }

            internal static global::System.Runtime.InteropServices.HandleRef getCPtr(iterator obj)
            {
                return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
            }

            ~iterator()
            {
                Dispose();
            }

            public virtual void Dispose()
            {
                lock (this) {
                    if (swigCPtr.Handle != global::System.IntPtr.Zero)
                    {
                        if (swigCMemOwn)
                        {
                            swigCMemOwn = false;
                            UsdCsPINVOKE.delete_UsdPrimRange_iterator(swigCPtr);
                        }
                        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                    }
                    global::System.GC.SuppressFinalize(this);
                }
            }

            public iterator() : this(UsdCsPINVOKE.new_UsdPrimRange_iterator__SWIG_0(), true)
            {
            }

            public iterator(UsdPrimRange.EndSentinel e) : this(UsdCsPINVOKE.new_UsdPrimRange_iterator__SWIG_1(UsdPrimRange.EndSentinel.getCPtr(e)), true)
            {
                if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            }

            public bool IsPostVisit()
            {
                bool ret = UsdCsPINVOKE.UsdPrimRange_iterator_IsPostVisit(swigCPtr);
                return ret;
            }

            public void PruneChildren()
            {
                UsdCsPINVOKE.UsdPrimRange_iterator_PruneChildren(swigCPtr);
            }

            public void MoveNext()
            {
                UsdCsPINVOKE.UsdPrimRange_iterator_MoveNext(swigCPtr);
            }

            public UsdPrim GetCurrent()
            {
                UsdPrim ret = new UsdPrim(UsdCsPINVOKE.UsdPrimRange_iterator_GetCurrent(swigCPtr), true);
                return ret;
            }

            public static bool Equals(UsdPrimRange.iterator lhs, UsdPrimRange.iterator rhs)
            {
                bool ret = UsdCsPINVOKE.UsdPrimRange_iterator_Equals(UsdPrimRange.iterator.getCPtr(lhs), UsdPrimRange.iterator.getCPtr(rhs));
                if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
                return ret;
            }

            override public int GetHashCode()
            {
                int ret = UsdCsPINVOKE.UsdPrimRange_iterator_GetHashCode(swigCPtr);
                return ret;
            }

            public static bool operator==(UsdPrimRange.iterator lhs, UsdPrimRange.iterator rhs)
            {
                // The Swig binding glue will re-enter this operator comparing to null, so
                // that case must be handled explicitly to avoid an infinite loop. This is still
                // not great, since it crosses the C#/C++ barrier twice. A better approache might
                // be to return a simple value from C++ that can be compared in C#.
                bool lnull = lhs as object == null;
                bool rnull = rhs as object == null;
                return (lnull == rnull) && ((lnull && rnull) || UsdPrimRange.iterator.Equals(lhs, rhs));
            }

            public static bool operator!=(UsdPrimRange.iterator lhs, UsdPrimRange.iterator rhs)
            {
                return !(lhs == rhs);
            }

            override public bool Equals(object rhs)
            {
                return UsdPrimRange.iterator.Equals(this, rhs as UsdPrimRange.iterator);
            }
        }

        public UsdPrimRange() : this(UsdCsPINVOKE.new_UsdPrimRange__SWIG_0(), true)
        {
        }

        public UsdPrimRange(UsdPrim start) : this(UsdCsPINVOKE.new_UsdPrimRange__SWIG_1(UsdPrim.getCPtr(start)), true)
        {
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
        }

        public UsdPrimRange(UsdPrim start, Usd_PrimFlagsPredicate predicate) : this(UsdCsPINVOKE.new_UsdPrimRange__SWIG_2(UsdPrim.getCPtr(start), Usd_PrimFlagsPredicate.getCPtr(predicate)), true)
        {
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
        }

        public static UsdPrimRange PreAndPostVisit(UsdPrim start)
        {
            UsdPrimRange ret = new UsdPrimRange(UsdCsPINVOKE.UsdPrimRange_PreAndPostVisit__SWIG_0(UsdPrim.getCPtr(start)), true);
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public static UsdPrimRange PreAndPostVisit(UsdPrim start, Usd_PrimFlagsPredicate predicate)
        {
            UsdPrimRange ret = new UsdPrimRange(UsdCsPINVOKE.UsdPrimRange_PreAndPostVisit__SWIG_1(UsdPrim.getCPtr(start), Usd_PrimFlagsPredicate.getCPtr(predicate)), true);
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public static UsdPrimRange AllPrims(UsdPrim start)
        {
            UsdPrimRange ret = new UsdPrimRange(UsdCsPINVOKE.UsdPrimRange_AllPrims(UsdPrim.getCPtr(start)), true);
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public static UsdPrimRange AllPrimsPreAndPostVisit(UsdPrim start)
        {
            UsdPrimRange ret = new UsdPrimRange(UsdCsPINVOKE.UsdPrimRange_AllPrimsPreAndPostVisit(UsdPrim.getCPtr(start)), true);
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public static UsdPrimRange Stage(UsdStageWeakPtr stage, Usd_PrimFlagsPredicate predicate)
        {
            UsdPrimRange ret = new UsdPrimRange(UsdCsPINVOKE.UsdPrimRange_Stage__SWIG_0(UsdStageWeakPtr.getCPtr(stage), Usd_PrimFlagsPredicate.getCPtr(predicate)), true);
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public static UsdPrimRange Stage(UsdStageWeakPtr stage)
        {
            UsdPrimRange ret = new UsdPrimRange(UsdCsPINVOKE.UsdPrimRange_Stage__SWIG_1(UsdStageWeakPtr.getCPtr(stage)), true);
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public UsdPrimRange.iterator GetStart()
        {
            UsdPrimRange.iterator ret = new UsdPrimRange.iterator(UsdCsPINVOKE.UsdPrimRange_GetStart(swigCPtr), true);
            return ret;
        }

        public UsdPrim GetCurrent()
        {
            UsdPrim ret = new UsdPrim(UsdCsPINVOKE.UsdPrimRange_GetCurrent(swigCPtr), true);
            return ret;
        }

        public UsdPrimRange.iterator GetEnd()
        {
            UsdPrimRange.iterator ret = new UsdPrimRange.iterator(UsdCsPINVOKE.UsdPrimRange_GetEnd(swigCPtr), true);
            return ret;
        }

        public void IncrementBegin()
        {
            UsdCsPINVOKE.UsdPrimRange_IncrementBegin(swigCPtr);
        }

        public void SetBegin(UsdPrimRange.iterator newBegin)
        {
            UsdCsPINVOKE.UsdPrimRange_SetBegin(swigCPtr, UsdPrimRange.iterator.getCPtr(newBegin));
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
        }

        public bool IsEmpty()
        {
            bool ret = UsdCsPINVOKE.UsdPrimRange_IsEmpty(swigCPtr);
            return ret;
        }

        public static bool Equals(UsdPrimRange lhs, UsdPrimRange rhs)
        {
            bool ret = UsdCsPINVOKE.UsdPrimRange_Equals(UsdPrimRange.getCPtr(lhs), UsdPrimRange.getCPtr(rhs));
            if (UsdCsPINVOKE.SWIGPendingException.Pending) throw UsdCsPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        override public int GetHashCode()
        {
            int ret = UsdCsPINVOKE.UsdPrimRange_GetHashCode(swigCPtr);
            return ret;
        }

        public static bool operator==(UsdPrimRange lhs, UsdPrimRange rhs)
        {
            // The Swig binding glue will re-enter this operator comparing to null, so
            // that case must be handled explicitly to avoid an infinite loop. This is still
            // not great, since it crosses the C#/C++ barrier twice. A better approache might
            // be to return a simple value from C++ that can be compared in C#.
            bool lnull = lhs as object == null;
            bool rnull = rhs as object == null;
            return (lnull == rnull) && ((lnull && rnull) || UsdPrimRange.Equals(lhs, rhs));
        }

        public static bool operator!=(UsdPrimRange lhs, UsdPrimRange rhs)
        {
            return !(lhs == rhs);
        }

        override public bool Equals(object rhs)
        {
            return UsdPrimRange.Equals(this, rhs as UsdPrimRange);
        }
    }
}
